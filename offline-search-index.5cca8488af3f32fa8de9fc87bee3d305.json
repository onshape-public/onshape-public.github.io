[{"body":"Welcome to the Onshape Developer Documentation. You can find resources here for developing applications that integrate with Onshape. Use the navigation bar on the left to navigate through the documentation.\nNew to Onshape? See the Onshape Architecture guide. New to REST APIs? Continue to the API Introduction page. Ready to develop your first Onshape app? Start with our Quick Start section. Already a pro? Head right over to the Onshape API Explorer. Use https://companyName.onshape.com/glassworks/explorer for Enterprise accounts. Looking to share your app with others? Check out our App Store documentation. Stuck? Check out our Get Help section. ","categories":"","description":"","excerpt":"Welcome to the Onshape Developer Documentation. You can find resources ‚Ä¶","ref":"/docs/","tags":"","title":"Welcome to the Onshape Developer Documentation"},{"body":"This page explains the basics of using the Onshape REST API. If you are brand new to using APIs, we suggest you spend some time learning the basics from these free resources:\nhttps://docs.github.com/en/rest/guides/getting-started-with-the-rest-api https://www.freecodecamp.org/news/apis-for-beginners/ Onshape uses REST APIs to communicate with clients and third-party systems. Onshape lives in your browser, which means you call REST APIs like you would any other web page. The API call returns information instead of a web page, and the response is formatted in JSON (JavaScript Object Notation).\nYou can use our REST APIs to access the Onshape engine and data in real time. We currently support three REST API requests (following the HTTP standards):\nGET: Retrieve (read) information from the server (i.e., your Onshape documents). Any arguments included in the URL are sent to the server. POST: Update (write) the server with new information. Required data is included in the request body. DELETE: Delete information from the server. A typical REST API call in Onshape includes five major components:\nMethod: GET, POST, or DELETE Every Onshape API endpoint is labeled with its method type. URL: Specifies the API endpoint and part of the document that the API is calling Uses the following format: {base_url}/{fixed_url}. {base_url}: Onshape URL (i.e., https://cad.onshape.com/api or https://companyName.onshape.com/api for Enterprise accounts). {fixed_url}: the URL of the API endpoint (more about this later) Query parameters: Optional parameters for the API call Described in the drop-down content of every endpoint in the API Explorer (you‚Äôll learn about using our API Explorer in a later section). Headers: Defines the associated metadata, which is used by the server to process the request. Usually contains Content-Type and Accept. Content-Type: Usually application/json If the application downloads a file, Content-Type will be application/octet-stream Accept: found under Media type in the API response section on in the API Explorer. Payload body: Only applicable for POST requests Required for some POST requests; optional for others. Body template is available in the API drop-down in the API Explorer. Typically obtained and modified from the response of a related GET request (rather than manually) Onshape API Request Since Onshape is a web-based solution, it uses a URL to define what is loaded in the browser.\nExample Onshape URL: https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22\nhttps://cad.onshape.com/api is the base URL of the document. Every Enterprise account has a custom base URL: https://companyName.onshape.com/api documents/ or d/ is followed by a 24-character document ID. The document ID uniquely identifies an Onshape document. Next, w/ is followed by a 24-character workspace ID. The workspace ID uniquely identifies a workspace within the document. By default, a document is started with the Main workspace. To refer to a specific document version, replace w/ with v/, followed by the 24-character version ID. With every edit made in the document, a microversion of every document is automatically created with every edit. To refer to a specific microversion, replace w/ with m/, followed by the 24-character microversion ID. Note: POST requests are always made to a workspace, since versions and microversions are immutable. e/ is followed by a 24-character element ID. The element ID uniquely identifies an element (e.g., a tab that we see and access through the user interface). In this documentation, we often refer to the URL template as: {base_URL}/{endpoint}/d/{did}/{wvm}/{wvmid}/e/{eid} or sometimes /{endpoint}/DWVME/ for short.\nWhen your application is instantiated in a document, it is called with a URL like this:\nhttps://_your-server.your-domain.com_?documentId=e60c4803eaf2ac8be492c18e\u0026workspaceId=d2558da712764516cc9fec62\u0026elementId=6bed6b43463f6a46a37b4a22\u0026server=https%3A%2F%2Fcad.onshape.com\u0026userId=53da35fbe4b0412c60b5e3b7\u0026access=edit\u0026debug=true The query parameters passed from Onshape to your application are:\nParameter Description documentId Current document ID workspaceId, versionId, microversionId Current workspace ID OR version ID OR microversion ID elementId Current (application) element ID server The address of the current Onshape server. The server parameter is informational; REST requests should always be sent to cad.onshape.com. Enterprise accounts should be sent to companyName.onshape.com. userId Current user ID, which can be found by calling /api/users/current and obtaining the user ID from the id field. access Set to edit if the document should open with edit capabilities. Onshape API Response The REST API in Onshape communicates data in JSON format. If you are new to working with JSON, we recommend the following resources:\nhttps://www.w3schools.com/js/js_json_intro.asp https://www.freecodecamp.org/news/what-is-json-a-json-file-example/ The example below is the response from calling the getDocument API for this public document. A lot of information is returned, so we‚Äôve truncated the middle of the response below, but if we look at the very end of the resulting JSON, we can see that the response has correctly returned Onshape API Guide as the document name.\n{ \"jsonType\": \"document\", \"documentThumbnailElementId\": \"\", \"isUpgradedToLatestVersion\": true, \"public\": false, \"permission\": \"FULL\", \"isOrphaned\": false, \"recentVersion\": null, ... \"isEnterpriseOwned\": false, \"resourceType\": \"document\", \"name\": \"Onshape API Guide\", \"id\": \"e60c4803eaf2ac8be492c18e\", \"href\": \"https://cad.onshape.com/api/v6/documents/e60c4803eaf2ac8be492c18e\" } Versioning All endpoint calls are versioned. The version string is inserted directly after the /api/ path component. For instance, https://cad.onshape.com/api/v6/documents/e60c4803eaf2ac8be492c18e indicates a version 6 request to the Onshape getDocument endpoint.\nCalls within a version are compatible with one another; typically this means that a GET request can be fed back in as a POST at the same version. Versions are incremented whenever Onshape introduces a non-backwards-compatible change. Onshape users should always refer to the latest version in their calls. If no version is specified, the oldest version (v0) will be used.\nAPI Conventions The Onshape API generally uses the following conventions:\nOnshape generally supports only 3 methods: GET for read-only operations, POST for write operations, and DELETE for deletions. Onshape does not currently support other methods, such as PUT. Strings should be UTF-8 encoded. Query parameters are used for optional parameters. All required parameters are included in the path. For brevity, we use the following upper case letters in path definitions in this document: D Document ID (24-characters) W Workspace ID (24-characters) V Version ID (24-characters) M Microversion ID (24-characters) E Element ID (24-characters) The general form of a path is /resource/context/subresource. When present, the context identifies the document (D), the workspace, version or microversion (WVM), and the element (E). See the Onshape Architecture page for more information on Onshape‚Äôs basic API structure. Our intention is to provide Workspace, Version, and Microversion forms for all appropriate GET operations. POST will always be to a Workspace, as Versions and Microversions are immutable. Not all forms of all interfaces are implemented at this time. As of this writing, some API calls return information that is of use only for Onshape clients. You should generally only use the fields that are documented for external use. The internal data may be changed or removed without notice. Unit Designators The following strings are valid unit designators:\nFor length measures:\nmeter, meters, m millimeter, millimeters, mm centimeter, centimeters, cm inch, inches, in foot, feet, ft yard, yards, yd For angular measures:\ndegree, degrees, deg radian, radians, rad What Now? Continue on to our API Explorer page to learn about about navigating the Onshape APIs in our Glassworks API Explorer.\n","categories":"","description":"","excerpt":"This page explains the basics of using the Onshape REST API. If you ‚Ä¶","ref":"/docs/api-intro/","tags":"","title":"Introduction to the Onshape REST API"},{"body":"We document all available Onshape REST API endpoints in our Glassworks API Explorer:\nhttps://cad.onshape.com/glassworks/explorer/\nThis API Explorer site enables you to run API requests directly within its interface and provides the output from the API call. To try an endpoint in the API Explorer, follow these steps or follow along with the video below:\nOpen this public Onshape document in your browser: https://cad.onshape.com/documents/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22 Open the API Explorer in a new browser tab: https://cad.onshape.com/glassworks/explorer/ Note: For Enterprise accounts, substitue cad in this URL with your company name. Scroll down to Document. Click to expand the getDocument endpoint. (Hint: it appears in the API Ref as GET /documents/{did}). Go back to the public document you opened in Step 2, and copy the document ID from the Onshape URL (e60c4803eaf2ac8be492c18e). Paste the document ID into the did field in the API Explorer. Note: If you can‚Äôt edit the did field, click the Try it out button. This will toggle to a Cancel button when the fields are editable. Scroll down and click Execute. Note: If you receive a 403 error, see the Authentication section for help. Scroll to the bottom of the 200 response body. We have correctly returned Onshape API Guide as the document name. IMPORTANT NOTE: The documentation in the API Explorer reflects the supported interface. Some API calls may, for historical reasons, return additional undocumented fields. Unless the return fields are documented in the API Explorer, you should NOT use them, as they may be removed without warning. Your application should always ignore unexpected or undocumented return data. Onshape reserves the right to add, remove or change any undocumented fields.\nAuthentication You can authenticate in the API Explorer in one of three ways:\nOnshape: Open Onshape in a new tab in your browser. Sign in with your Onshape credentials. Onshape will pass your credentials to the API Explorer. API Keys: Click Authorize in the top-right of the API Explorer page and scroll to the bottom of the dialog. Provide your API access key in the Username field and your secret key in the Password field. See API Keys for help creating your API Keys. Do NOT enter your Onshape credentials. Click Authorize, and then click Close. Oauth: Click Authorize in the top-right of the API Explorer page. Fill out the OAuth fields. See OAuth for more information on autheneticating with OAuth2. Click Authorize, and then click Close. Use the Auto-fill feature Expand the endpoint you want to use in the API Explorer. Paste an entire Onshape URL into the top field. Click Auto-fill. The document ID, workspace/version/microversion ID, and element ID are pushed from the URL into the correct fields. Confirm all fields are filled out as expected. Not every parameter can be extracted from an Onshape URL, so there may be more fields to fill out. View response body docs Expand the endpoint you want to use the in API Explorer. Scroll down to the Responses section. Click Schema. Click the [...] symbols to expand the docs for the response JSON. View request body docs Expand the endpoint you want to use the in API Explorer. Click the Cancel button to make the schema viewable. Click Schema. Click the [...] symbols to expand the docs for the response JSON. Copy a cURL Expand the endpoint you want to use in the API Explorer. Fill out the parameter fields. Click Execute in the API Explorer. Copy the curl from the Curl field. Troubleshooting If the parameter fields in the API Explorer are grayed out, click the Try it Out! button to toggle it to a Cancel button. The parameter fields should become editable. If you can‚Äôt see the request body JSON docs, click the Cancel button to toggle it back to the Try it Out! button. If you see authentication issues, review the Authentication section above. ","categories":"","description":"","excerpt":"We document all available Onshape REST API endpoints in our Glassworks ‚Ä¶","ref":"/docs/api-intro/explorer/","tags":"","title":"API Explorer"},{"body":"Design in Onshape typically beings with a document, which is the container that includes all content related to a specific design. All data in an Onshape document is stored in Elements. Part Studios and Assemblies are two of the most common element types in a design. Throughout the design process, creating versions can be useful for product development management while working on the ‚ÄúMain‚Äù workspace. See also:\nThe API Introduction page for information on how documents, workspaces, and elements are assembled into a URL. The Associativity page for information on how Parts, Assemblies, and Elements relate to each other. Elements All data in an Onshape document are stored in Elements (represented as tabs in the user interface). Onshape documents contain five kinds of elements:\nPart Studio: Contains zero or more parts Assembly: Contains zero or more parts or assemblies Blob (Binary Large OBject): Can be provided by a partner or by the end user. For example, the user can upload a PDF file, an image, or a text file. Partner applications can store arbitrary data, but we recommend using the structured storage available in an element for better integration. Application: Presents an iframe to the user. The user interface is managed by a server that can be provided by a third-party. Onshape Drawings are a special case of an application element. Feature Studio: Contains the definition for Onshape Features, which are defined in FeatureScript. Workspaces, Versions, and Microversions A document is stored in Onshape as a collection of changes.\nYou can think of a workspace as a branch of the document, similar to a branch in a source control system. Documents can be branched to create new workspaces. Each individual change to the document creates a new document microversion. As the document is edited, changes are applied to the active workspace, creating new microversions. Periodically, the user may designate versions of the document. A version is a named snapshot of the entire document at some point in time (that is, at some microversion). You cannot change a version or microversion of a document; all changes are applied to a workspace (and create a new microversion). Thus, while in general the GET methods of the API can read from a version, microversion, or workspace, the POST methods generally require a workspace, and create a new microversion when data is written to the document. (An exception is that it is possible to set metadata within a version; this does not create a new microversion).\nThe following IDs are used by many of the APIs. Each ID (except for Geometry IDs such as Part, Face and Edge) is a 24-character string that is used internally by Onshape to uniquely identify the resource. The Geometry IDs are variable-length strings used to resolve to a specific geometric entity within a model.\nID Description User ID Identifies a single user. Document ID Identifies a document. The logged-in user must have access to the requested document for the API to succeed. Workspace ID The Workspace ID identifies a workspace within the document. Workspaces are used to distinguish between different branches of the document. Version ID The Version ID identifies a specific named version. Microversion ID The Microversion ID identifies an internal revision of the document. Element ID The Element ID identifies an element within the document. Part ID Face ID Edge ID The Part ID identifies a part within a part studio. The Part ID should generally not be stored for long-term use, as it is only expected to be valid during the course of a session. Note that a Part ID may reference a part that no longer exists if the model is changed, so it is best to specify a Version or Microversion to pick the context for the Part ID. Note that even with the Version or Microversion, internal changes to the Onshape system may also change the Part ID. Onshape provides mechanisms for maintaining persistent references. See the Associativity page for more information. Face and Edge IDs are used in similar ways.\nThe following table identifies Onshape concepts and the corresponding Git concepts. Note that this is not a direct mapping, and the implementation of the concepts is very different.\nOnshape concept Git concept Document Repository Element File Workspace Branch Version Tag Microversion Commit Linked Documents Although a document can contain a complex model tree involving many Part Studio and Assembly elements, it is often more efficient to split the content into multiple documents. Connections between documents always refer to a specific version of the target document. Once a version is used as the target of a linked document, that document version is preserved as long as any document references it, even if the containing document is deleted. Additionally, any user that has access to the referring document will have limited read access to the target document, regardless of what permissions are currently on the target document.\nConfigurations Onshape Part Studios can be constructed to be configurable using Onshape Configurations. API calls that reference Part Studios (primarily within the Parts and Part Studios APIs) often accept a configuration parameter that identifies what specific configuration of the Part Studios is being referenced. When not specified, the API implementation typically uses the configuration that is currently selected within the Part Studio. An interactive ad-hoc API call might not behave consistently in an application, so be sure to specify the configuration parameter where applicable.\nOnshape Data Model Onshape data is stored in replicated databases in the cloud. The Onshape data model is influenced by the Git data model and similar source code repositories.\nDocuments contain elements. Elements are presented as tabs in the user interface. With some exceptions, all data in a document is stored within an element. The following table describes what data stored in each Element type:\nElement Type Description Part Studio Each Part Studio contains exactly one Feature list. The Feature list contains Features such as sketches, planes, extrudes, etc. Each Feature contains one or parameters. Whenever the Feature list changes, the parametric history is evaluated, and the model is regenerated. Assembly Each Assembly contains an assembly tree, which contains parts and/or other assemblies (sub-assemblies), along with mate information. Onshape provides an API call to retrieve the assembly tree definition. Blob Each Blob element contains an uninterpreted binary object that has been uploaded to Onshape, typically from a file. Onshape depends on the browser client to display some blob data (e.g., PDF and image data), but does not interpret the data. A blob element can be updated with new data. Application Each Application element contains zero or more sub-elements, providing a structured set of transactional data that is defined and managed by an application. Application data can be displayed in the Onshape tab in an iframe; the application is responsible for rendering the data in the iframe from its server. Note that Onshape Drawing elements are Application elements managed by Onshape.\nTessellated data is not stored persistently in Onshape; it is generated on demand for display by the Onshape clients, or in response to application REST API requests. This data may be cached for performance.\nDocument data All elements, including Assemblies, Part Studios, Drawings, or even apps, are history based. Each change to an element or set of elements represents a unique record in the document‚Äôs history, known as a microversion. The document can be restored to that particular state any time in the future.\nPart Studio data The Part Studio element is defined by a list of features, some of which (e.g., a sketch), may have a complex internal structure composed of entities. Part Studio features and entities are referenced by unique persistent identifiers. Part Studio features and entities can appear, disappear, and reappear depending on the current microversion of the model.\nAssembly data The Assembly element is defined as a list of assembly features and a tree of subassemblies/part instances. Occurrence ID is a unique persistent identifier of an occurrence of a part in the assembly structure.\nExternal application data An external application has complete control over how it manages/stores documents, however, to take advantage of the Onshape data model, there is a set of endpoints they should use to store state. These are collectively known as the AppElement API.\nModel presentation data A valid model definition usually corresponds to a real-world manufacturable topology, represented internally as a set of parts, faces, edges, and vertices and the set of relations between them. Each of these has a unique identifier in every state of the model. The identifier represents an encoded index in the model‚Äôs history, and its value depends on the structure of the model‚Äôs history. The value is not guaranteed to be preserved across model changes, and will almost always change if the model changes in significant ways. The model can be tessellated into a set of geometric primitives, which approximate the shape of the model. Tessellated data can be used for visual representation of the model or other processing related to the shape of the model.\nThe following changes in the topological representation can occur between two microversions of the model:\nNew topological entities appear Id of existing topology change Topological entities disappear Existing topological entities are merged into a single entity Existing topological entity are split into multiple entities The model microversion and topology ID can be used to identify topological entities across the model changes. Topology ID defined in a specific microversion can be translated into a set of topology IDs in the current microversion of the model. (The Topology ID is sometimes referred to as a Deterministic ID within Onshape, and is exposed in specific API calls as partId, faceId, etc.). See the PartStudio APIs to see what topology IDs are exposed.\n","categories":"","description":"","excerpt":"Design in Onshape typically beings with a document, which is the ‚Ä¶","ref":"/docs/api-intro/architecture/","tags":"","title":"Architecture"},{"body":"In this example, we will call an Onshape REST API endpoint to send a document name to our console. Please note that the sample shown on this page is only designed to be used as a quick start guide and does not represent a full Onshape application.\nSystem Requirements You must be signed in to your Onshape account at https://cad.onshape.com (or https://companyName.onshape.com for Enterprise accounts). This example is coded in Python. The equivalent code is provided in other languages at the end of the example. To follow along with this tutorial, you can download and install Python here: https://www.python.org/downloads/. Review the API Endpoint Go to the API Explorer and scroll to Document. Expand the GET /documents/{did} endpoint. Note that in the URL, the name of this API is getDocument. Make a note of the URL structure and the parameters required to make this request. This will become the fixed URL part of our API call. For this endpoint, we only need to get the document ID from the document URL. Scroll down and make a note of the Media Type that we‚Äôll need to include in our header. Review the Document Navigate to this public document, and make a note of the document ID in the URL (e60c4803eaf2ac8be492c18e). Create your API Keys Go to https://dev-portal.onshape.com. In the left pane, click API keys. Click the Create new API key button. Select the following permissions for your app: Application can read your documents. Application can write to your documents. Click the Create API key button. Copy both the access key and secret key from the pop-up window, save them somewhere, then click the Close button. IMPORTANT NOTE: You will not be able to find the secret key again, so save it somewhere safe! The details for your application appear. Open your terminal and run the following command, replacing ACCESS_KEY and SECRET_KEY with the access key and secret key you created above. Remember to include the colon (:) between the keys. MacOS: printf ACCESS_KEY:SECRET_KEY | base64 Windows: powershell \"[convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes(\\\"ACCESS_KEY:SECRET_KEY\\\"))\" You will receive a long, base-64-encoded string. You will need this string later, so keep it somewhere safe. We‚Äôll refer to it as our CREDENTIALS. Write Your Code Create a new file called hello.py. Start your file by importing the necessary libraries. import requests import jsons Next, define the URL for the API call: # Assemble the URL for the API call api_url = \"ASSEMBLED_URL\" Replace ASSEMBLED_URL with the fully formed API. This is where we‚Äôll put together everything we‚Äôve learned so far: The base URL: https://cad.onshape.com/api https://companyName.onshape.com/api for Enterprise accounts The fixed URL is specified in the getDocument API in Glassworks: /documents/{did} The document ID parameter from the public document URL to include in the fixed URL: {did}: e60c4803eaf2ac8be492c18e Together, this makes the URL for our API request: https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e We don‚Äôt need to send any optional parameters with our request, so we can define them as an empty object: # Optional query parameters can be assigned params = {} Now, define your API keys: # Use the encoded authorization string you created from your API Keys. api_keys = (\"CREDENTIALS\") Replace CREDENTIALS with the string you created in the last section. Next, define your headers: # Define the header for the request headers = {'Accept': 'MEDIA_TYPE', 'Content-Type': 'application/json'} Replace MEDIA_TYPE with the Media type we obtained from the API Explorer during the Review the API section above: application/json;charset=UTF-8;qs=0.09 Put all the variables you just defined together into the request: # Put everything together to make the API request response = requests.get(api_url, params=params, auth=api_keys, headers=headers) And finally, print the name value from the response: # Convert the response to formatted JSON and print the `name` property print(json.dumps(response.json()[\"name\"], indent=4)) Make sure your file matches the full example below: import requests import jsons # Assemble the URL for the API call api_url = \"https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e\" # Optional query parameters can be assigned params = {} # Use the encoded authorization string you created from your API Keys. api_keys = (\"CREDENTIALS\") # Define the header for the request headers = {'Accept': 'application/json;charset=UTF-8;qs=0.09', 'Content-Type': 'application/json'} # Putting everything together to make the API request response = requests.get(api_url, params=params, auth=api_keys, headers=headers) # Convert the response to formatted JSON and print the `name` property print(json.dumps(response.json()[\"name\"], indent=4)) Run Your Code Open your terminal and navigate into the folder where you saved your hello.py file: cd ~/\u003cyour-file-path\u003e Install the necessary modules: python3 -m pip install requests python3 -m pip install jsons Run your code:python3 hello.py Confirm that your console displays:\"Onshape API Guide\" Other Language Examples Remember to replace CREDENTIALS with your credentials.\ncURL Returns the entire response json. Scroll to the bottom to the see name field.\ncurl -X 'GET' \\ https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e' \\ -H 'Content-Type: application/json' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' JavaScript import fetch from 'node-fetch'; async function getDocument(url='') { const response = await fetch(url, { method: 'GET', headers: { 'Content-Type': 'application/json', Accept: 'application/json;charset=UTF-8;qs=0.09', Authorization: `Basic ${btoa('CREDENTIALS')}` } }); return response.json(); } getDocument('https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e' ).then((data) =\u003e { console.log(data.name); }); C++ Returns the entire response json. Scroll to the bottom to the see name field.\n#include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e using namespace std; int main() { string url = \"curl \"; url += \"-X 'GET' \"; url += \"'https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e'\"; url += \"-H 'accept: application/json;charset=UTF-8; qs=0.09' \"; url += \"-H 'Authorization: Basic CREDENTIALS'\"; system(url.c_str()); return 0; } Python import requests import jsons # Assemble the URL for the API call api_url = \"https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e\" # Optional query parameters can be assigned params = {} # Use the encoded authorization string you created from your API Keys. api_keys = (\"CREDENTIALS\") # Define the header for the request headers = {'Accept': 'application/json;charset=UTF-8;qs=0.09', 'Content-Type': 'application/json'} # Putting everything together to make the API request response = requests.get(api_url, params=params, auth=api_keys, headers=headers) # Convert the response to formatted JSON and print the `name` property print(json.dumps(response.json()[\"name\"], indent=4)) ","categories":"","description":"","excerpt":"In this example, we will call an Onshape REST API endpoint to send a ‚Ä¶","ref":"/docs/api-intro/quickstart/","tags":"","title":"Quick Start"},{"body":"Why Onshape? As long as there have been applications that manage organizational data into a database, there has been a need to share that data between different departments and therefore, usually, different systems. In a typical design/manufacturing organization, there could be at least four or five mission-critical databases that manage the data for different departments and for different stages in the product‚Äôs lifecycle.\nInitially, these systems provide the capabilities required by their consumers (i.e., the departments that use these systems). For instance, the Finance might use QuickBooks, Manufacturing might use a manufacturing planning and execution system (MES), Engineering might use a Product Data management System (PDM), and so on for each group in the organization.\nThis often leads to disparate silos of data and knowledge. The departments in an organization do not work in a vacuum; each is dependent on information generated by other groups. For instance, Manufacturing can‚Äôt produce accurate assembly instructions without input from engineering on the designs and the bill of materials. Finance can‚Äôt price the product without understanding its contents and which parts are manufactured in-house or purchased.\nTherefore, the need to integrate these systems becomes critical for the organization to function optimally. Initially, connecting one system to another can be a straightforward process. This usually involves some services to get the systems to talk to each other, however it isn‚Äôt too painful as long as the requirements are clearly defined.\nAnyone who has implemented integrations between PLM (Product Lifecycle Management) systems or ERP (Enterprise Resource Planning) systems will tell you of the nightmare scenarios they encountered. Often this is the result of poorly scoped and defined requirements, conflicting requirements coming from multiple departments, and the many integration points required between systems. The result is that the organization is not getting what it wants or needs, the customer is paying for services that do not provide the promised solution, and usually the project is long overdue. All this equals an unhappy customer and often the software vendor‚Äôs solutions are blamed for the disaster.\nOver the years, many technologies have appeared (and some of them, just as quickly disappeared) to enable integration without the need to write thousands of lines of custom code that needs to be re-written for every software upgrade. Several technologies provide ‚Äúcodeless‚Äù integration between SaaS products (Zapier, for example). These solutions are particularly good for generic use cases for data exchange between systems, but can be limited when it comes to custom modifications to the data being sent that might be required by a specific customer. In addition, they have the overhead of requiring a subscription to their service. Sending corporate IP through another third-party can also cause data security issues.\nTherefore, we can understand that in most organizations integration between systems is a necessary evil that must be tackled, either with an out-of-the-box solution or through some custom coding.\nEarly on, Onshape understood that as an engineering system, it cannot exist in a vacuum; it must be able to communicate with other systems. For this reason, the REST API was developed.\nAn API, or¬†application programming interface, is a set of rules that define how applications or devices can connect to and communicate with each other. A REST API is an API that conforms to the design principles of the REST, or¬†representational state transfer¬†architectural style. For this reason, REST APIs are sometimes referred to RESTful APIs.\nOnshape SaaS Onshape was built from the ground up as a true SaaS-based system; Onshape had no investment in legacy code and was able to develop an application that truly runs as a multi-tenant SaaS solution from the first line of code. Many companies claim to run cloud-based solutions, but since they have such a large investment in their legacy code, that they can‚Äôt just discard and start again from scratch. Instead, they tend to try and port that code to the web.\nMore often than not, porting existing code to the web and calling it a SaaS solution is no more than a marketing ploy; it isn‚Äôt a true SaaS solution if it wasn‚Äôt written as one. These are generally known as cloud-hosted solutions. This means that a typical three-tier data management solution (which could have previously been installed on a set of servers), has now been modified to be hosted on the web.\nTraditional three-tier architecture Traditional PLM systems typically use a three-tier architecture, mainly consisting of an application server, a database server, and a client (either a web client or a thick client installed on the client hardware).\nTypical three-tier architecture\nTo connect to and integrate with this architecture, APIs are usually exposed on the application or web server. If this architecture is ported to the web, it cannot make customizations through the API, since it would modify the behavior of the program for everyone connected to that application server.\nSingle- vs multiple-tenant architectures The three-tier architecture is typical of most PLM solutions on the market today, which is fine if you want the solution to be installed on company servers and be accessible to people within the company only.\nWhen this type of solution is ported to the web, software vendors typically must create a single-tenant application where an application server and a database server are provisioned for each new customer.\nSingle-tenant architecture\nIn this case, the vendor must use expensive hardware to host more customers, which is not a sustainable model.\nModern 21st century software solutions use multi-tenant solutions that can be hosted on services such as Amazon cloud, Azure, etc. There are many benefits to this architecture, including that servers can be provisioned and decommissioned on the fly to provide ultimate performance whenever required. Since servers cost money, decommissioning servers when they are not required is a key benefit to a true SaaS solution.\nMulti-tenant architecture\nSince each application is separate in this architecture, we can enable customizations that can‚Äôt be implemented in a single-tenant architecture. For example, we can provide access to the REST APIs that are required for Onshape integration. In the single-tenant architecture, if you provide API access to the application server, one customer will be modifying that application for all customers who are registered on that tenant.\nThe Onshape Difference Onshape does not work like other legacy CAD systems. Onshape was built from scratch for the cloud and as a modern CAD system, so many of the failings of legacy CAD systems were excluded.\nThere are many differences and benefits to Onshape, which are well-documented in the Onshape Help and training materials.\nThe information in this section is specific to integrations, since Onshape does not behave like a traditional file-based systems. When writing an integration for Onshape, it is critical to understand the nuances in Onshape‚Äôs design practices and how data is organized in Onshape.\nData-driven/fileless Most traditional PDM/PLM systems integrated with CAD systems enable this integration on a per-file basis. This means that you have an object in the PDM/PLM system that corresponds directly to a file in the CAD system. In this way, the PDM/PLM system can manage access to the files, build assemblies from the files, view the CAD data, and much more.\nOnshape, however, does not work this way.\nBeing data-driven means that Onshape has no files, just data, so an integration into Onshape is going to look different from any integration to a CAD system that you might have done previously.\nIn traditional CAD, a single file represents a snapshot of what the design looked like at a specific moment in time. Unless it‚Äôs changed, it will remain in that state forever. PDM systems manage these files, and once a designer decides to make a revision or a release, the file is locked, and a new file can be created to represent any further updated versions or releases of the design. PDM/PLM systems are very good at managing this data in an up-to-date structure, but it does have the drawbacks. They generate many file copies of a specific design, and once a file is taken out from the system (for instance, to share with a supplier), it is no longer managed and tracked.\nOnshape uses data instead of files. The data is always up-to-date and can be collaborated on in real-time without the need to send file copies back and forth. This means that Onshape views versions and releases differently than those traditional systems do. When integrating with Onshape, we must design for data rather than files.\nFiles can be generated from the Onshape data. For example, you can generate a PDF of a drawing upon release or of a STEP file that can be used by other downstream systems.\nA key benefit of a data-driven system is the ability to retrieve detailed, real-time analytics. Onshape has comprehensive analytics; including who can view or edit a design, when and exactly what edits are made, which commands were used, and how long was spent modifying the design.\nBuilt in PDM Up until now, CAD was one software program, and PDM/PLM was another program that had to be integrated with the CAD. In many cases, both programs could be sold by the same software vendor (even though there are many PLM systems available that are sold by independent vendors who have no CAD system). Regardless, a PDM/PLM system always had to be an added solution to the CAD system.\nNo matter how deep the integration between a CAD system and a PLM system, there is always the need to sync data between the two. This is usually a weak point in any solution that is prone to errors.\nBeing data-driven, Onshape already has PDM built in as part of the CAD system. This is unique in the industry: CAD and PDM as part of the same solution with no additional piece of software required.\nOnshape‚Äôs revision and part number schema definition interface\nFor instance:\nSince the data is always up-to-date, the correct state of any design is always represented in real-time with no delay for syncing between systems.\nUnlike file-based systems, the data is never locked; it is always available and always changing.\nPDM system data management aspects are fully integrated into every aspect of the CAD system.\nTrue real-time collaboration/co-design on both design and data is enabled.\nSo, what does this mean when it comes to integrating Onshape with another PLM system? First and foremost, we must understand that there are many things that a PLM system does that Onshape‚Äôs PDM capabilities can‚Äôt do. Integrating Onshape to a PLM system should augment the powerful capabilities already available inside Onshape, not necessarily replace them. Similarly, Onshape does not replace PLM-native capabilities. Instead, depending on the business case, we can use the best-in-class capabilities of each system to augment the other.\nThe Onshape release process is an example of the augmentation of each system‚Äôs capabilities. Onshape has a specific way of managing the release of data that is different from traditional PDM systems. This capability is inherently suited to a data-driven approach and provides a lot of value to the update of design data in Onshape. At the same time, PLM systems provide enterprise release processes that may include many people and different departments that extend beyond the engineering domain. Such PLM processes can be highly customized and suited to the organizations established business processes.\nIn this scenario, it doesn‚Äôt make sense to avoid the enterprise release processes in the PLM system. However, also omitting Onshape‚Äôs release capabilities could put data between Onshape and the PLM system out of sync and prevent Onshape from updating data (e.g., watermarks and title blocks on drawings, icons related the visualizing the state of data, etc.).\nIn this case, we want to use the best-in-class features of each software solution without compromising the capability provided by each solution. If we plan our integration correctly, this can be achieved by initiating the release of the data in Onshape, transferring the release data to the PLM system where the release process will be triggered, and finally automating the release in Onshape once the process has been completed in the PLM system.\nMulti-part Part Studios In traditional CAD systems, one file typically equals one part. While design-in-context is available in most CAD systems, and multiple solid bodies can be created, each part is self-contained in a separate file. For PLM systems, this makes it easy to associate an object in the PDM/PLM database with a specific CAD file. This is not the case in Onshape.\nIn Onshape, parts are designed in what‚Äôs called a Part Studio. Within a Part Studio, the designer is free to create as many parts as they want. The general rule is that the parts should be related to each other in a system, thereby making it easier to design one part from another, however there is a lot of flexibility in how the designer wishes to work.\nAn example of a multi-part Part Studio in Onshape\nThe structure of the Onshape document is discussed in detail in the Onshape Architecture page. The Part Studio is included in an Onshape document.\nWe can already begin to understand that the traditional CAD/PDM paradigm of ‚Äúone file per object‚Äù will not work with Onshape; the designer would be forced by the PDM/PLM system to only create one part per Part Studio. This would therefore limit the designer‚Äôs freedom for creativity in Onshape and seriously reduce the powerful functionality available for the designer to use.\nTherefore, we need to re-think how we integrate with Onshape versus how we integrate with traditional CAD systems. Fortunately, Onshape‚Äôs REST API supports the multi-part Part Studio scenario. Instead of associating a file with an object in the PDM/PLM database, we now use the REST API to associate a Part with its corresponding object.\nVersions and releases Traditional PDM/PLM systems provide design release support by locking a CAD file for access. The access controls are defined in the database and the definition of a part/assembly/drawing as released is controlled by the database. When a new revision of the part is required, a file copy is made, and the database provides access to the new copy. Generally, the old copy representing the previous release persists in the file store and can be referenced by the database. This is not how Onshape works.\nSince there are no files in Onshape (just data) no file locking or copy mechanisms are available. Instead, Onshape looks at the data as a continuous timeline that is always moving forward and always changing as the design evolves. The data is never locked; it is always available.\nIn place of file copies that represent versions and releases of the design, Onshape provides the ability to create versions as bookmarks in the timeline. When creating a version, Onshape places a bookmark in the timeline that represents the state of the design at that specific moment in time. Releases work in a similar way, but they are defined as official, company-approved processes and have special meaning.\nIn addition to creating versions and releases, Onshape can create branches, which can be defined as alternative timelines. A designer might want to experiment with alternate design ideas without modifying the existing design that others are working on. By creating a branch from any point in the timeline, the designer is free to experiment with alternate ideas. If the ideas work, they can be merged into the current timeline at any point.\nFrom an integration perspective, we need to take into consideration how Onshape works with versions and releases. Since a release represents a company-approved design, Onshape provides processes for the approval of a release and the change of state of a design. Onshape also provides APIs and triggers (events) that enable integration points throughout the release process. It is through the triggers and the APIs that integration of any third-party system that wishes to manage the release process is enabled.\nWorkflows Release and obsoletion workflows are included with Onshape and can be customized to meet company standards.\nFor details on how to implement and customize Onshape‚Äôs workflows, please review these online help topics:\nHow to design release management processes How to create a customized release workflow Most PDM/PLM systems can model a company‚Äôs business processes in a workflow. These can be highly automated processes that move data and file references through a process of reviews and approvals. Onshape also has this capability, which is currently used for release and obsoletion processes.\nThere are no files or file references in Onshape that are moved through the process. Onshape only has data. Therefore, it is the data that is referenced at each stage of the process. Traditional PDM systems might make file copies and lock files as they move through a release process. If the process is rejected at any stage, those files must be discarded, the previous version of the files unlocked and all states updated. In short, it system must rewind back to the state of the files and the data when the workflow was initiated. This is a lot of complex actions that must occur when a process is rejected for any reason. Onshape doesn‚Äôt work this way.\nA release process can be started on data (such as assemblies, parts, drawings, etc.). For example, if the state of a referenced part is updated to ‚ÄúPending,‚Äù and the process is rejected at any stage, there is no rewinding of files and data; the data just reverts to the original ‚ÄúIn Progress‚Äù state, and the workflow is discarded. Since the workflow didn‚Äôt complete, nothing related to the data has actually changed. When you are used to traditional PDM systems, this feels like an anti-climax, and we often receive the question, ‚ÄúBut where‚Äôs my process? Where‚Äôs the data that was attached to the process?‚Äù. Well, the answer is: nothing changed. Until the process is completed, nothing actually changes, so the data is in the same state it was prior to the initialization of the release process.\nA custom release process in Onshape\n","categories":"","description":"","excerpt":"Why Onshape? As long as there have been applications that manage ‚Ä¶","ref":"/docs/api-intro/whyonshape/","tags":"","title":"Why Onshape?"},{"body":" üìò Note\nAll applications submitted to the Onshape App Store (Onshape Apps) must follow the instructions on the OAuth2 page and use OAuth2 for authorization. Automation scripts (or applications not meant for the Onshape App Store) may use either OAuth2 or API Keys for authentication. OAuth2 allows applications to call Onshape APIs on behalf of the users of the application; API keys will only perform operations on behalf of the Onshape user who generated the API keys.\nWe‚Äôve structured API keys to work very similarly to OAuth in the operation of your app. You must build your Authorization header differently (and set up redirects and sign-ins), but the API calls themselves work the same in both versions, provided that the API key and the OAuth app have the same scopes. An API key with the OAuth2Read and OAuth2Write scopes have the same access to the same API endpoints as an OAuth application with the OAuth2Read and OAuth2Write scopes. The only differences are when calling API endpoints in relation to the OAuth application itself, since an API key request does not come from an OAuth application.\nPlease select an option for authentication:\nAPI Keys OAuth2 ","categories":"","description":"","excerpt":" üìò Note\nAll applications submitted to the Onshape App Store (Onshape ‚Ä¶","ref":"/docs/auth/","tags":"","title":"Authentication"},{"body":"See the gltf-viewer-app for a working example of OAuth2.\nüìò Note\nAll applications submitted to the Onshape App Store (Onshape Apps) must use OAuth2 for authorization. Automation scripts (or applications not meant for the Onshape App Store) may use either OAuth2 or API Keys for authentication. OAuth2 allows applications to call Onshape APIs on behalf of the users of the application; API keys will only perform operations on behalf of the Onshape user who generated the API keys.\nWhat is OAuth2? The OAuth (Open authorization) protocol was developed by the Internet Engineering Task Force, an open standards organization that develops and promotes voluntary Internet standards (particularly the technical standards that comprise the Internet protocol suite) to enable secure, delegated access to an application‚Äôs resources.\nThe OAuth2 protocol enables an application to access a resource that is under the control of someone else. In order to access that resource, a token is required. The token represent the delegated rights of access (that is, what rights this application has, such as read/write/update, scope, rights to different resources, and more).\nThis means the application can be accessed by a third-party system without that system impersonating the user that controls the resource.\nA good analogy is the hotel check-in process. When you arrive at the front desk of a hotel, you provide an ID and a form of payment. Then, you are given a key card that opens a specific door. When you reach that door, you swipe your key card and are granted access. The door itself doesn‚Äôt know who you are or anything about you, it just knows that the key card was encoded correctly, and it allows you access. At some point, the key card expires, and the door no longer lets you into the room. This is the same for access tokens in the OAuth2 flow.\nWith the OAuth2 protocol, you register your application with the third party, and you are given a set of keys. These keys get exchanged for an access token that grants you access to resources in the third-party application. The token expires regularly; you miust get a new token to access the application again. For this, you are provided with a refresh token. Sending the refresh token to the authentication server updates your access token and gives you a new refresh token.\nOAuth2 \u0026 Onshape The first step in the OAuth flow is for the Onshape user to request that Onshape let the third-party application access Onshape.\nOnce the user has authorized the application, they are redirected to a predefined URL (called a redirect URL) with a code that will requests an access token from Onshape. Therefore, the redirect URL should contain a script that can capture the authorization code.\nYou will use the access token to authenticate requests to the Onshape API. The token expires after preset amount of time. To get a new valid access token after one has expired, you must use the refresh token to request a new access token. Refreshing the access token also provides you with an updated refresh token to use in the next refresh access token request. Make sure to store both the the access token and the refresh token, and update them with each refresh of the token. The authorization token must accompany any call to the API, this is done by adding the token to an Authorization field in the header of each request:\nAuthorization: Bearer \u003caccessToken\u003e If correctly authenticated, most responses from the REST API call return JSON data (though some return binary data), with an HTTP response code of 200 Success, 204 - No Content, or 301 - Permanent Redirect. 301 responses will include a redirect for you to follow.\nIn the event that the authorization code is incorrect (for instance, if it expired), you will receive an HTTP 401 response. This response means that the client request has not been completed, since it lacks valid authentication credentials for the requested resource. In this event, your code for each call to the REST API should include a catch clause for a 401 exception. Once caught, you can refresh the token and make the request again. Pay close attention to the Content-Type header for what data to parse and expect.\nWhen integrating with Onshape, OAuth tokens give third-party applications (such as desktop applications or web services) access to users‚Äô data as defined by the permissions scope (such as users‚Äô documents or profile information). Using OAuth terminology, Onshape acts as both the authorization and resource server, while the desktop or web-based application is the client. Resource owners have the option of granting or denying access to applications.\nOnce obtained, an OAuth token will work for third-party APIs under /api. Do NOT attempt to use an OAuth token to fetch the URLs typically displayed in a web browsers location bar.\nMore resources Digital Ocean - A good resource for learning more about OAuth2. RFC 6749 - The reference for the OAuth framework as a whole. Most of this document describes how to implement the OAuth exchanges described by the reference within the context of Onshape and client applications. RFC 6750 - Describes the exchange of OAuth access tokens between clients and OAuth servers. Implement OAuth2 This OAuth tutorial demonstrates how to recreate the authentication process in Node.js found in the gltf-viewer-app sample code. The final code in Node.js and other languages can be found at the end of this page.\n1: Register the app Navigate to https://dev-portal.onshape.com/signin and sign in. In the left sidebar, click OAuth applications. Click the Create new OAuth application button. Fill out the form as follows: Name: gltf-viewer-yourname The application name to display to users. Should include the name of your company to differentiate it from other possibly similar applications. Primary format: com.yourname.gltf-viewer String that uniquely identifies your application and is a marker for the data it might store on Onshape servers. Cannot be changed after the application is registered. Summary: Onshape OAuth tutorial Description of your application. Displayed to the user when they‚Äôre asked to grant the application permission to access their data. Redirect URLs: http://localhost:5000/token Your application must specify at least one URL used in the OAuth protocol exchanges. This URL must also use SSL (a URL that begins with¬†https), with two exceptions applicable for installed desktop applications: http://localhost:\u003cport\u003e and urn:ietf:wg:oauth:2.0:oob. e.g., https://app-gltf-viewer-yourname-c11f263794bc.herokuapp.com/oauthRedirect Admin team: No Team Optional. If defined, members of the team can make changes to the definition of this OAuth application. See the Help Docs: Teams page for more information on creating teams in Onshape. OAuth URL: none Should contain the URL of your deployed application. This is the first URL called from the Onshape Applications page. The page hosted at this URL should handle the OAuth authentication. Once your application‚Äôs server has been authenticated on behalf of the user, that user should be redirected to your applications content. If you have not deployed your app yet, you can leave this field blank (as shown in this example) for local work and update it later. e.g., https://app-gltf-viewer-yourname-c11f263794bc.herokuapp.com/oauthSignin Settings: check Supports collaboration Permissions: This is also called application scope, and it defines what access rights your application has to the user‚Äôs data. Application can read your profile information - Enable your application to access the Onshape user profile. Check this option. Application can read your documents - Onshape documents created by this user can be accessed with read privileges only. Check this option. Application can write to your documents - The user-owned Onshape documents can be modified by this application. Check this option. Application can delete documents and workspaces - Your application will be able to delete a workspace within a document or the complete Onshape document. Do not check this option for this example. Application can request Purchases on Your behalf - The application will have access to make purchases if required. Do not check this option for this example. Application can share and unshare documents on your behalf - Onshape‚Äôs document sharing capabilities are very powerful; they enable other parties to access your shared documents with predefined rights. If this option is checked, the application can automatically share a document with other people. Do not check this option for this example. Click Create application. COPY THE OAUTH SECRET FROM THE POP-UP WINDOW. You will not be able to access this secret again. This secret is unique to you and your app and should be protected like any sensitive password. For example, it should NOT be checked in to source code control systems. Click Close. Copy the OAuth client identifier from the app Details page that opens. These OAuth secret and client ID keys will be used in your code for requesting a one-time user authorization code from Onshape. Your application is now registered with Onshape and you have options to modify the application definition through this portal.\n2: Get the user authorization code We‚Äôll start by loading the basic libraries required to run this sample. We‚Äôll use Passport to authenticate requests through plugins known as strategies. In this example, we‚Äôll use an Onshape-developed plugin called passport-onshape, but you can define your own strategy to use with Passport, if you prefer. You can find more information on Passport here.\nCreate a directory for your app, and then install Passport and passport-onshape: npm install passport npm install passport-onshape Next, create a file calls app.js and add the following definitions to the top of the file: // App definitions const path = require('path'); const uuid = require('uuid'); const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const passport = require('passport'); const OnshapeStrategy = require('passport-onshape'); const config = require('./config'); Next, tell Express to use Passport and initialize it. Note: you can replace the Express code with code for the web server of your choice. // Tell Express to use Passport, and initialize it. const app = express(); app.use(express.static(path.join(__dirname, 'public'))); app.use(express.static(path.join(__dirname, 'dist'))); app.use(bodyParser.json()); app.set('trust proxy', 1); // To allow to run correctly behind Heroku when deployed app.use(session({ secret: config.sessionSecret, saveUninitialized: false, resave: false, cookie: { name: 'app-gltf-viewer', sameSite: 'none', secure: true, httpOnly: true, path: '/', maxAge: 1000 * 60 * 60 * 24 // 1 day } })); app.use(passport.initialize()); app.use(passport.session()); Next, we‚Äôll store the Onshape user information so it can be retrieved from req.user in each call. Passport uses¬†the serializeUser function to persist user data (after successful authentication) into the session. The function¬†deserializeUser is used to retrieve user data from session. //Store the Onshape user information passport.serializeUser((user, done) =\u003e done(null, user)); passport.deserializeUser((obj, done) =\u003e done(null, obj)); Initialize Passport with the Onshape Strategy: //Initialize Passport with the Onshape Strategy passport.use(new OnshapeStrategy({ clientID: config.oauthClientId, clientSecret: config.oauthClientSecret, callbackURL: config.oauthCallbackUrl, authorizationURL: `${config.oauthUrl}/oauth/authorize`, tokenURL: `${config.oauthUrl}/oauth/token`, userProfileURL: `${config.oauthUrl}/api/users/sessioninfo` }, (accessToken, refreshToken, profile, done) =\u003e { profile.accessToken = accessToken; profile.refreshToken = refreshToken; return done(null, profile); } )); Open your environment variables file (e.g.,.env, .bashrc, .bash_profile, .zshrc, etc.) and add the following environment variables, then save and close the file. authorizationURL : https://oauth.onshape.com/oauth/authorize tokenURL : https://oauth.onshape.com/oauth/token userProfileURL : https://cad.onshape.com/api/users/sessioninfo The callback function will provide us with the accessToken, the refreshToken, and the user‚Äôs Onshape profile once authentication has been successfully passed. We can now use this to update our database with user-specific information.\nNote that if you store the accessToken and refreshToken in the database along with the user record, you must update it each time that the access codes are refreshed.\nNext, we define our endpoint where the authorization flow starts (in this case, /oauthSignin). This is the endpoint that we previously defined in the Onshape application setup. This will redirect to an Onshape page in order for the user to confirm (or deny) the applications access to theOnshape resources. //Define the Onshape API endpoint app.use('/oauthSignin', (req, res) =\u003e { /* These 5 lines are specific to the glTF Viewer sample app. You can replace them with the input for whatever Onshape endpoints you are using in your app */ const state = { docId: req.query.documentId, workId: req.query.workspaceId, elId: req.query.elementId }; req.session.state = state; return passport.authenticate('onshape', { state: uuid.v4(state) })(req, res); }, (req, res) =\u003e { }); 3: Exchange the code for an access token Fortunately, if you are using Passport, there isn‚Äôt much to do once the user grants authorization. The return URL will contain the one-time authorization token, which Passport will extract and exchange for an access token and a refresh token, which are available in Passport callback function.\nAdd the following code to app.js: //Exchange the code for an access token app.use('/oauthRedirect', passport.authenticate('onshape', { failureRedirect: '/grantDenied' }), (req, res) =\u003e { /* This code is specific to the glTF Viewer sample app. You can replace it with the input for whatever Onshape endpoints you are using in your app. */ res.redirect(`/?documentId=${req.session.state.docId} \u0026workspaceId=${req.session.state.workId}\u0026elementId= ${req.session.state.elId}`); }); If the user clicks Deny instead of Authorize Application, they are taken to a page that notifies them that access to the application was denied. We can see that in the failureRedirect argument. Add the following to app.js: //Handle denied access app.get('/grantDenied', (req, res) =\u003e { res.sendFile(path.join(__dirname, 'public', 'html', 'grantDenied.html')); }) Now we have received the access token, and it can be accessed from res.user.accessToken on this page or from req.user.accessToken from any other page you redirect to from here.\n4: Use the access token Add the following to the bottom of app.js. You can see that the access token is used as an Authorization header: //Use the access token as an Authorization header makeOnshapeAPICall: async (req, res) =\u003e { try { const apiUrl = \"https://cad.onshape.com/api/documents?ownerType=1\u0026sortColumn=createdAt\u0026sortOrder=desc\u0026offset=0\u0026limit=20\"; //You can replace this with any Onshape API endpoint URL. const resp = await fetch(normalizedUrl, { headers: { Authorization: `Bearer ${req.user.accessToken}` }}); const data = await resp.text(); const contentType = resp.headers.get('Content-Type'); res.status(resp.status).contentType(contentType).send(data); } catch (err) { res.status(500).json({ error: err }); } } Note: in the glTF Viewer sample app, this code appears in utils.js instead of app.js.\n5: Refresh the token When the access token expires, it must be refreshed by making another POST request to¬†https://oauth.onshape.com/oauth/token¬†with the following URL-encoded form body (with Content-Type¬†application/x-www-form-urlencoded):\ngrant_type=refresh_token\u0026refresh_token=\\\u003crefresh_token\\\u003e\u0026client_id=\\\u003cclient_id\\\u003e\u0026client_secret=\\\u003cclient_secret\\\u003e As with the authorization code data, the parameters in the form body must be URL-encoded. The response to this POST request will be a JSON-encoded structure with a new¬†access_token¬†value that can be used for the next 60 minutes.\nRefresh tokens are valid for the lifetime of the user‚Äôs grant. If a user who previously granted access to your application decides to revoke the grant, the refresh token is invalidated. If the user decides to re-grant application access, a new refresh token is generated and returned along with the access token.\nAdd the following to app.js: /** After landing on the home page, we check if a user had already signed in. If no user has signed in, we redirect the request to the OAuth sign-in page. If a user had signed in previously, we will attempt to refresh the access token of the user. After successfully refreshing the access token, we will simply take the user to the landing page of the app. If the refresh token request fails, we will redirect the user to the OAuth sign-in page again. */ app.get('/', (req, res) =\u003e { if (!req.user) { return res.redirect(`/oauthSignin${req._parsedUrl.search ? req._parsedUrl.search : \"\"}`); } else { refreshAccessToken(req.user).then((tokenJson) =\u003e { // Dereference the user object and update the access token and refresh token in the in-memory object. let usrObj = JSON.parse(JSON.stringify(req.user)); usrObj.accessToken = tokenJson.access_token; usrObj.refreshToken = tokenJson.refresh_token; // Update the user object in PassportJS. No redirections will happen here, this is a purely internal operation. req.login(usrObj, () =\u003e { return res.sendFile(path.join(__dirname, 'public', 'html', 'index.html')); }); }).catch(() =\u003e { // Refresh token failed, take the user to OAuth sign in page. return res.redirect(`/oauthSignin${req._parsedUrl.search ? req._parsedUrl.search : \"\"}`); }); } }); //Refresh the access token const refreshAccessToken = async (user) =\u003e { const body = 'grant_type=refresh_token\u0026refresh_token=' + user.refreshToken + '\u0026client_id=' + config.oauthClientId + '\u0026client_secret=' + config.oauthClientSecret; let res = await fetch(config.oauthUrl + \"/oauth/token\", { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: body }); if (res.ok) { return await res.json(); } else { throw new Error(\"Could not refresh access token, please sign in again.\"); } } app.use('/api', require('./api')); module.exports = app; Save the file. To see the authentication working in practice, you can follow the instructions in the glTF Viewer README to deploy the glTF Viewer app. 6: Grant authorization For apps published in the Onshape App Store, the Onshape user must grant authorization to your application to access the Onshape data. This must be done by each user of your app.\nTo grant the application access to a user‚Äôs data in Onshape, the Onshape user must follow the steps below:\nSign in to cad.onshape.com. Note: Use https://companyName.onshape.com for Enterprise accounts. See Enterprise users below for more information. Click their name in the top-right corner of the Onshape window, and then click My account in the dropdown menu. Click Applications in the left sidebar. Note that the gltf-viewer app will not appear in this list until it has been deployed and subscribed to as described in the glTF Viewer README. Click Grant next to your app name to grant it access to their Onshape data. The Onshape user can click Revoke at any time to prevent your app from accessing their Onshape data. The user will see the Authorize application screen shown below and will need to confirm their authorization grant by clicking Authorize application. The user is then redirected to the Redirect URL you specified in your code. Your app can now access the user‚Äôs Onshape resources and profile. Notes Installed desktop applications OAuth is designed for interactions between two servers using a browser. However, it can also be used by an installed desktop (or mobile) application. The application must perform a similar role to that of a third party server: it must exchange the code for an access token structure.\nTo enable this, Onshape allows two special forms of redirect URI to be registered:\nhttp://localhost:\u003cport\u003e Causes the browser to attempt to load a page from the host upon which it is running. The code parameter will be supplied exactly the same as outlined above. If the application can listen on the registered port and behave as a simple web server for the redirect URL, it can retrieve the code in the same way as a deployed web server. urn:ietf:wg:oauth:2.0:oob Causes the browser to display a simple page after a request has been granted instead of going to a new URL. The page contains simple instructions to copy and paste code into an application field. The browser will also update the title of the window to contain the code. An application could also look for browsers with window titles containing the string Success code=\u003ccode\u003e and automatically grab the code from the browser window title. If an error occurs (e.g., the grant is denied), the browser window title will contain Error description=\u003cerror string\u003e. Enterprise users When a user authorizes an OAuth app to access Onshape on their behalf, they get a bearer token that corresponds to their session and the allowed scopes.\nHowever, if the user has a seat in the Enterprise, additional information is needed to determine whether to allow the bearer token to access enterprise data for the user or simply return non-enterprise data. We use the companyId field for this distinction.\nThere are two ways of setting the companyId correctly to access enterprise data:\nDuring the authorization process, select the name and URL of the enterprise instead of cad.onshape.com. This will correctly associate your bearer token with the companyId. If you have an integrated app, call the Company/findCompany endpoint to obtain the companyId. Append this companyId as a query parameter to the /authorize URL while initiating the OAuth workflow. (Note: you may be asked to authenticate yourself again.) 3rd-party cookies 3rd-party cookies must be enabled in the browser for Onshape apps to work correctly.\nDebugging Debugging OAuth can be a little tricky. Some tips are below:\nMake sure you are correctly URL encoding the values supplied to the oauth/authorize and oauth/token endpoints. Use a GET /oauth/authorize but a POST /oauth/token and make sure that the GET uses query parameters but that the POST uses a URL-encoded form body. If you supply a redirect_uri to /oauth/authorize, you must also supply it as an additional parameter in the POST to /oauth/token Use a tool such as Burp or Charles to deliberately ‚Äòman-in-the-middle‚Äô the connection requests between your server and Onshape, and verify that you are performing the correct REST operations (GET vs. POST) and correctly URL-encoding the parameter values. Final Code The above example uses Node.js to authenticate an Onshape app. This section includes the code for using OAuth2 with other coding languages.\nNode.js Prerequisites\nnpm install passport npm install passport-onshape Environment variables\nauthorizationURL : \u003chttps://oauth.onshape.com/oauth/authorize\u003e tokenURL : \u003chttps://oauth.onshape.com/oauth/token\u003e userProfileURL : \u003chttps://cad.onshape.com/api/users/sessioninfo\u003e app.js\n//App definitions const path = require('path'); const uuid = require('uuid'); const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const passport = require('passport'); const OnshapeStrategy = require('passport-onshape'); const config = require('./config'); //Tell Express to use Passport, and initialize it. const app = express(); app.use(express.static(path.join(__dirname, 'public'))); app.use(express.static(path.join(__dirname, 'dist'))); app.use(bodyParser.json()); app.set('trust proxy', 1); // To allow to run correctly behind Heroku when deployed. app.use(session({ secret: config.sessionSecret, saveUninitialized: false, resave: false, cookie: { name: 'app-gltf-viewer', sameSite: 'none', secure: true, httpOnly: true, path: '/', maxAge: 1000 * 60 * 60 * 24 // 1 day } })); app.use(passport.initialize()); app.use(passport.session()); //Store the Onshape user information passport.serializeUser((user, done) =\u003e done(null, user)); passport.deserializeUser((obj, done) =\u003e done(null, obj)); //Initialize Passport with the Onshape Strategy passport.use(new OnshapeStrategy({ clientID: config.oauthClientId, clientSecret: config.oauthClientSecret, callbackURL: config.oauthCallbackUrl, authorizationURL: `${config.oauthUrl}/oauth/authorize`, tokenURL: `${config.oauthUrl}/oauth/token`, userProfileURL: `${config.oauthUrl}/api/users/sessioninfo` }, (accessToken, refreshToken, profile, done) =\u003e { profile.accessToken = accessToken; profile.refreshToken = refreshToken; return done(null, profile); } )); //Define the Onshape API endpoint app.use('/oauthSignin', (req, res) =\u003e { /* These 5 lines are specific to the glTF Viewer sample app. You can replace them with the input for whatever Onshape endpoints you are using in your app. */ const state = { docId: req.query.documentId, workId: req.query.workspaceId, elId: req.query.elementId }; req.session.state = state; return passport.authenticate('onshape', { state: uuid.v4(state) })(req, res); }, (req, res) =\u003e { }); app.use('/oauthRedirect', passport.authenticate('onshape', { failureRedirect: '/grantDenied' }), (req, res) =\u003e { /* This code is specific to the glTF Viewer sample app. You can replace it with the input for whatever Onshape endpoints you are using in your app. */ res.redirect(`/?documentId=${req.session.state.docId}\u0026workspaceId=${req.session.state.workId}\u0026elementId=${req.session.state.elId}`); }); //Handle denied access app.get('/grantDenied', (req, res) =\u003e { res.sendFile(path.join(__dirname, 'public', 'html', 'grantDenied.html')); }) /** After landing on the home page, we check if a user had already signed in. If no user has signed in, we redirect the request to the OAuth sign-in page. If a user had signed in previously, we will attempt to refresh the access token of the user. After successfully refreshing the access token, we will simply take the user to the landing page of the app. If the refresh token request fails, we will redirect the user to the OAuth sign-in page again. */ app.get('/', (req, res) =\u003e { if (!req.user) { return res.redirect(`/oauthSignin${req._parsedUrl.search ? req._parsedUrl.search : \"\"}`); } else { refreshAccessToken(req.user).then((tokenJson) =\u003e { // Dereference the user object, and update the access token and refresh token in the in-memory object. let usrObj = JSON.parse(JSON.stringify(req.user)); usrObj.accessToken = tokenJson.access_token; usrObj.refreshToken = tokenJson.refresh_token; // Update the user object in PassportJS. No redirections will happen here, this is a purely internal operation. req.login(usrObj, () =\u003e { return res.sendFile(path.join(__dirname, 'public', 'html', 'index.html')); }); }).catch(() =\u003e { // Refresh token failed, take the user to OAuth sign in page. return res.redirect(`/oauthSignin${req._parsedUrl.search ? req._parsedUrl.search : \"\"}`); }); } }); //Refresh the access token const refreshAccessToken = async (user) =\u003e { const body = 'grant_type=refresh_token\u0026refresh_token=' + user.refreshToken + '\u0026client_id=' + config.oauthClientId + '\u0026client_secret=' + config.oauthClientSecret; let res = await fetch(config.oauthUrl + \"/oauth/token\", { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: body }); if (res.ok) { return await res.json(); } else { throw new Error(\"Could not refresh access token, please sign in again.\"); } } app.use('/api', require('./api')); module.exports = app; //Use the access token in an Authorization header. makeOnshapeAPICall: async (req, res) =\u003e { try { const apiUrl = \"https://cad.onshape.com/glassworks/explorer/#/Document/getDocuments\"; //You can replace this with any Onshape API endpoint URL. const resp = await fetch(normalizedUrl, { headers: { Authorization: `Bearer ${req.user.accessToken}` }}); const data = await resp.text(); const contentType = resp.headers.get('Content-Type'); res.status(resp.status).contentType(contentType).send(data); } catch (err) { res.status(500).json({ error: err }); } } Python This Python code only works on a local machine. To deploy the code, you can replace the Flask code with the web server of your choice.\nPrerequisites\npip3 install flask pip3 install requests_oauthlib app.py\nfrom flask import Flask, request, redirect, session, url_for from flask.json import jsonify from requests_oauthlib import OAuth2Session import os app = Flask(__name__) app.secret_key = b'F\\xf5\\xe5\\xc0\\xbe\\tg\\x7f\\xac\\x89\\x87e\\xc24\\xe8m\\x1c\\xd9\\xda\\x96G,\\x90i' os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = \"1\" client_id = \u003cClient ID of your application\u003e client_secret = \u003cClient Secret of your application\u003e authorization_base_url = \"https://oauth.onshape.com/oauth/authorize\" token_url = \"https://oauth.onshape.com/oauth/token\" redirect_url = \"http://localhost:5000\" @app.route('/') def home(): onshape = OAuth2Session(client_id, redirect_uri=redirect_url) auth_url, state = onshape.authorization_url(authorization_base_url) session['oauth_state'] = state return redirect(auth_url) @app.route('/token', methods=[\"GET\"]) def token(): onshape = OAuth2Session(client_id, state=session['oauth_state'], redirect_uri=redirect_url) token = onshape.fetch_token(token_url, client_secret=client_secret, authorization_response=request.url) session['oauth_token'] = token return redirect(url_for('.documents')) @app.route('/documents', methods=[\"GET\"]) def documents(): extra = { 'client_id': client_id, 'client_secret': client_secret, } onshape = OAuth2Session(client_id, token=session['oauth_token'], redirect_uri=redirect_url) session['oauth_token'] = onshape.refresh_token(token_url, **extra) return jsonify(onshape.get('https://cad.onshape.com/api/v6/documents?q=Untitled\u0026ownerType=1\u0026sortColumn=createdAt\u0026sortOrder=desc\u0026offset=0\u0026limit=20').json()) if __name__ == \"__main__\": app.run() ","categories":"","description":"","excerpt":"See the gltf-viewer-app for a working example of OAuth2.\nüìò Note\nAll ‚Ä¶","ref":"/docs/auth/oauth/","tags":"","title":"OAuth"},{"body":" üìò Note\nAll applications submitted to the Onshape App Store (Onshape Apps) must follow the instructions on the OAuth2 page and use OAuth2 for authorization. Automation scripts (or applications not meant for the Onshape App Store) may use either OAuth2 or API Keys for authentication. OAuth2 allows applications to call Onshape APIs on behalf of the users of the application; API keys will only perform operations on behalf of the Onshape user who generated the API keys.\nWhy API Keys? API keys are useful for small applications meant for personal use, allowing developers to avoid the overhead of the OAuth workflow. Creating an app is very easy with API keys: create an API key with the Developer Portal, set up a function to build your API key header as in the samples, and make your API calls! There‚Äôs no need to deal with OAuth redirects or things like that.\nWe‚Äôve moved over to using API keys for authenticating requests instead of using cookies for several reasons.\nSecurity: Each request is signed with unique headers so that we can be sure it‚Äôs coming from the right place. OAuth: The API key system we‚Äôre now using for HTTP requests is the same process developers follow when building full-blown OAuth applications; there‚Äôs no longer a disconnect between the two. Once you create an API key, it will only be valid in the stack on which it was created. An API key created on the partner stack, for example, will not function on the production stack.\nIf you need information or have a question unanswered in this documentation, feel free to chat with us by sending an email to api-support@onshape.com or by checking out the forums. If you are a member of the DevPartners group (see the Development help page for information) more detailed instructions and code examples are in the apikey sample repo.\n1. Create API Keys Go to https://dev-portal.onshape.com. In the left pane, click API keys. Click the Create new API key button. Select the desired permissions for your app. Click the Create API key button. Copy both the access key and secret key from the pop-up window, save them somewhere, then click the Close button. IMPORTANT NOTE: You will not be able to find the secret key again, so save it somewhere safe! The details for your application appear. Now that you have a key pair, see Generate a Request Signature for information on signing your requests to use our API. Once you have your access key and secret, you will want to avoid giving others access to them, since they‚Äôre tied directly to your personal Onshape account. Think of your API key as a username and password pair. Do not place them directly in the code for your application, especially if others might see it. The samples we provide here use a separate configuration file to contain this information, but there are other ways to keep the access key and secret safe, like setting them as environment variables.\nScopes There are several scopes available for API keys (equivalent to OAuth scopes):\nOAuth2Read - Read non-personal information (documents, parts, etc.) OAuth2ReadPII - Read personal information (name, email, etc.) OAuth2Write - Create and edit documents, etc. OAuth2Delete - Delete documents, etc. OAuth2Purchase - Authorize purchases from account 2. Select an Authentication Option Please select an option for authentication:\nBasic Authorization: Lowest security. For local testing only. Request Signature: Medium security. For testing and internal use. OAuth2: Highest security. Required for all Onshape Apps. Basic Authorization For local testing, you can provide a basic authentication via your API Keys.\nOpen your terminal and run the following command, replacing ACCESS_KEY and SECRET_KEY with the access key and secret key you created earlier. Remember to include the colon (:) between the keys. You will receive a long, base-64-encoded string as output. MacOS: printf ACCESS_KEY:SECRET_KEY | base64 Windows: powershell \"[convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes(\\\"ACCESS_KEY:SECRET_KEY\\\"))\" Add the authorization header to your code, replacing CREDENTIALS with the string you receieved in Step 1: -H 'Authorization: Basic CREDENTIALS' \\ See our Quick Start Guide for an example of using Basic Authorization in an app.\nRequest Signature For additional security, you can include your API Keys as part of a request signature. This provides more security than the Basic Authorization above, but less security than OAuth2.\nTo ensure that a request is coming from you, we have a process for signing requests that you must follow for API calls to work. Everything is done via HTTP headers that you‚Äôll need to set:\nDate: A standard date header giving the time of the request; must be accurate within 5 minutes of request. Example: Mon, 11 Apr 2016 20:08:56 GMT On-Nonce: A string that satisfies the following requirements (see the code for one possible way to generate it): At least 16 characters Alphanumeric Unique for each request Authorization: This is where the API keys come into play. You‚Äôll sign the request by implementing this algorithm: Input: Method, URL, On-Nonce, Date, Content-Type, AccessKey, SecretKey Output: String of the form: On \u003cAccessKey\u003e:HmacSHA256:\u003cSignature\u003e Steps to generate the signature portion: Parse the URL and get the following: The path, e.g. /api/documents (no query params!) The query string, e.g. a=1\u0026b=2 NOTE: If no query paramaters are present, use an empty string Create a string by appending the following information in order. Each field should be separated by a newline (\\n) character, and the string must be converted to lowercase: HTTP method On-Nonce header value Date header value Content-Type header value URL pathname URL query string Using SHA-256, generate an HMAC digest, using the API secret key first and then the above string, then encode it in Base64. Create the On \u003cAccessKey\u003e:HmacSHA256:\u003cSignature\u003e string and use that in the Authorization header in your request. Below is an example function to generate the authorization header, using Node.js‚Äôs standard crypto and url libraries:\n// ...at top of file var u = require('url'); var crypto = require('crypto'); /** * Generates the \"Authorization\" HTTP header for using the Onshape API * * @param {string} method - Request method; GET, POST, etc. * @param {string} url - The full request URL * @param {string} nonce - 25-character nonce (generated by you) * @param {string} authDate - UTC-formatted date string (generated by you) * @param {string} contentType - Value of the \"Content-Type\" header; generally \"application/json\" * @param {string} accessKey - API access key * @param {string} secretKey - API secret key * * @return {string} Value for the \"Authorization\" header */ function createSignature(method, url, nonce, authDate, contentType, accessKey, secretKey) { var urlObj = u.parse(url); var urlPath = urlObj.pathname; var urlQuery = urlObj.query ? urlObj.query : ''; // if no query, use empty string var str = (method + '\\n' + nonce + '\\n' + authDate + '\\n' + contentType + '\\n' + urlPath + '\\n' + urlQuery + '\\n').toLowerCase(); var hmac = crypto.createHmac('sha256', secretKey) .update(str) .digest('base64'); var signature = 'On ' + accessKey + ':HmacSHA256:' + hmac; return signature; } Redirects Some API endpoints return 307 redirects. You must generate an Authorization header for the redirect as well, but please note that the server portion of the URL might be different, the redirect URL may contain query parameters that must be encoded in the Authorization header, etc.\n","categories":"","description":"","excerpt":" üìò Note\nAll applications submitted to the Onshape App Store (Onshape ‚Ä¶","ref":"/docs/auth/apikeys/","tags":"","title":"API Keys"},{"body":"Please refer to the pages in this section for more information on working with Onshape APIs.\n","categories":"","description":"","excerpt":"Please refer to the pages in this section for more information on ‚Ä¶","ref":"/docs/api-adv/","tags":"","title":"API Guides"},{"body":"Onshape does not expose a persistent ID for any of these entities. When the model changes, the ID may change. Therefore, Onshape provides an API to enable mapping IDs from a previous microversion to the current microversion. Assuming a simple case of maintaining associativity for a face, an abstract workflow might be:\nRead the tessellated model data. Select the face of interest. Store the Face ID and Document Microversion ID for the face. [ user changes model ] Call the REST API to translate from the known Face ID to an ID in the new model. Re-apply application-specific data to the face(s) in the new model. Note that a face may become zero, one or multiple faces in the new model, depending on what changes the user made. Associativity Example Create a cube in Onshape: Get the document microversion ID from the URL: https://cad.onshape.com/api/d/\u003cdocid\u003e/w/\u003cwid\u003e/microversionId. Use the appropriate REST API to get the tessellated faces (getPartStudioFaces) and edges (getPartStudioEdges}. Note the ids: Part ID: JHD Front face ID: JHO Top edge of the front face ID: JHd Right edge of the top face ID: JHt Split cube with the Front plane and translate the IDs: POST\nhttps://cad.onshape.com/api/partstudios/d/\u003cdocid\u003e/w/\u003cwid\u003e/e/\u003ceid\u003e/idtranslations Body:\n{ \"sourceDocumentMicroversion\" : \"47e75ab2ee8b4356a76ebd47\", \"ids\" : [\"JHD\", \"JHO\", \"JHd\", \"JHt\" ] } Response:\n{ \"documentId\": \"748d6e850c9248328189922b\", \"elementId\": \"042a6fa54e79451e8076463d\", \"sourceDocumentMicroversion\": \"47e75ab2ee8b4356a76ebd47\", \"ids\": [ { \"source\": \"JHD\", \"status\": \"SPLIT\", \"target\": [\"JID\", \"JIH\"] }, { \"source\": \"JHO\", \"status\": \"OK\", \"target\": [\"JHO\"] }, { \"source\": \"JHd\", \"status\": \"OK\", \"target\": [\"JHd\"] }, { \"source\": \"JHt\", \"status\": \"SPLIT\", \"target\": [\"JI5\", \"JI9\"] } ], \"targetDocumentMicroversion\": \"78bc7f3fcf82475085c2f3ab\" } Delete one of the parts, and translate the IDs: POST\nhttps://cad.onshape.com/api/partstudios/d/\u003cdocid\u003e/w/\u003cwid\u003e/e/\u003ceid\u003e/idtranslations Body:\n{ \"sourceDocumentMicroversion\" : \"47e75ab2ee8b4356a76ebd47\", \"ids\" : [\"JHD\", \"JHO\", \"JHd\", \"JHt\"] } Response:\n{ \"documentId\": \"748d6e850c9248328189922b\", \"elementId\": \"042a6fa54e79451e8076463d\", \"sourceDocumentMicroversion\": \"47e75ab2ee8b4356a76ebd47\", \"ids\": [ { \"source\": \"JHD\", \"status\": \"OK\", \"target\": [\"JID\"] }, { \"source\": \"JHO\", \"status\": \"FAILED_TO_RESOLVE\", \"target\": [] }, { \"source\": \"JHd\", \"status\": \"FAILED_TO_RESOLVE\", \"target\": [] }, { \"source\": \"JHt\", \"status\": \"OK\", \"target\": [\"JI5\"] } ], \"targetDocumentMicroversion\": \"52aa74d34b624f3aaef33204\" } Roll back the delete and the split, and translate the IDs: POST\nhttps://cad.onshape.com/api/partstudios/d/\u003cdocid\u003e/w/\u003cwid\u003e/e/\u003ceid\u003e/idtranslations Body:\n{ \"sourceDocumentMicroversion\" : \"47e75ab2ee8b4356a76ebd47\", \"ids\" : [\"JHD\", \"JHO\", \"JHd\", \"JHt\"] } Response:\n{ \"documentId\": \"748d6e850c9248328189922b\", \"elementId\": \"042a6fa54e79451e8076463d\", \"sourceDocumentMicroversion\": \"47e75ab2ee8b4356a76ebd47\", \"ids\": [ { \"source\": \"JHD\", \"status\": \"OK\", \"target\": [\"JID\"] }, { \"source\": \"JHO\", \"status\": \"OK\", \"target\": [\"JHO\"] }, { \"source\": \"JHd\", \"status\": \"OK\", \"target\": [\"JHd\"] }, { \"source\": \"JHt\", \"status\": \"OK\", \"target\": [\"JHt\"] } ], \"targetDocumentMicroversion\": \"52aa74d34b624f3aaef33204\" } ","categories":"","description":"","excerpt":"Onshape does not expose a persistent ID for any of these entities. ‚Ä¶","ref":"/docs/api-adv/associativity/","tags":"","title":"Associativity"},{"body":"This document describes APIs that will allow partners to interact with the Onshape billing system.\nPlease address questions to ‚Äúapi-support@onshape.com‚Äù for the fastest response.\nOverview All billing is done through ‚Äúplans‚Äù that are created in the Developer Portal. A ‚Äúplan‚Äù has the following attributes:\nName (also called SKU) A unique (within your company) plan name Description A user-visible description of the plan Amount The cost of the plan (may be one-time or recurring, depending on the type) Type Monthly, One-time or Consumable Onshape defines three kinds of plans:\nPlan type Description Recurring (Monthly Subscription) A plan that is renewed monthly at a fixed cost. All Apps in the app store must have a Free monthly plan (which is created by default), and may have additional paid plans. One-time A plan that is purchased once (not renewed monthly). A user may purchase these multiple times. Consumable A plan that represents a consumable unit, such as \"hours of rendering\" or ‚Äúsimulation runs‚Äù. Consumable plans are not fully implemented at this time, but the consumable functionality can be implemented using One-time Purchase plans as described below. Users may purchase plans through the App Store interface. In addition, if your application has the OAuth Purchase Scope, your application can initiate ‚Äúin-app‚Äù purchases by calling Onshape to request a purchase.\nThe basic steps for interacting with Onshape Billing:\nDefine one or more plans using the Developer Portal interface Use the Onshape API to determine the current user‚Äôs plan Provide features and/or limits based on the current plan Using the Onshape Billing API GET /api/accounts/purchases\nReturns a list of purchase made by the current user for plans owned by the current application. Use this information to determine what capabilities or features the user is entitled to use.\nDELETE /api/accounts/purchases/\u003cpurchase id\u003e\nCancel a recurring purchase.\nPOST /api/accounts/purchases/\u003cpurchase id\u003e/consume\nIndicate the use of a consumable. (Not fully implemented at this time)\nGET /api/billing/plans/client/\u003cclient id\u003e\nGet a list of the billing plans defined for this client.\nInitiating a purchase from an application (in-app purchases) To initiate a purchase of a subscription or one time item you must set the browser‚Äôs location to particular URL within the Onshape stack:\nhttps://cad.onshape.com/billing/purchase?redirectUri=RRRR\u0026clientId=CCCC\u0026sku=SSSS\u0026userId=UUUU\nEach of the query parameters should be URL encoded. The clientId is your application‚Äôs OAuth Client ID, the sku is the name/sku field for an item (you can find this in the developer portal or it‚Äôs retrievable through the /api/billing/plans REST endpoints). The user Id should be the Onshape user Id for the current user and is available through the /api/users/session REST endpoint. The redirectUri is the URI the user will be returned to within your website when the purchase is finished.\nWhen the browser‚Äôs location is changed to this pattern the Onshape stack will serve content to confirm the users identity, confirm the details of what is being purchased (or obtained if the item is free) and then after the user agrees to the purchase will confirm the transaction (with our payment processor if the item is not free) and then redirect the user back to the supplied redirectUri (the browser location will be changed to the redirectUri). Additionally Onshape will add a success=true or success=false query parameter to the redirectURI indicating whether the user completed successfully (payment was taken if required etc.) or failed, either due to cancelling the purchase or an issue with payment.\nWhen the browser fetches the redirectUri your application must call back through the /api/account/purchases API to get confirmation of the purchase - do NOT assume that a fetch of the redirectUri with a success=true query parameter actually indicates a purchase has occurred. Query the Onshape stack with the /api/account/purchases API to ensure that the required item has actually been bought.\nConsumable Items A detailed description of the interface for managing consumable purchases will be provided shortly. You can use one-time plans to achieve similar results:\nDefine a one-time purchase plan with a description indicating the nature of the purchase, for example:\nRENDER-10\tTen rendering hours\t$100\nKeep track of the number of hours that the user has consumed. You can store and retrieve this information in Onshape using the following APIs. These APIs allow you to store and retrieve arbitrary information on a per-user basis.\nPOST /applications/clients/:cid/settings/users/:uid GET /applications/clients/:cid/settings/users/:uid\nCheck the number of available ‚Äúunits‚Äù by getting the purchases and the record of consumables. Be sure to include UI in your application that the user can use to see their remaining quantity.\nAlternately, you can store the consumption data in your own system; you do not need to use the Onshape API to manage that data.\nOnshape intends to provide a richer set of APIs that help track the purchase and consumption of consumables in the near future.\nOther billing models You can use these mechanisms to implement other models. For example, a time-limited trial could be implemented by scanning purchases for the first ‚Äúpurchase‚Äù and denying service if it is more than a defined number of days in the past. A ‚Äúfixed number of uses per month‚Äù could be implemented as a monthly subscription, string usage data with the settings API, and denying service after a fixed number of uses.\nSamples Onshape will provide sample code for both desktop and integrated applications demonstrating the use of the billing APIs and workflow. If you are subscribed to the Onshape Github Partner group, you will have access to those samples as soon as they are posted.\nTesting Please contact api-support@onshape.com to discuss details of testing billing \u0026 subscriptions.\n","categories":"","description":"","excerpt":"This document describes APIs that will allow partners to interact with ‚Ä¶","ref":"/docs/api-adv/billing/","tags":"","title":"Billing"},{"body":"This page describes the APIs Onshape provides for working with Configurations.\nYou can use Configurations to create variations of entire Part Studios, Assemblies, specific parts and more. You can configure feature and parameter values, part properties, custom part properties, face and part appearances, and sketch text. Each Part Studio can have only one Configuration, but it can contain multiple Configuration inputs. The Configuration inputs you define for a Part Studio become options when inserting that Part Studio into an Assembly or Drawing. You can also create your own Configurations for an Assembly, regardless of any existing Part Studio Configurations. Assembly Configurations work the same way as Part Studio Configurations, but are limited to configuring Mates (not Mate connectors), instances, and patterns.\nüìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {eid}, {pid}, {otherId}. These represent document, workspace, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com Endpoints Element/getConfiguration: Get the configuration data for a Part Studio or Assembly. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/wvm/{wvmid}/e/{eid}/configuration' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' Element/updateConfiguration: Update the configuration data for a Part Studio or Assembly. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/wvm/{wvmid}/e/{eid}/configuration' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ }' Element/decodeConfiguration: Process an encoded configuration file. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/wvm/{wvmid}/e/{eid}/configurationencodings/{encodingId}' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Element/encodeConfigurationMap: Create an encoded map of configurations. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/e/{eid}/configurationencodings' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"parameters\": [ { \"parameterId\": \"{parameterId}\", \"parameterValue\": \"{configValue}\" } ] }' Encoded Configuration Strings The Element/encodeConfigurationMap and Element/decodeConfiguration APIs convert parameters from JSON to a URL-encoded string in the following format: \"configuration=parameterId%3DparameterValue\"\nFor example,\n{ \"parameters\": [ { \"parameterId\": \"List_izOjbm5HCRXEld\", \"parameterValue\": \"_500_mm\" } ] } encodes to:\n\"configuration=List_izOjbm5HCRXEld%3D_500_mm\" and:\n\"configuration=List_izOjbm5HCRXEld%3DDefault\" decodes to:\n{ \"parameters\": [ { \"parameterId\": \"List_izOjbm5HCRXEld\", \"parameterValue\": \"Default\" } ] } Sample Workflows These sample workflows all build off one another. Completing all of the workflows will take you step-by-step through the process of getting Configuration information, encoding the information for use, and using the encoded configuration to create a configured export. You can also watch the video to see the entire workflow in the Glassworks API Explorer.\nGet a Configuration In this example, we‚Äôll use the Element/getConfiguration endpoint to get the Configuration information from a Part Studio.\nMake a copy of this public document. Make a note of the new document‚Äôs document ID, workspace ID, and element ID. Click the Configurations dropdown in the Features list, and observe that there are two options for the drillbit length, 250 mm and 500 mm. Set up a call to the Element/getConfiguration endpoint to get the Configuration for the Part Studio. Don‚Äôt forget to replace the URL parameters with the IDs from your copy of the document, and replace CREDENTIALS with your authorization credentials. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/w/{wid}/e/{eid}/configuration' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ Review the Configuration information detailed in the response. You can see that the Part Studio contains one configuration (Drill_Bit_Length) with two options (250 mm and 500 mm): { \"btType\": \"BTConfigurationResponse-2019\", \"currentConfiguration\": [ { \"btType\": \"BTMParameterEnum-145\", \"namespace\": \"\", \"nodeId\": \"{nodeId1}\", \"value\": \"Default\", \"enumName\": \"{paramId_conf}\", \"parameterId\": \"{paramId}\" } ], \"configurationParameters\": [ { \"btType\": \"BTMConfigurationParameterEnum-105\", \"defaultValue\": \"Default\", \"enumName\": \"{enumName}\", \"namespace\": \"\", \"options\": [ { \"btType\": \"BTMEnumOption-592\", \"optionName\": \"250 mm\", \"option\": \"Default\", \"nodeId\": \"{nodeId2}\" }, { \"btType\": \"BTMEnumOption-592\", \"optionName\": \"500 mm\", \"option\": \"_500_mm\", \"nodeId\": \"{nodeId3}\" } ], \"isCosmetic\": false, \"parameterId\": \"{paramId}\", \"parameterName\": \"Drill_Bit_Length\", \"nodeId\": \"{nodeId4}\" } ], \"serializationVersion\": \"1.2.0\", \"sourceMicroversion\": \"{mid}\", \"microversionSkew\": false, \"rejectMicroversionSkew\": false, \"libraryVersion\": 2296 } Encode a configuration string In this example, we‚Äôll encode a Configuration so it can be used as part of a translation (i.e., an export). Please read the Encoded Configuration Strings section before beginning this example.\nThis example builds off the previous one. Please complete the Get a Part Studio Configuration workflow to obtain the raw Configuration output for the Part Studio. Set up a call to the Element/encodeConfigurationMap endpoint. Don‚Äôt forget to replace the URL parameters with the IDs from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/e/{eid}/configurationencodings' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ }' Now we need to create our JSON body for the request. Note the structure of the body: { \"parameters\": [ { \"parameterId\": \"string\", \"parameterValue\": \"string\" } ], \"standardContentParametersId\": \"string\" } Fill out the request body with our information: We‚Äôre not using a standard content part, so we can delete the second key/value pair. The parameterId can be found in the response from the previous example. It usually begins with (List_) For the parameter value, we‚Äôll enter one of our configuration options from the previous example. In this case, we‚Äôll use _500_mm to export a 500 mm drillbit part. { \"parameters\": [ { \"parameterId\": \"{parameterId}\", \"parameterValue\": \"_500_mm\" } ] } Now we can make our call: curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/elements/d/{did}/e/{eid}/configurationencodings' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"parameters\": [ { \"parameterId\": \"{parameterId}\", \"parameterValue\": \"_500_mm\" } ] }' The call responds with two values: the ID of the encoding, and the encoded configuration string. We can use this configuration string (returned in the queryParam field) any time we want to specify the 500 mm drillbit length. { \"encodedId\": \"{encodedId}\", \"queryParam\": \"configuration={configString}\" } Export a configured part In this example, we will export a configured part. We have a drillbit with two configurations: 250 mm and 500 mm lengths. To export a 500 mm drillbit, we can specify the configuration as part of the export.\nThis example builds off the previous two. Please complete this exercise after the Encode a configuration workflow. Next, set up a call to the PartStudio/exportParasolid endpoint. Don‚Äôt forget to replace the URL parameters with the IDs from your document, and replace CREDENTIALS with your authorization credentials. Note that this endpoint includes an optional configuration parameter. This is where we‚Äôll enter the configuration string we found in the previous example. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/partstudios/d/{did}/w/{wid}/e/{eid}/parasolid?version=0\u0026includeExportIds=false\u0026configuration={configString}\u0026binaryExport=false' \\ -H 'Accept: */*' \\ -H 'Authorization: Basic CREDENTIALS' \\ This endpoint returns a redirect URL. Navigate to the returned URL in your browser to download the export. Hint: The URL will look something like this, but with different IDs: https://cad.onshape.com/api/v6/partstudios/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/958bceb5a2511b572dbbe851/parasolid?version=0\u0026includeExportIds=false\u0026configuration=List_izOjbm5HCRXEld%253D_500_mm\u0026binaryExport=false Now we need to import our Parasolid to confirm the correct configuration was used. Open your document in the Onshape UI, click the Insert new tab button, and then select Import. Navigate to the export you downloaded (with the .x_t extension) and import it into Onshape. Use the measure tool to confirm the length of the imported drillbit is 500 mm. Workflow Video This video demonstrates how to complete the above tutorials in the Onshape API Explorer. Additional Resources API Explorer: Configurations API Guide: API Explorer Onshape Help: Configurations ","categories":"","description":"","excerpt":"This page describes the APIs Onshape provides for working with ‚Ä¶","ref":"/docs/api-adv/configs/","tags":"","title":"Configurations"},{"body":"This page describes the APIs Onshape provides for creating and manipulating Onshape drawings.\nüìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {eid}, {pid}, {otherId}. These represent document, workspace, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com Endpoints To create drawings, Onshape allows you to send all drawing data points and information through the API as part of the request body JSON.\nThe following endpoints are available:\nCreate a drawing curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \u003cJSON request body options from the BTDrawingParams schema\u003e }' Specify the document in which to create the drawing in the URL, and pass any additional options as part of the request body. You can provide a name for the drawing, manipulate the drawing graphics area, specify a part or template to create the drawing from, and more. See documentation for all available options in the API Explorer. For instructions on viewing the documentation for the request body schemas, see our API Explorer page. Check out the Sample Workflows section below for some practical examples. Modify a drawing curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Description of the modification.\", \"jsonRequests\": [ { \u003cJSON request body options from the jsonRequests schema\u003e } ] }' Specify the drawing to modify in the URL, and pass the information on the modification in the request body. Note that the jsonRequests schema is not defined in the Glassworks API Explorer; see the OnshapeDrawingJson repository for this information, and check out the Sample Workflows section below for some practical examples. Get the drawing modification status curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/drawings/modify/status/{mrid} -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Provide the modification ID (from the modifyDrawing response body) to get the status of the modification. Translate a drawing: See the Translations API Guide. Get drawing translation formats: See the Translations API Guide. Sample App Please see the Onshape TypeScript Drawing Client for a working example of using the Onshape Drawing APIs in an application.\nSample Workflows Create a drawing from a part In this example, we‚Äôll create a drawing from the FLYWHEEL part in this public document.\nCreate or open an Onshape document in which to create your drawing. Start to form the Drawings/createDrawingAppElement call. Replace {did} and {wid} in the URL below with the document ID and workspace ID of your document (i.e., the target document), and replace CREDENTIAL with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add the request body information: Add flywheelDrawing as the drawingName field. We must specify the source document‚Äôs document and version IDs. Note that since our target document and source document are different, we use the external document and version ID fields. We must also provide the ID of the part to create the drawing from, and the ID of the element (i.e., tab) in which the part lives. (Hint: You can call Part/getPartsWMVE to get a list of part IDs in an element.) curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"drawingName\": \"flywheelDrawing\", \"externalDocumentId\": \"e60c4803eaf2ac8be492c18e\", \"externalDocumentVersionId\": \"405ba186c3a70e0227ab2941\", \"elementId\": \"6bed6b43463f6a46a37b4a22\", \"partId\": \"JiD\" }' Call the endpoint and open your document. Confirm that you see the new flywheelDrawing element containing the drawing: Create a drawing from a template In this example, we‚Äôll create a drawing from the standard ANSI template in this public document.\nOpen any Onshape document in which to create your drawing. Start to form the Drawings/createDrawingAppElement call. Replace {did} and {wid} in the URL below with the document ID and workspace ID of your document (i.e., the target document), and replace CREDENTIAL with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add the request body information: Add templateAnsiDrawing as the drawingName field. We must specify the source document‚Äôs document ID and workspace ID. We must also provide the ID of the element (i.e., tab) in which the template lives. Note that we use the template document, workspace, and element ID fields when referring to a specific template for drawing creation. curl 'https://cad.onshape.com/api/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json, text/plain, */*' \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -d '{ \"drawingName\": \"templateAnsiDrawing\", \"templateDocumentId\":\"cbe6e776694549b5ba1a3e88\", \"templateWorkspaceId\":\"24d08acf10234dbc8d3ab585\", \"templateElementId\":\"17eef7862b224f6fb12cbc46\" }' Call the endpoint and open your document. Confirm that you see the new templateAnsiDrawing element containing the emtpy drawing template. Create a drawing in a custom graphics area Open any Onshape document in which to create your drawing. Start to form the Drawings/createDrawingAppElement call. Replace {did} and {wid} in the URL below with your document, and replace CREDENTIAL with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the drawings area. In this example, we‚Äôll add an additional column and row to the drawings area, a title block, and add a border around it. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/create' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"drawingName\": \"customGraphicsArea\", \"border\": \"true\", \"numberHorizontalZones\": \"3\", \"numberVerticalZones\": \"3\" \"titleblock\": true }' Call the endpoint and open your document. Confirm that you see the new customGraphicsArea element: Add a note to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll create an Onshape::Note on the drawing. We must specify the messageName and formatVersion for the modification, and then provide the contents and size of the annotation. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add a note to the drawing.\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"type\": \"Onshape::Note\", \"note\": { \"position\": { \"type\": \"Onshape::Reference::Point\", \"coordinate\": [ 1, 10, 0 ] }, \"contents\": \"This is a note\", \"textHeight\": 0.2, \"logicalId\": \"note1\" } } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new note. Note that your drawing may not match this image exactly, depending on your drawing and document properties. This sample document uses Inches for units. Add a callout to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::Callout to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the contents and size of the annotation: curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add a callout to the drawing.\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"callout\": { \"borderShape\": \"Circle\", \"borderSize\": 0, \"contents\": \"Example Callout\", \"contentsBottom\": \"bottom\", \"contentsLeft\": \"left\", \"contentsRight\": \"right\", \"contentsTop\": \"top\", \"position\": { \"coordinate\": [ 2.5, 6, 0 ], \"type\": \"Onshape::Reference::Point\" }, \"textHeight\": 0.12, \"logicalId\": \"callout1\" }, \"type\": \"Onshape::Callout\" } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new callout. Add a centerline to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::Centerline to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the coordinates of the centerline ends. Note: you can Export a Drawing to JSON to get a list of valid coordinates and handles. Note: if you have access, you can refer to the ODA documentation for more detailed formatting information. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add a centerline to the drawing\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"pointToPointCenterline\": { \"point1\": { \"coordinate\": [ 2, 4, 0 ], \"type\": \"Onshape::Reference::Point\", \"uniqueId\": \"point1\", \"viewId\": \"51fa8b6040e411dfd17a4cda\" }, \"point2\": { \"coordinate\": [ 7, 6, 1 ], \"type\": \"Onshape::Reference::Point\", \"uniqueId\": \"point2\", \"viewId\": \"ay6a8b6020e4h7dfdnn1499i\" } }, \"type\": \"Onshape::Centerline::PointToPoint\" } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new centerline. Add a dimension to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::Dimension to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the coordinates and formatting options for the dimension. (Hint: you can Export a Drawing to JSON to get a list of valid coordinates and handles.) curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add a dimension to the drawing\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"radialDimension\": { \"centerPoint\": { \"coordinate\": [ 0.2800021171569824, 0.014964947476983043, 0.079502 ], \"type\": \"Onshape::Reference::Point\", \"uniqueId\": \"point1\", \"viewId\": \"e11c38795c04ca55047f7ea7\" }, \"chordPoint\": { \"coordinate\": [ 0.2920149764955524, 0.010030535983985095, 0.079502 ], \"type\": \"Onshape::Reference::Point\", \"uniqueId\": \"point2\", \"viewId\": \"e11c38795c04ca55047f7ea7\" }, \"formatting\": { \"dimdec\": 2, \"dimlim\": false, \"dimpost\": \"R\u003c\u003e\", \"dimtm\": 0, \"dimtol\": false, \"dimtp\": 0, \"type\": \"Onshape::Formatting::Dimension\" }, \"logicalId\": \"dimension1\", \"textOverride\": \"\", \"textPosition\": { \"coordinate\": [ 191.80537349378181, 89.76274130852224, 0 ], \"type\": \"Onshape::Reference::Point\" } }, \"type\": \"Onshape::Dimension::Radial\" } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new dimension. Add a geometric tolerance to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::GeometricTolerance to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the frames and position of the annotation: curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add a geometric tolerance to the drawing\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"geometricTolerance\": { \"frames\": [ \"{\\\\fDrawing Symbols Sans;‚óé}%%v{\\\\fDrawing Symbols Sans;‚àÖ}tol1{\\\\fDrawing Symbols Sans;‚ìÇ}%%v%%v%%v%%v%%v\\n\", \"{\\\\fDrawing Symbols Sans;‚åñ}%%vto2{\\\\fDrawing Symbols Sans;‚ìÅ}%%v%%v%%v%%v%%v\\n\" ], \"logicalId\": \"geometricTolerance1\", \"position\": { \"coordinate\": [ 6, 6, 0 ], \"type\": \"Onshape::Reference::Point\" } }, \"type\": \"Onshape::GeometricTolerance\" } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new annotation. Add an inspection symbol to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::InspectionSymbol to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the shape and position of the inspection symbol. (Hint: you can Export a Drawing to JSON to get a list of valid coordinates and handles.) curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"Add an inspection symbol to the drawing\", \"jsonRequests\": [ { \"messageName\": \"onshapeCreateAnnotations\", \"formatVersion\": \"2021-01-01\", \"annotations\": [ { \"inspectionSymbol\": { \"borderShape\": \"Circle\", \"borderSize\": 2, \"logicalId\": \"inspection1\", \"parentAnnotation\": \"h:10000577\", \"parentLineIndex\": 0.0, \"position\": { \"coordinate\": [ 2.6, 6, 0 ], \"type\": \"Onshape::Reference::Point\" }, \"textHeight\": 2 }, \"type\": \"Onshape::InspectionSymbol\" } ] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new inspection symbol. Add a table to a drawing Open an existing (or create a new) Onshape document with a drawing. Start to form the Drawings/modifyDrawing call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\s -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add information about the modification. In this example, we‚Äôll add an Onshape::Table::GeneralTable to the drawing. We must specify the messageName and formatVersion for the modification, and then provide the location, number of rows, and number of columns for the table. (Hint: you can Export a Drawing to JSON to get a list of valid coordinates.) curl -X 'POST \\ 'https://cad.onshape.doc/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/modify' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"description\": \"New table\", \"jsonRequests\": [ { \"formatVersion\": \"2021-01-01\", \"messageName\": \"onshapeCreateAnnotations\", \"annotations\": [ { \"table\": { \"cells\": [ { \"column\": 0, \"content\": \"1.1\", \"row\": 0 }, { \"column\": 0, \"content\": \"2.1\", \"row\": 1 }, { \"column\": 1, \"content\": \"1.2\", \"row\": 0 }, { \"column\": 1, \"content\": \"2.2\", \"row\": 1 } ], \"columns\": 2, \"rows\": 2, \"showHeaderRow\": false, \"showTitleRow\": false, \"position\": { \"coordinate\": [100.0, 400.0, 0.0], \"type\": \"Onshape::Reference::Point\" } }, \"type\": \"Onshape::Table::GeneralTable\" }] }] }' Make the call, and then get id from the response body. You‚Äôll need this to poll the modification status to figure out when the modification has completed. Set up the Drawings/getModificationStatus call. Replace {mrid} with the id from the last step, and replace CREDENTIALS with your credentials. Poll the modification status until the response returns \"requestState\": \"DONE\". curl -X 'GET \\ 'https://cad.onshape.doc/api/v6/drawings/modify/status/{mrid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Open your drawing and confirm that you see the new table. Additional Resources Guide to Onshape APIs Guide to the API Explorer API Explorer: Drawings Onshape Help: Drawings ","categories":"","description":"","excerpt":"This page describes the APIs Onshape provides for creating and ‚Ä¶","ref":"/docs/api-adv/drawings/","tags":"","title":"Drawings"},{"body":"This page describes the APIs Onshape provides for creating and manipulating features and the Feature List in a Part Studio.\nüìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {vid}, {mid}, {eid}, {pid}, {otherId}. These represent document, workspace, version, microversion, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com FeatureScript vs REST API When working with complex geometry, you might find working directly in FeatureScript easier than working with the Onshape REST API. Click here to see the FeatureScript documentation.\nEndpoints The following endpoints are available for working with features and the Feature List:\nGet the Feature List curl -X 'GET' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features?rollbackBarIndex=-1\u0026includeGeometryIds=true\u0026noSketchGeometry=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Add a Feature curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{wid}/features' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"btType\": \"BTMFeature-134\", \"featureType\": \"\", \"name\": \"\", \"parameters\": [] } }' Update a Feature curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"btType\": \"BTMFeature-134\", \"featureId\": \"{fid}\", \"parameters\": [] } }' Update Multiple Features curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/features/updates' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"btType\": \"BTUpdateFeaturesCall-1748\", \"features\": [ { \"btType\": \"BTMFeature-134\", \"featureId\": \"{fid1}\", \"parameters\": [] }, { \"btType\": \"BTMFeature-134\", \"featureId\": \"{fid2}\", \"parameters\": [] } ] }' Delete a Feature curl -X 'DELETE' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features/featureid/{fid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' JSON encoding Instead of providing a translation layer between a feature‚Äôs internal and external formats, these APIs present the internal format of the feature definitions to the user. The best way to familiarize yourself with the formats involved is by calling the Get the Feature List endpoint on existing Part Studios.\nüìò Notes\nOnshape REST API parameters may change at any time. The documentation on this page is accurate for v8 of the Onshape API. The quickest way to verify what parameters are needed for a call is to create the sketch/feature in the Onshape UI, then call the Get the Feature List API and see what parameters are returned for the feature. üìò Notes\nDefault values are sometimes omitted in the encoded output. These defaults are: String: \"\" Boolean: false Numeric: 0 The JSON encoding uses a special tagging system to manage polymorphic data structures. Objects are generally by enclosing them within another object that declares the type information for the enclosed object. Feature types Below, find the available types for working with features in the API.\nBTMFeature-134 - General feature type BTMSketch-151 - Feature type for sketches Parameter types All parameters have the following fields in common:\nparameterId - Unique ID of the parameter nodeId - Unique ID of the parameter node The parameter types available for use in the API are:\nBTMParameterQuantity-147 expression - Define the value for the parameter BTMParameterQueryList-148 - defined by one of the following: SBTMIndividualQuery-138 geometryIds - List of geometry IDs the feature applies to SBTMIndividualSketchRegionQuery-140 featureId - Feature ID of the sketch for which to include all regions BTMParameterBoolean-144 value - true | false BTMParameterEnum-145 enumName - Name of the enum type that the value is a member of value - The enum member Sketch plane IDs The following string can be sent along with the PartStudios/featurescript API to get the plane ID. You can then use that ID to specify the plane on which to create a sketch.\nfunction(context is Context, queries) { return transientQueriesToStrings(evaluateQuery(context, qCreatedBy(makeId(\\\"{planeName}\\\"), EntityType.FACE))); } For example, to get the ID of the Top plane, you would make the following call:\ncurl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/featurescript?rollbackBarIndex=-1' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"script\": \"function(context is Context, queries) { return transientQueriesToStrings(evaluateQuery(context, qCreatedBy(makeId(\\\"Top\\\"), EntityType.FACE))); }\" }' Sample Workflows Below are several examples of how the API can be used in order to help you get started. The calls could be executed using your preferred software environment but interactive use in a REST-aware tool is likely the easiest way to try the examples.\nGet the list of features in a Part Studio One of the best ways to familiarize yourself with the Onshape Feature APIs is to view the API details for existing features in a Part Studio. In this example, we‚Äôll add three features to a Part Studio, and then call the PartStudio/getPartStudioFeatures API on the Part Studio. We‚Äôll then be able to view the structure of the way features are represented in the API.\nCreate a new document or open an existing one. Create a new sketch in the document, and draw a long rectangle. Extrude the rectangle. Add a fillet to one edge of the part. Call the PartStudio/getPartStudioFeatures API. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'GET \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features?rollbackBarIndex=-1\u0026includeGeometryIds=true\u0026noSketchGeometry=false' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' Review the JSON returned in the response body. A lot of information is returned, but it will look something like the truncated snippet below. Notice that there are objects returned for each feature in the Part Studio‚Äì the sketch, the extrude, the fillet, and the chamfer. Each default plane and the origin in the Part Studio also appear in the defaultFeatures object. The Standard Geometry library is listed as an import, and the response also includes the state of each feature. : { \"btType\": \"BTFeatureListResponse-2457\", \"isComplete\": true, \"serializationVersion\": \"1.2.4\", \"rollbackIndex\": 4, \"features\": [ { \"btType\": \"BTMSketch-151\", \"entities\": [...], \"constraints\": [...], \"name\": \"Sketch 1\", \"suppressed\": false, \"parameters\": [...], \"featureId\": \"{fid1}\", \"featureType\": \"newSketch\", \"subFeatures\": [...], \"returnAfterSubfeatures\": false }, { \"btType\": \"BTMFeature-134\", \"name\": \"Extrude 1\", \"suppressed\": false, \"parameters\": [...] \"featureId\": \"{fid2}\", \"featureType\": \"extrude\", \"subFeatures\": [], \"returnAfterSubfeatures\": false }, { \"btType\": \"BTMFeature-134\", \"name\": \"Fillet 1\", \"suppressed\": false, \"parameters\": [...], \"featureId\": \"{fid3}\", \"featureType\": \"fillet\", \"subFeatures\": [...], \"returnAfterSubfeatures\": false }, { \"btType\": \"BTMFeature-134\", \"name\": \"Chamfer 1\", \"suppressed\": false, \"parameters\": [...], \"featureId\": \"{fid4}\", } ], \"featureStates\": { \"{fid1}\": { \"btType\": \"BTFeatureState-1688\", \"featureStatus\": \"OK\", \"inactive\": false }, ... }, \"defaultFeatures\": [ { \"btType\": \"BTMFeature-134\", \"name\": \"Origin\", }, { \"btType\": \"BTMFeature-134\", \"name\": \"Top\", }, { \"btType\": \"BTMFeature-134\", \"name\": \"Front\", }, { \"btType\": \"BTMFeature-134\", \"name\": \"Right\", } ], \"imports\": [ { \"btType\": \"BTMImport-136\", \"path\": \"onshape/std/geometry.fs\", \"version\": \"2232.0\" } ], \"libraryVersion\": 2232 } Create a cube feature In this example we will create a cube using the cube feature. The feature accepts a single parameter (the length of a side) and creates a cube with a corner at the origin and aligned with the three default planes.\nCreate a new document or open an existing one. We‚Äôll create the cube feature in this document. Begin to create the PartStudio/addPartStudioFeature call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. This is a call to the same endpoint as in the previous example, but is a POST instead of a GET. curl -X 'POST \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \u003cJSON of feature data\u003e }' Add the following as the JSON body. Note the btType defines this as a Feature. We‚Äôve named the feature cube and inserted an instance of the feature named Cube 1 into the Part Studio. The cube feature has one parameter‚Äì the cube sideLength in inches, which is set to 1 by default. { \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"btType\": \"BTMFeature-134\", \"featureType\": \"cube\", \"name\": \"Cube 1\", \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"isInteger\": false, \"expression\": \"1 in\", \"parameterId\": \"sideLength\" } ], \"returnAfterSubfeatures\": false, \"suppressed\": false } } Confirm your call matches the following, and then make the call: curl -X 'POST \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"btType\": \"BTMFeature-134\", \"featureType\": \"cube\", \"name\": \"Cube 1\", \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"isInteger\": false, \"expression\": \"1 in\", \"parameterId\": \"sideLength\" } ], \"returnAfterSubfeatures\": false, \"suppressed\": false } }' Return to your console to review the endpoint response. The output returns: The feature definition that we provided as input with nodeIds and a featureId. Make a note of the featureId; we‚Äôll use it in the next example. Information that the feature executed correctly The serialization version and microversion of the document that resulted from the feature addition { \"btType\": \"BTFeatureDefinitionResponse-1617\", \"featureState\": { \"btType\": \"BTFeatureState-1688\", \"featureStatus\": \"OK\", \"inactive\": false }, \"feature\": { \"btType\": \"BTMFeature-134\", \"name\": \"Cube 1\", \"suppressed\": false, \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"value\": 0, \"units\": \"\", \"isInteger\": false, \"expression\": \"1 in\", \"nodeId\": \"{nid1}\", \"parameterId\": \"sideLength\" } ], \"featureId\": \"{fid}\", \"nodeId\": \"{nid2}\", \"featureType\": \"cube\", \"returnAfterSubfeatures\": false, \"subFeatures\": [], \"namespace\": \"\" }, \"serializationVersion\": \"1.2.4\", \"sourceMicroversion\": \"{mid}\", \"microversionSkew\": false, \"rejectMicroversionSkew\": false, \"libraryVersion\": 0 } Open your document and confirm that the cube has been inserted into the Part Studio. Double-click Cube 1 in the Feature List to open the Cube 1 dialog. Change the sideLength to 3 and click the checkbox. Note that the size of the cube changes automatically. Create a sketch In this example, we‚Äôll create a circular sketch feature with the following properties:\nWhile other features use a btType of BTMFeature-141, sketches have their own special type: BTMSketch-151 Sketches must use the newSketch featureType Sketch plane ID: Front Radius: 0.025 inches Location: (0.05, 0.05) Open a new PartStudio. Note the following: Document ID Workspace ID Element ID (of the Part Studio tab) We want to create the circle on the Front plane, so we‚Äôll call the PartStudios/featurescript endpoint to get its ID: curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/featurescript?rollbackBarIndex=-1' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"script\": \"function(context is Context, queries) { return transientQueriesToStrings(evaluateQuery(context, qCreatedBy(makeId(\\\"Front\\\"), EntityType.FACE))); }\" }' The call returns the following, identifying the plane as JCC. { \"btType\": \"BTFeatureScriptEvalResponse-1859\", \"result\": { \"btType\": \"com.belmonttech.serialize.fsvalue.BTFSValueArray\", \"value\": [ { \"btType\": \"com.belmonttech.serialize.fsvalue.BTFSValueString\", \"value\": \"JCC\", \"typeTag\": \"\" } ], \"typeTag\": \"\" } } Now we‚Äôll create the JSON structure for our sketch. All sketches must be created with the BTMSketch-151 btType and the newSketch featureType. Note how we‚Äôve specified the plane to use in the sketchPlane parameter, and the geometry details. { \"feature\" : { \"btType\": \"BTMSketch-151\", \"featureType\": \"newSketch\", \"name\": \"Sketch 1\", \"parameters\": [ { \"btType\": \"BTMParameterQueryList-148\", \"queries\": [ { \"btType\": \"BTMIndividualQuery-138\", \"deterministicIds\": [ \"JCC\" ] } ], \"parameterId\": \"sketchPlane\" } ], \"entities\": [ { \"btType\": \"BTMSketchCurve-4\", \"geometry\": { \"btType\": \"BTCurveGeometryCircle-115\", \"radius\": 0.025, \"xcenter\": 0.05, \"ycenter\": 0.05, \"xdir\": 1, \"ydir\": 0, \"clockwise\": false }, \"centerId\": \"circle-entity.center\", \"entityId\": \"circle-entity\" } ], \"constraints\": [ ] } } Now we‚Äôll add the JSON structure to the PartStudio/addPartStudioFeature endpoint. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{wid}/features' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"feature\" : { \"btType\": \"BTMSketch-151\", \"featureType\": \"newSketch\", \"name\": \"Sketch 1\", \"parameters\": [ { \"btType\": \"BTMParameterQueryList-148\", \"queries\": [ { \"btType\": \"BTMIndividualQuery-138\", \"deterministicIds\": [ \"JCC\" ] } ], \"parameterId\": \"sketchPlane\" } ], \"entities\": [ { \"btType\": \"BTMSketchCurve-4\", \"geometry\": { \"btType\": \"BTCurveGeometryCircle-115\", \"radius\": 0.025, \"xcenter\": 0.05, \"ycenter\": 0.05, \"xdir\": 1, \"ydir\": 0, \"clockwise\": false }, \"centerId\": \"circle-entity.center\", \"entityId\": \"circle-entity\" } ], \"constraints\": [ ] } }' Find the new sketch‚Äôs featureId in the call response. You‚Äôll need this for the Create a cylinder tutorial. Open your Part Studio and confirm that the sketch has been added: Create a cylinder In this tutorial, we‚Äôll extrude an sketch with the following properties: This tutorial expands on the Create a sketch tutorial. You‚Äôll need the following from the document containing your circular sketch: Document ID Workspace ID Element ID of the tab containing the sketch Feature ID of the sketch If you need to get this featureId again, you can call the getPartStudioFeatures endpoint on the document. Begin to create the PartStudio/addPartStudioFeature call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \u003cJSON of feature data\u003e }' Creating an extrude has many options; this means creating an extrude in the API requires adding a lot of parameters, even if they‚Äôre not used. To make this tutorial a little easier to follow, we‚Äôll start by constructing the JSON with all available parameters, then we‚Äôll fill in the ones we need to manipulate. Note the btType and featureType added below: { \"features\": [ { \"btType\": \"BTMFeature-134\", \"featureType\": \"extrude\", \"name\": \"Extrude 1\", \"suppressed\": false, \"parameters\": [ { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"bodyType\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"operationType\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"entities\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"endBound\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"depth\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"domain\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"surfaceOperationType\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"flatOperationType\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"surfaceEntities\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"wallShape\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"midplane\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness1\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"flipWall\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness2\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"endBound\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"oppositeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityFace\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityBody\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityVertex\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasOffset\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"offsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"offsetOppositeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasExtrudeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"extrudeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"startOffset\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"startOffsetBound\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"startOffsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"startOffsetOppositeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"startOffsetEntity\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"symmetric\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasDraft\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"draftAngle\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"draftPullDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirection\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"secondDirectionBound\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionOppositeDirection\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionDepth\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityFace\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityBody\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityVertex\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirectionOffset\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionOffsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionOffsetOppositeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirectionDraft\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionDraftAngle\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionDraftPullDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"defaultScope\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"booleanScope\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"defaultSurfaceScope\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"booleanSurfaceScope\" } ] } ] } Now, we‚Äôll add values for the options we want. Just like when creating an extrude within the Onshape UI, we‚Äôll specify that the extrude is a Solid, New, Blind extrude of our sketch (we‚Äôll specify the sketch by its featureId), with a depth of 1 inch. We‚Äôll leave the rest of the parameters as they are. { \"btType\": \"BTMParameterEnum-145\", \"value\": \"SOLID\", \"enumName\": \"ExtendedToolBodyType\", \"parameterId\": \"bodyType\" }, { \"btType\": \"BTMParameterEnum-145\", \"value\": \"NEW\", \"enumName\": \"NewBodyOperationType\", \"parameterId\": \"operationType\" }, { \"btType\": \"BTMParameterQueryList-148\", \"queries\": [ { \"btType\": \"BTMIndividualSketchRegionQuery-140\", \"featureId\": \"{featureId}\" } ], \"parameterId\": \"entities\" }, { \"btType\": \"BTMParameterEnum-145\", \"value\": \"BLIND\", \"enumName\": \"BoundingType\", \"parameterId\": \"endBound\" }, { \"btType\": \"BTMParameterQuantity-147\", \"expression\": \"1 in\", \"parameterId\": \"depth\" } Now our JSON is complete, and we can make our call. curl -X 'POST \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"features\": [ { \"btType\": \"BTMFeature-134\", \"featureType\": \"extrude\", \"name\": \"Extrude 1\", \"suppressed\": false, \"parameters\": [ { \"btType\": \"BTMParameterEnum-145\", \"value\": \"SOLID\", \"enumName\": \"ExtendedToolBodyType\", \"parameterId\": \"bodyType\" }, { \"btType\": \"BTMParameterEnum-145\", \"value\": \"NEW\", \"enumName\": \"NewBodyOperationType\", \"parameterId\": \"operationType\" }, { \"btType\": \"BTMParameterQueryList-148\", \"queries\": [ { \"btType\": \"BTMIndividualSketchRegionQuery-140\", \"featureId\": \"FBMwlCB9CZS8uWY_0\" } ], \"parameterId\": \"entities\" }, { \"btType\": \"BTMParameterEnum-145\", \"value\": \"BLIND\", \"enumName\": \"BoundingType\", \"parameterId\": \"endBound\" }, { \"btType\": \"BTMParameterQuantity-147\", \"expression\": \"1 in\", \"parameterId\": \"depth\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"domain\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"surfaceOperationType\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"flatOperationType\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"surfaceEntities\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"wallShape\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"midplane\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness1\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"flipWall\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness2\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"thickness\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"endBound\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"oppositeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityFace\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityBody\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"endBoundEntityVertex\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasOffset\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"offsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"offsetOppositeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasExtrudeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"extrudeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"startOffset\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"startOffsetBound\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"startOffsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"startOffsetOppositeDirection\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"startOffsetEntity\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"symmetric\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasDraft\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"draftAngle\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"draftPullDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirection\" }, { \"btType\": \"BTMParameterEnum-145\", \"parameterId\": \"secondDirectionBound\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionOppositeDirection\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionDepth\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityFace\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityBody\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"secondDirectionBoundEntityVertex\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirectionOffset\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionOffsetDistance\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionOffsetOppositeDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"hasSecondDirectionDraft\" }, { \"btType\": \"BTMParameterQuantity-147\", \"parameterId\": \"secondDirectionDraftAngle\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"secondDirectionDraftPullDirection\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"defaultScope\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"booleanScope\" }, { \"btType\": \"BTMParameterBoolean-144\", \"parameterId\": \"defaultSurfaceScope\" }, { \"btType\": \"BTMParameterQueryList-148\", \"parameterId\": \"booleanSurfaceScope\" } ] } ] }' Open your document and confirm that the sketch has been extruded into a cylinder. Update a feature In this example we‚Äôll update our cube feature.\nOpen the document in which you created the cube feature in this example. You will need the following from this document: Document ID Workspace ID Element ID (for the element that contains the cube feature) Feature ID (ID of the cube feature, returned in the API response in the previous example) If you need to get this featureId again, you can call the getPartStudioFeatures endpoint on the document. Begin to create the PartStudio/updatePartStudioFeature call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \u003cJSON of feature data\u003e }' Add the following as the JSON body. Note the btType defines this as a Feature. We specify the featureId again in the request body. This must match the featureId sent in the URL exactly. We must also specify the feature‚Äôs featureType and name in this call; if we don‚Äôt send those fields, the call will attempt to change these values to empty strings, resulting in errors. The cube feature has one parameter‚Äì the cube sideLength in inches, which we will update to 2 inches: { \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"featureId\": \"{fid}\", \"featureType\": \"cube\", \"name\": \"Cube 1\", \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"isInteger\": false, \"expression\": \"2 in\", \"parameterId\": \"sideLength\" } ] } } Confirm your call matches the following, and then make the call: curl -X 'POST' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"btType\": \"BTFeatureDefinitionCall-1406\", \"feature\": { \"featureId\": \"{fid}\", \"featureType\": \"cube\", \"name\": \"Cube 1\", \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"isInteger\": false, \"expression\": \"2 in\", \"parameterId\": \"sideLength\" } ] } }' Return to your console to review the endpoint response. The output returns: The updated feature definition Information that the feature executed correctly The serialization version and microversion of the document that resulted from the feature update { \"btType\": \"BTFeatureDefinitionResponse-1617\", \"featureState\": { \"btType\": \"BTFeatureState-1688\", \"featureStatus\": \"OK\", \"inactive\": false }, \"feature\": { \"btType\": \"BTMFeature-134\", \"name\": \"Cube 1\", \"suppressed\": false, \"parameters\": [ { \"btType\": \"BTMParameterQuantity-147\", \"value\": 0, \"units\": \"\", \"isInteger\": false, \"expression\": \"2 in\", \"nodeId\": \"{nid1}\", \"parameterId\": \"sideLength\" } ], \"featureId\": \"{fid}\", \"nodeId\": \"{nid2}, \"featureType\": \"cube\", \"returnAfterSubfeatures\": false, \"subFeatures\": [], \"namespace\": \"\" }, \"serializationVersion\": \"1.2.4\", \"sourceMicroversion\": \"{mid}\", \"microversionSkew\": false, \"rejectMicroversionSkew\": false, \"libraryVersion\": 0 } Open your document and confirm that the cube has a side length of 2 inches. Delete a feature Create a new document and add a cube feature to it. See Create a cube feature for instructions. Make a note of the following: Document ID Workspace ID Element ID (for the element containing the cube feature) Call the getPartStudioFeatures endpoint on the document to get the featureId of the cube feature. See Get the Feature list for instructions. Create and execute the PartStudio/deletePartStudioFeature call. Replace the URL parameters with the values from your document, and replace CREDENTIALS with your authorization credentials. curl -X 'DELETE' \\ 'https://cad.onshape.com/api/v8/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Confirm that the cube feature has been removed from your document. ","categories":"","description":"","excerpt":"This page describes the APIs Onshape provides for creating and ‚Ä¶","ref":"/docs/api-adv/featureaccess/","tags":"","title":"Features"},{"body":"This page describes the APIs Onshape provides for importing files to Onshape and exporting files from Onshape into different formats. We refer to the process of importing and exporting files from one format to another as translating the files.\nOnshape provides several APIs to support this format translation. These fall into three categories:\nSynchronous exports - Export Onshape content to glTF, STL, or Parasolid format. Asynchronous exports - Export Onshape content into a variety of other formats. Import to Onshape - Import a translatable file by uploading it to an Onshape blob element. üìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {eid}, {pid}, {otherId}. These represent document, workspace, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com Synchronous exports Onshape provides a simple way to export content to common formats (glTF, Parasolid, and STL). Most of the interfaces defined here operate by requesting an HTTP redirect to a different URL where the request is fulfilled. Applications must explicitly handle the redirect and attachment authentication headers to the follow-up request, or it will fail.\nThe following endpoints are available. We‚Äôve included an example curl with each one.\nExport Part to glTF curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/parts/d/{did}/w/{wid}/e/{eid}/partid/{partid}/gltf?rollbackBarIndex=-1\u0026outputSeparateFaceNodes=false\u0026outputFaceAppearances=false' \\ -H 'accept: model/gltf-binary;qs=0.08' \\ Export Part to Parasolid curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/parts/d/{did}/w/{wid}?elementId={eid}\u0026withThumbnails=false\u0026includePropertyDefaults=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' Export Part to STL curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/parts/d/{did}/w/{wid}/e/{eid}/partid/{partid}/stl?mode=text\u0026grouping=true\u0026scale=1\u0026units=inch' \\ -H 'accept: application/octet-stream' Export PartStudio to glTF curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/partstudios/d/{did}/w/{wid}/e/{eid}/gltf?rollbackBarIndex=-1\u0026outputSeparateFaceNodes=false\u0026outputFaceAppearances=false' \\ -H 'accept: model/gltf-binary;qs=0.08' Export PartStudio to Parasolid curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/partstudios/d/{did}/w/{wid}/e/{eid}/parasolid?version=0\u0026includeExportIds=false\u0026binaryExport=false' \\ -H 'accept: */*' Export PartStudio to STL curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/partstudios/d/{did}/w/{wid}/e/{eid}/stl?mode=text\u0026grouping=true\u0026scale=1\u0026units=inch' \\ -H 'accept: */*' Export Document to JSON curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/documents/d/{did}/w/{wid}/e/{eid}/export' \\ -H 'accept: application/octet-stream' \\ Asynchronous exports The exports in the last section perform the format translation synchronously, returning the output immediately after some processing delay. Other format conversions are more complex and time-consuming, and in many cases, cannot be completed quickly enough to prevent connection errors. Note that the source format for an export is currently always automatically detected by Onshape. Part Studios and Assemblies are known to be ONSHAPE format. File uploads have their type determined by the filename suffix. For example, a file named part7.step is assumed to be in STEP format.\nThe following asynchronous translation APIs are available:\nBlobElement/createBlobTranslation: Export a Blob Element to the specified formatName. PartStudios/createPartStudioTranslation: Export a Part Studio to the specified formatName. Assembly/translateFormat: Export an Assembly to the specified formatName. Drawing/createDrawingTranslation: Export a Drawing to the specified formatName. These asynchronous exports include a few additional steps, which are explained in more detail in the next section:\nSee what formats are available for exporting your content with Translation/getAllTranslatorFormats. Note: Parts with mesh data cannot be exported to ACIS, IGES, or OBJ format. Call the desired translation API. Specify the target formatName in the request body JSON. Specify storeInDocument=false (default) to export the content to new file. Specify storeInDocument=true to export the content to a blob element in the source document. Poll the requestState in the translation response and wait for a result of DONE. To retrieve the exported results: External files: call Document/downloadExternalData on the resultExternalDataIds from the translation response. Blob elements: call BlobElement/downloadFileWorkspace on the resultElementIds from the translation response. Async export details To export your Onshape content to another format:\nDetermine what export format file types are available for your content by calling: Translations/getAllTranslatorFormats. Note that Drawings have their own API for this call: Drawing/getDrawingTranslatorFormats Next, initiate the export by calling one of the asynchronous translation APIs. Note that each of these APIs takes a JSON for specifying options for the export as part of the request body. Refer to the API Explorer page for help viewing these JSON docs. The target file format must be specified in the formatName field in the request body, and must match a valid format found in Step 1. By default, storeInDocument is set to false in the request body to export to a single data file (or a zip of multiple files). Set to true to export as blob elements. Wait for the translation to complete. You can either register a webhook and wait to receive a notifcation that the translation is complete (see Webhook Notifications), or you can poll the translation‚Äôs requestState: You can poll the requestState from the initial translation‚Äôs response, or you can call Translation/getTranslation on the translationId from the initial translation‚Äôs response. When a translation is complete, requestState will change from ACTIVE to either DONE or FAILED. When requestState=DONE, results are available to be used. Retrieve the exported results: If you exported to an external file, call Documents/downloadExternalData to retrieve the exported result. Note that this API takes the source document ID and a ‚Äúforeign ID‚Äù as required parameters. Use the resultExternalDataIds from the translation response as the foreign ID (fid). External data is associated with, but external to, the document used as translation context. This data is not versioned like with in-document data. If your translation request body specified storeInDocument=true, retrieve the blob element data with BlobElement/downloadFileWorkspace. The element IDs for the new blob elements can be found in the resultElementIds field in the translation response. Imports Files can be imported to Onshape as blob elements. When uploading a file to a blob element, either as a new element or an update to an existing element, if the file is a recognized format for import, it will be translated into ONSHAPE format by default. This behavior can be overridden by the application, if desired.\nTranslation/createTranslation curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/translations/d/{did}/w/{wid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: multipart/form-data' \\ -F 'storeInDocument=true' \\ -F 'flattenAssemblies=true -F 'file=@/path/filename.ext' -F 'formatName=' \\ ... BlobElement/uploadFileCreateElement curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/blobelements/d/{did}/w/{wid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: multipart/form-data' \\ -F 'storeInDocument=true' \\ -F 'file=@/path/filename.ext' -F 'formatName=' \\ ... BlobElement/uploadFileUpdateElement curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/blobelements/d/{did}/w/{wid}/e/{eid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: multipart/form-data' \\ -F 'storeInDocument=true' \\ -F 'locationElementId=' \\ -F 'file=@/path/filename.ext' ... Note that these endpoints require you to specify the target document ID and workspace ID. You must also include the file to import. These APIs also includes a request body JSON for specifying options for the import.\nOverride the translation to ONSHAPE format by specifying a valid format in the formatName field. Get a list of valid import formats by calling Translation/getAllTranslatorFormats. Specify storeInDocument=true to import the data as a blob element into the target document. Change to false to only create an external data file. If the source file contains an assembly and flattenAssemblies=true, the assembly structure is removed and a single part studio is created. Note that when using cURL, you must begin the path to the file with an @ symbol. Sample Workflows Export a PartStudio to STL We will export the CRANK PartStudio from this public document to an STL file.\nCall the Part Studios/exportPartStudioStl endpoint on the document: curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/partstudios/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22/stl?mode=text\u0026grouping=true\u0026scale=1\u0026units=inch' \\ -H 'accept: */*' Navigate to the request URL to download the resulting STL file: https://cad.onshape.com/api/v6/partstudios/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22/stl?mode=text\u0026grouping=true\u0026scale=1\u0026units=inch Open the CRANK.stl file from wherever your downloads are saved. Export a Part to Parasolid We will export the FLYWHEEL part from this public document to an STL file.\nCall the Part/getPartsWMV endpoint on your document and get all the part IDs: curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/parts/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62?elementId=6bed6b43463f6a46a37b4a22\u0026withThumbnails=false\u0026includePropertyDefaults=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Locate the part to export (hint: look for name = yourPartName) in the response body. Get the part ID from the partId field. In the example below, partId = JiD for name=FLYWHEEL: [ ... { \"name\" : \"FLYWHEEL\", \"state\" : \"IN_PROGRESS\", \"propertySourceTypes\" : { \"57f3fb8efa3416c06701d60f\" : 3, \"57f3fb8efa3416c06701d60d\" : 3, \"57f3fb8efa3416c06701d61e\" : 3, \"57f3fb8efa3416c06701d60e\" : 3, \"57f3fb8efa3416c06701d60c\" : 3 }, \"defaultColorHash\" : \"FzHLKqGeuTBFjmY_2_0\", \"ordinal\" : 1, \"isMesh\" : false, \"description\" : \"Flywheel\", \"microversionId\" : \"bdb504d2d4c948493a87ccf3\", \"partNumber\" : \"PRT-10241\", \"elementId\" : \"6bed6b43463f6a46a37b4a22\", \"partId\" : \"JiD\", \"bodyType\" : \"solid\", \"customProperties\" : { \"57f3fb8efa3416c06701d61e\" : \"false\" } ... ] Call the Part/exportPS endpoint on the FLYWHEEL part: curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/parts/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22/partid/JiD/parasolid?version=0' \\ -H 'accept: application/octet-stream' \\ -H 'Authorization: Basic CREDENTIALS' Navigate to the request URL to download the resulting file: https://cad.onshape.com/api/v6/parts/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22/partid/JiD/parasolid?version=0 Open the CRANK.x_t file from your downloads. Note that the file is automatically named after the PartStudio to which the part belongs. Export a PartStudio to SOLIDWORKS We will export the CRANK PartStudio from this public document to a SOLIDWORKS file.\nValidate that SOLIDWORKS is a supported export file type by calling Translation/getAllTranslatorFormats and confirming that validDestinationFormat=true for translatorName=SOLIDWORKS. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/translations/translationformats' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ [ { \"validSourceFormat\": true, \"validDestinationFormat\": true, \"name\": \"SOLIDWORKS\", \"translatorName\": \"solidworks\", \"couldBeAssembly\": true } ] Initialize the export by calling PartStudio/createPartStudioTranslation. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/partstudios/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22/translations' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"formatName\": \"SOLIDWORKS\", \"storeInDocument\": false, \"translate\": true }' Note that the API takes a JSON as part of the request body, in which you can specify options for the export. In this example, we‚Äôve just shown a snippet of the entire JSON. A formatName string must be specified that matches one of the valid formats you found in the last step. In this example, we set formatName to SOLIDWORKS. We want to export this to a new file, so we‚Äôll leave storeInDocument set to false. Next, we poll the PartStudio/createPartStudioTranslation response until requestState changes from ACTIVE to DONE or FAILED. { \"documentId\": \"e60c4803eaf2ac8be492c18e\", \"requestElementId\": \"6bed6b43463f6a46a37b4a22\", \"requestState\": \"DONE\", \"resultExternalDataIds\": \"[{resultId}]\", ... } Once requestState=DONE, we can call Documents/downloadExternalData to retrieve the exported result. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/documents/d/e60c4803eaf2ac8be492c18e/externaldata/{fid}' Use the resultExternalDataIds value from the translation response as the foreign ID (fid). The new SOLIDWORKS file is returned as the response and will be downloaded to wherever the API call is made. Export an Assembly to STEP In this example, we‚Äôll export an assembly from this public document to a STEP file.\nMake a copy of this public document so you can export the assembly. Make a note of the documentId, workspaceId, and elementId of the assembly in your new document. Validate that STEP is a supported export file type for assemblies by calling Translation/getAllTranslatorFormats and confirming that validDestinationFormat=true and couldBeAssembly=true for translatorName=STEP. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/translations/translationformats' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ [ { \"validSourceFormat\": true, \"validDestinationFormat\": true, \"name\": \"STEP\", \"translatorName\": \"step\", \"couldBeAssembly\": true }, ... ] Initialize the export by calling Assembly/translateFormat. Replace {did}, {wid}, and {eid} with the document, workspace, and element IDs from your copied document. Do NOT include the curly braces ({}) in the final call. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/assemblies/d/{did}/w/{wid}/e/{eid}/translations' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"allowFaultyParts\": true, \"angularTolerance\": 0.001, \"formatName\": \"STEP\", \"storeInDocument\": true }' Note that the API takes a JSON as part of the request body, in which you can specify options for the export. In the example above, we‚Äôve just shown a snippet of the entire JSON where we allow faulty parts to be exported and set the angular tolerance to 0.001. A formatName string must be specified that matches one of the valid formats you found in the last step. In this example, we set formatName to STEP. Set storeInDocument to true to upload the STEP file as a blob element in your document. Next, we poll the Assembly/translateFormat response until requestState changes from ACTIVE to DONE or FAILED. { \"resultDocumentId\" : \"{did}\", \"resultWorkspaceId\" : \"{wid}\", \"requestState\" : \"DONE\", \"requestElementId\" : \"{eid}\", \"resultExternalDataIds\" : [ \"{resultExternalId}\" ], \"documentId\" : \"{did}\", \"workspaceId\" : \"{wid}\", \"resultElementIds\" : {resulteid}, \"name\" : \"GEARBOX_CHUCK\", \"id\" : \"{translationId}\", \"href\" : \"https://cad.onshape.com/api/v6/translations/{translationId}\" } Once requestState=DONE, we make a note of the resultElementId in the response. This is the elementId of the STEP blob. Now, we can call BlobElement/downloadFileWorkspace to retrieve the exported results. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/blobelements/d/{did}/w/{wid}/e/{resulteid}' \\ -H 'accept: application/octet-stream' \\ -H 'Authorization: Basic CREDENTIALS' \\ Use the resultElementIds value from the translation response as the element ID ({resulteid}). Note that you can also open your document, click the GEARBOX_CHUCK.STEP tab, and download the file from there. Export a Drawing as a JSON In this example, we‚Äôll export a Drawing from this public document to a JSON file. Exporting a Drawing to JSON is useful when you need to gather information about that drawing (for example, finding valid coordinates on which to place an inspection symbol).\nMake a copy of this public document so you can export the assembly. Make a note of the documentId, workspaceId, and elementId of the assembly in your new document. Validate that JSON is a supported export file type for Drawings by calling Drawing/getDrawingTranslatorFormats and confirming that \"name\": \"DRAWING_JSON\" appears in the response for the drawing element in your copied document. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/translationformats' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ [ { \"name\": \"DRAWING_JSON\", \"translatorName\": \"drawing_json\", \"couldBeAssembly\": false }, ... ] Initialize the export by calling Drawing/createDrawingTranslation. Replace {did}, {wid}, and {eid} with the document, workspace, and element IDs from your copied document. Do NOT include the curly braces ({}) in the final call. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/drawings/d/{did}/w/{wid}/e/{eid}/translations' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"formatName\": \"DRAWING_JSON\" }' Note that the API takes a JSON as part of the request body, in which you can specify options for the export. The only required JSON field is formatName, in which we‚Äôve specified the format as found in the getDrawingTranslatorFormats response body. Next, we poll the Drawing/createDrawingTranslation response until requestState changes from ACTIVE to DONE or FAILED. { \"resultDocumentId\" : \"{did}\", \"resultWorkspaceId\" : \"{wid}\", \"requestState\" : \"DONE\", \"requestElementId\" : \"{eid}\", \"resultExternalDataIds\" : [ \"{resultExternalId}\" ], \"documentId\" : \"{did}\", \"workspaceId\" : \"{wid}\", \"resultElementIds\" : {eid}, \"name\" : \"GEARBOX_CHUCK\", \"id\" : \"{translationId}\", \"href\" : \"https://cad.onshape.com/api/v6/translations/{translationId}\" } Once requestState=DONE, we make a note of the \"resultElementIds\" : {resulteid}, in the response. This is the element ID of the JSON blob. Now, we can call BlobElement/downloadFileWorkspace to retrieve the exported results. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/blobelements/d/{did}/w/{wid}/e/{resulteid}' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'accept: application/octet-stream' Use the {resultExternalId} value from the translation response as the element ID ({resulteid}). Do not include the curly braces in your call. Note that you can also open your document, click the GEARBOX_CHUCK.JSON tab, and download the file from there. Import a Parasolid file as a Part In this example, we‚Äôll import the FLYWHEEL part from the CRANK.x_t file we created in the Export a Part to Parasolid example.\nOpen or create a new Onshape document in which to import the Part. Make a note of the documentId and workspaceId of your document. Validate that Parasolid is a supported export file type for imports by calling Translation/getAllTranslatorFormats and confirming that validSourceFormat=true for translatorName=parasolid. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/translations/translationformats' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' [ { \"validSourceFormat\": true, \"validDestinationFormat\": true, \"name\": \"PARASOLID\", \"translatorName\": \"parasolid\", \"couldBeAssembly\": true } ]s Initialize the import by calling Translation/createTranslation. In this example, the filename is CRANK.x_t. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/translations/d/{did}/w/{wid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09's \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: multipart/form-data' \\ -F 'formatName=' \\ -F 'flattenAssemblies=true' \\ -F 'translate=true' \\ -F 'file=@/pathToFile/CRANK.x_t' \\ Replace {did} and {wid} in the URL with the document and workspace IDs for the document you want to import the part to. Note that when using cURL, you must begin the path to the file with an @ symbol. Note that the API takes a JSON as part of the request body, in which you can specify options for the import. When importing files, the API assumes we are importing to the ONSHAPE file type. You can override this and import to a different file type using the formatName field. In this case, we can leave the formatName field blank to import to the ONSHAPE file type. Next, we poll the Translation/getDocumentTranslations response until requestState changes from ACTIVE to DONE or FAILED. { \"requestState\" : \"DONE\", \"documentId\" : \"{did}\", \"workspaceId\" : \"{wid}\", \"resultElementIds\" : [ \"{resulteid}\" ], \"name\" : \"FLYWHEEL\", \"id\" : \"{id}\", \"href\" : \"https://cad.onshape.com/api/v1/translations/{tid}\" } Once requestState=DONE, we can view the imported file as a Part in our Onshape document. The FLYWHEEL part appears in a new PartStudio named CRANK in our document. Export a configured part See the Configurations API Guide for examples.\nAdditional Resources Onshape Help: Translation Onshape Help: Webhooks API Guide: Webhook Notifications API Explorer ","categories":"","description":"","excerpt":"This page describes the APIs Onshape provides for importing files to ‚Ä¶","ref":"/docs/api-adv/translation/","tags":"","title":"Import \u0026 Export"},{"body":"This page describes the APIs Onshape provides for working with document metadata.\nüìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {eid}, {pid}, {otherId}. These represent document, workspace, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com Endpoints Get Metadata getWVMetadata: Get metadata for a workspace or version. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}?inferMetadataOwner=false\u0026depth=1\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' getWMVEsMetadata: Get metadata for all elements in a document. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e?inferMetadataOwner=false\u0026depth=1\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' getWMVEMetadata: Get metadata for an element. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e/{eid}?inferMetadataOwner=false\u0026depth=1\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' getWMVEPMetadata: Get metadata for a part. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e/{eid}/p/{pid}?rollbackBarIndex=-1\u0026inferMetadataOwner=false\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' getWMVEPsMetadata: Get metadata for all parts in a document. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e/{eid}/p?inferMetadataOwner=false\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS'\\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' getVEOPStandardContentMetadata: Get metadata for a standard content part. {linkedDocumentId}: ID of the document into which the standard content part is inserted. You can call getAssemblyDefinition to get the other values needed for the call: {did}: ID of the document in which the standard content part lives. {vid}: ID of the version in which the standard content part lives. {eid}: ID of the element tab in which the standard content part lives. {pid}: Part ID of the standard content part. {config}: Encoded configuration string. curl -X 'GET' \\ 'https://cad.onshape.com/api/metadata/standardcontent/d/{did}/v/{vid}/e/{eid}/p/{pid}?configuration={config}\u0026linkDocumentId={linkDocument}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' Update Metadata To update metadata, you send a JSON in the API request body. This JSON block must include a jsonType value and a properties object array. Each object in the properties array includes a propertyId and the metadata key/value pairs.\nupdateWVMetadata: Update workspace or version metadata. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"jsonType\": (\"metadata-workspace\" | \"metadata-version\") , \"properties\": [ { \"propertyId\": \"propertyId1\", \"key1\": \"value\", \"key2\": \"value }, { \"propertyId\": \"propertyId2\", \"key1\": \"value\", \"key2\": \"value } ] }' updateWVEMetadata: Update element metadata. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e/{eid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"jsonType\": \"metadata-element\", \"properties\": [ { \"propertyId\": \"propertyId\", \"key1\": \"value\", \"key2\": \"value } ] }' updateWVEPMetadata: Update part metadata curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/wv/{wvid}/e/{eid}/{iden}/{pid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"jsonType\": \"metadata-part\", \"properties\": [ { \"propertyId\": \"propertyId\", \"key1\": \"value\", \"key2\": \"value } ] }' updateVEOPStandardContentPartMetadata: Update standard content part metadata. {linkedDocumentId}: ID of the document into which the standard content part is inserted. You can call getAssemblyDefinition to get the other values needed for the call: {did}, {vid}, {eid}: IDs of the document, version, and element in which the standard content part lives. {companyId}: ID of the company that owns the standard content part. All metadata changes to this standard content part will populate for the entire company. {pid}: Part ID of the standard content part. {config}: Encoded configuration string. For each items.properties object, include a unique propertyId and at least one key/value metadata pair. Updates made to standard content are global for all users and documents within the company. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/standardcontent/d/{did}?linkDocumentId={linkDocumentId}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"items\": [ { \"href\": \"https://cad.onshape.com/api/metadata/standardcontent/d/did/v/vid/e/eid/c/companyId/p/pid?configuration=config\u0026linkDocumentId=linkDocumentId\u0026applyToAllConfigs=true\", \"properties\": [ { \"key\": \"value\", \"propertyId\": \"propertyId1\" }, { \"key\": \"value\", \"propertyId\": \"propertyId2\" } ] } ] }' Sample Workflows Get a part property In this example we‚Äôll get the name of a part by getting the metadata from the DRILL_BIT element in this public document.\nCall the Metadata/getWMVEMetadata endpoint. Replace CREDENTIALS with your authentication credentials: curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/958bceb5a2511b572dbbe851?inferMetadataOwner=false\u0026depth=1\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' In the response body, confirm that for properties.name=Name, properties.value=DRILL_BIT. { \"jsonType\": \"metadata-element\", \"elementType\": 0, \"mimeType\": \"onshape/partstudio\", \"elementId\": \"958bceb5a2511b572dbbe851\", \"properties\": [ { \"name\": \"Name\", \"value\": \"DRILL_BIT\", \"defaultValue\": null, \"computedPropertyError\": null, \"propertySource\": 0, ... Update a part property In this example we will update a part‚Äôs description by getting the current metadata for the part, and then posting an update to that metadata.\nGet your document information:\nMake a copy of this public document. Make a note of the new document‚Äôs document ID, workspace ID, and element ID.\nGet the ID of the part to update:\nCall the Part/getPartsWMVE API on your copied document to get a list of part IDs in the element. Only one part exists in the document, with a part ID of JHD.\n{ \"name\": \"Main\", ... \"microversionId\": \"{mid}\", \"partNumber\": null, \"elementId\": \"{eid}\", \"partId\": \"JHD\", \"bodyType\": \"sheet\", ... } Get the metadata of the part:\nWe‚Äôll call the Metadata/getWMVEPMetadata endpoint to get the current metadata JSON for the part. Don‚Äôt forget to replace the URL parameters with the IDs from your copied document, and replace CREDENTIALS with your authorization credentials.\ncurl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}/p/JHD?rollbackBarIndex=-1\u0026inferMetadataOwner=false\u0026includeComputedProperties=true\u0026includeComputedAssemblyProperties=false\u0026thumbnail=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' Locate the property to update in the response:\nThe call returns a response body in JSON format. Scroll to the Description properties block of the JSON response, and notice that the value field is an empty string.\n... { \"name\": \"Description\", \"value\": \"\", \"defaultValue\": null, \"computedPropertyError\": null, \"propertySource\": 3, \"validator\": { }, \"required\": false, \"editable\": true, \"propertyId\": \"{propertyId}\", \"editableInUi\": true, \"dateFormat\": null, \"valueType\": \"STRING\", \"enumValues\": null, \"multivalued\": false, \"computedAssemblyProperty\": false, \"computedProperty\": false, \"propertyOverrideStatus\": 0 }, ... Find the metadata‚Äôs property ID:\nCopy Description‚Äôs propertyId. We‚Äôll need this ID to update the metadata.\nSet up the Metadata/updateWVEPMetadata call:\ncurl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}/p/JHD?rollbackBarIndex=-1' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add the request JSON to the call:\nNote that we need to include the jsonType, the partId, the propertyId, and the value to update.\n-d '{ \"jsonType\": \"metadata-part\", \"partId\": \"JHD\", \"properties\": [ { \"value\": \"\", \"propertyId\": \"{propertyId}\" } ] }' Add the new property information:\nIn the request JSON, change the empty Description value string to \"Drill bit\":\n-d '{ \"jsonType\": \"metadata-part\", \"partId\": \"JHD\", \"properties\": [ { \"value\": \"Drill bit\", \"propertyId\": \"{propertyId}\" } ] }' POST the new metadata:\nDon‚Äôt forget to replace the URL parameters and CREDENTIALS with your information.\ncurl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}/p/JHD?rollbackBarIndex=-1' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"jsonType\": \"metadata-part\", \"partId\": \"JHD\", \"properties\": [ { \"value\": \"Drill bit\", \"propertyId\": \"{propertyId}\" } ] }' Confirm your changes:\nRepeat steps 3 and 4 to confirm that the Description value for the part is now Drill bit.\nUpdate a tab name In this example we will update an element‚Äôs tab name by getting the current metadata for the element, and then posting an update to that metadata. Remember that in Onshape, an element is typically represented as a tab in the Onshape UI.\nGet your document information:\nMake a copy of this public document. Make a note of the new document‚Äôs document ID, workspace ID, and element ID. Note the tab name of the element is ‚ÄúNEW_PART‚Äù.\nGet the metadata of the element:\nWe‚Äôll call the Metadata/getWMVEMetadata endpoint to get the current metadata JSON for the element. Don‚Äôt forget to replace the URL parameters with the IDs from your copied document, and replace CREDENTIALS with your authorization credentials.\ncurl -X 'GET' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' Locate the property to update in the response:\nThe call returns a response body in JSON format. Scroll to the Name properties block of the JSON response, and notice that the value field matches our current tab name, ‚ÄúNEW_PART‚Äù.\n{ \"jsonType\": \"metadata-element\", \"elementType\": 0, \"mimeType\": \"onshape/partstudio\", \"elementId\": \"{eid}\", \"properties\": [ { \"name\": \"Name\", \"value\": \"NEW_PART\", \"validator\": {}, \"required\": true, \"editable\": true, \"propertyId\": \"{propertyId}\", }, ... ], ... } Find the metadata‚Äôs property ID:\nCopy the Name block‚Äôs propertyId in the response. We‚Äôll need this ID to update the metadata.\nSet up the updateWVEMetadata call:\ncurl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ Add the request JSON to the call:\nNote that we need to include the propertyId and the value to update.\n-d '{ \"properties\": [ { \"value\": \"\", \"propertyId\": \"{propertyId}\" } ] }' Add the new property information:\nIn the request JSON, replace {propertyId} with the property ID you found in Step 4, then change the empty value string to \"PISTON\":\n-d '{ \"properties\": [ { \"value\": \"PISTON\", \"propertyId\": \"{propertyId}\" } ] }' POST the new metadata:\nDon‚Äôt forget to replace the URL parameters and CREDENTIALS with your information.\ncurl -X 'POST' \\ 'https://cad.onshape.com/api/v6/metadata/d/{did}/w/{wid}/e/{eid}' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"properties\": [ { \"value\": \"PISTON\", \"propertyId\": \"{propertyId}\" } ] }' Confirm your changes:\nOpen your document and confirm that the tab name is now PISTON.\nAdditional Resources API Explorer: Metadata API Guide: API Explorer ","categories":"","description":"","excerpt":"This page describes the APIs Onshape provides for working with ‚Ä¶","ref":"/docs/api-adv/metadata/","tags":"","title":"Metadata"},{"body":"This page details some of the response codes that may be returned by Onshape API endpoints. For each response code, we‚Äôve provided a brief description of the response and recommended next steps.\nSuccess (2xx) The client call was successful.\n200 - OK The client call was successful. No action needed.\n204 - No Content The client call was successful, and there‚Äôs nothing to return in the response body. The empty response body cannot be parsed.\nRedirect (3xx) 307 - Temporary Redirect The client call was successful, and a redirection URL was returned. Follow the URL provided in the response.\nClient Error (4xx) There‚Äôs an error with the client request. Find the error code below, and follow the instructions for resolution.\n400 - Bad Request The request cannot be processed by the server due a client-side error. This could be a malformed request syntax or other issue. Check the request parameters (GET and POST) and request body (POST) to determine the cause of the failure.\n401 - Unauthorized The request failed the authentication/authorization checks. This could mean that the client is not logged in, API keys are invalid, OAuth failed, etc. Make sure the client is authenticated.\n403 - Forbidden The client doesn‚Äôt have the correct permissions to perform this operation. Check that the API Keys or OAuth authentication have sufficient permissions to perform the operation. For example, POST operations typically require write scope; if the API Key was created with only read scope, the server will return a 403 error.\nYou might also need to check document and user permissions. For more details, see Share Documents (for everyone) and Understanding and Administering Project Roles and Permission Schemes (for Enterprise users and administrators).\n404 - Not Found The server can‚Äôt find what the client is looking for. For example, a 404 error will be returned if the client tries to make a GET request for a document that doesn‚Äôt exist.\n405 - Method Not Allowed Use of that method is not supported. For example, you cannot perform a DELETE request on a document version, because versions are read-only. Only GET requests on document versions are allowed.\n406 - Not Acceptable The server cannot provide a response for the media type requested. See https://datatracker.ietf.org/doc/html/rfc2616#section-6.1.1.\n409 - Conflict The client call includes duplicate values, causing a conflict. Modify the request to remove any conflicting values.\n415 - Media Type Not Supported The client call includes unsupported data types or invalid JSON. Review the client code. When performing data imports and exports, follow all Translation guidelines to ensure all media and file types are supported.\n429 - Too Many Requests The client sent too many requests to a particular endpoint in a given time window. The number of requests allowed per time window vary and are subject to change. Onshape does not publish this information. If the client receives HTTP 429 responses, delay and then retry, or reduce its request rate.\n499 - Timeout This call is taking too long. Please try again later.\nServer Error (5xx) There‚Äôs an error with the Onshape servers. Find the error code below, and follow the instructions for resolution.\n500 - Internal Server Error The request resulted in an error. Set a limit for the number of retries, and if the request continues to fail, reach out to support.\n503 - Service Unavailable Something is wrong with the Onshape servers. Retry after the delay specified in the response. Set a limit for the number of retries, and if the request continues to fail, reach out to support.\n","categories":"","description":"","excerpt":"This page details some of the response codes that may be returned by ‚Ä¶","ref":"/docs/api-adv/errors/","tags":"","title":"Response Codes"},{"body":"The primary APIs provided by Onshape are REST interfaces that can be accessed over HTTPS. The client can be a web server or a desktop application (including command line tools, such as curl). Onshape does not support use of the APIs directly from a browser client due to cross-domain scripting concerns.\nPartner applications typically interact with Onshape in three ways:\nFile Exchange: Onshape provides extensive import and export translation capabilities to interact with applications that can read or write a variety of file formats. Live Link Integration: Desktop or server applications can use REST calls to read information from the Onshape servers and store information back. These applications can gain ‚Äúcloud value‚Äù by using Onshape data management capabilities for sharing, versioning, and durability. In-Tab Integration: Web server applications can create a tightly integrated experience within Onshape by using a combination of REST and client-side APIs to build a seamless interaction by interacting with users inside an Onshape tab. The following diagram illustrates basic desktop integration and cloud integration architecture:\nThe Onshape Server Stack consists of several cooperating servers that provide the underlying support for the Onshape CAD experience. The Onshape servers are built with a variety of technologies, including Java and C++, database and message services, geometry and constraint management systems, and much more.\nPartner cloud applications can be written in any web framework. Onshape provides a set of sample apps in Github, as well as text tutorials.\nYou may notice that the above diagram does not illustrate the Onshape mobile clients for iOS and Android devices; the development of 3rd-party mobile applications for Onshape is beyond the scope of this document.\nIntegration Considerations There is much to Onshape that is different from traditional CAD and PDM systems. For system integrators who have previous experience with these types of systems, the instinct is to try and apply the concepts developed for those integrations to an Onshape integration. This is a mistake. Applying existing integration concepts to Onshape simply won‚Äôt work.\nKey Onshape integration considerations include:\nDo not limit the capabilities of the software: When applying integration practices of legacy file-based solutions to Onshape, you must adjust the way designers work in Onshape to accommodate the limitations of your integration. Instead, the integration should follow best practices and methodologies that can be applied to modern SaaS-based solutions. Enable designers the freedom to work without constraints: Designers working in a CAD system should never be restricted in their ability to use the software features to the fullest. The software is designed to provide its users with the freedom to innovate and the flexibility to adjust to how a designer wants to work. Utilize the best in class features from each solution: Different software solutions are designed to provide features that should provide expected functionality for whatever function the software was designed to do. For instance, a CAD system should have best-in-class tools for modeling, whereas data management tools should provide capabilities to manage, analyze and report on data. While there might be overlap between systems, it is best practice to let each software solution do exactly what it was designed to do, instead of forcing one to perform the functions of the other. Map out your business processes: Decide which software solution is responsible for which part of the process. It will be impossible to develop a successful integration if the requirements aren‚Äôt clearly stated. The business process(es) that you manage through the integration should be mapped out, along with the systems involved and which system is responsible for which function. Use standards and Published APIs: Developers hate when thousands of lines of code and days of work are thrown away because of an upgrade of a piece of software. By using industry standards and published APIs, you will protect yourself from such a disaster. Create an Application To create an application that interacts with Onshape:\nFollow the steps on the OAuth page to register your application in the Onshape Developer Portal and set up authentication. Onshape uses industry standards for establishing a secure connection between itself and a third-party application. To access Onshape‚Äôs resources, any application requesting those resources must be authenticated by Onshape. Likewise, if Onshape needs to access resources from a third-party application, Onshape must be correctly authenticated by the third party prior to access being granted. Use the Onshape APIs to create your application. Review the other pages in the App Development section of the Developer Documentation for information on app development best practices and methodologies. Follow the steps on the Onshape App Store page to submit your application to the Onshape App Store. Resources The Developer Portal is your place to create and administer applications: https://dev-portal.onshape.com/ Find Onshape documentation at: https://cad.onshape.com/help/Content (or at https://\u003ccompanyName\u003e.onshape.com/help/Content for Enterprise accounts.) Find developer documentation on this site. We specifically recommend reviewing the following sections: Introduction to the Onshape REST API Onshape App Development Onshape App Store Find sample apps: https://github.com/onshape-public Speak to other developers in the forum: https://forum.onshape.com/categories/developer-community ","categories":"","description":"","excerpt":"The primary APIs provided by Onshape are REST interfaces that can be ‚Ä¶","ref":"/docs/app-dev/","tags":"","title":"App Development"},{"body":"This page provides information for some of the more common options for embedding a third-party application into the Onshape interface. Onshape provides many options for embedding commands in various menus, fly-out panels, and elements. In this example, you will embed a custom web page inside a document‚Äôs right side fly-out panel. This interface will receive information from Onshape and push information from the panel back to Onshape, providing a complete, bi-directional integration scenario.\nPlease see also:\nCreate an Extension tutorial: A step-by-step walkthrough of creating an extension. Create an Extension Video Sample: Extension Types We can classify extensions into two high-level types. The first type embeds a UI from the application into the Onshape UI. The embedded UI is an HTTPS page displayed in an iFrame in the Onshape UI. The UI is served from the application, and can choose to make API calls to Onshape for additional information. This is exactly like the traditional tab-based applications in Onshape, except that such extensions exist at different UI locations.\nThe second type of extension embeds an action that calls a REST API exposed by the application from the Onshape UI (e.g., context menu actions and toolbar actions). These types of extensions rely on External OAuth information to authenticate and make a call where Onshape acts as a client, and the application acts as a server.\nExtension Attributes Each extension exists at a specific place in the Onshape UI and works with a specific context or selection. The attributes of an extension are:\nName: This should be short and explicit. It will appear in the Onshape UI as a menu item, a toolbar tooltip, a collapsed panel icon tooltip, or a panel icon. It might be truncated in the UI if it is too long. Description: This is where the developer can record a detailed description of the extension. It does not appear in the Onshape UI, but could appear in the grant process. Location: This describes where the extension exists in the Onshape UI. Over time, this will cover various panels in the UI, context menus, toolbars, actions in dialogs, etc. You can see the list of currently supported locations here. Please note that you can create only one element tab extension per application. Context (selection): Some locations will work in the context of a selection. Let‚Äôs say the application developer wants to show some information from a third-party system, pertinent only to parts (not assemblies or drawings). In this scenario, the developer would choose a location like ‚ÄòDocument list info panel‚Äô, and the context as ‚ÄòSelected part‚Äô. If the user searches for something in the document list, some documents, Part Studios, parts, and Assemblies would be returned. This extension will show up in the Info panel only if the selected entity is a part. Using context enables application developers to control when the extension is displayed. Check the list of contexts available for different locations here. Action URL: Locations that embed a UI use the action URL to define the address of the page to display. The action URL is used to specify the REST endpoint if the location is an action (context menu, toolbar item, action in dialog etc.) and the action type is GET or POST. If the location is an action and the action is ‚ÄòOpen in new window‚Äô, the action URL is the URL to open in the new window.\nThe action URL can be parameterized to pass information from Onshape to the application. The action URL replaces attributes in the format {$attribute} with the appropriate value. These attributes can be used to identify the selected entity and/or make calls back to Onshape via the API. The currently supported attributes are: {$documentId} - The Onshape ID for the current or selected document. {$workspaceOrVersion} - This will be either w or v for workspace or version respectively depending on current opened document state or selection. {$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version. {$workspaceId} - Use {$workspaceOrVersionId} instead. {$versionId} - Use {$workspaceOrVersionId} instead. {$microversionId} - The Onshape ID for the current or select document microversion. {tabElementId} - The Onshape ID for the current tab. {$elementId} - The Onshape ID for the current or selected element. Note: In most cases, tabElementId and elementId will be the same. However, when creating an extension with the Selected instance context, tabElementId indicates the current tab (i.e., the target element), and elementId indicates the tab from which the instance/subassembly was inserted (i.e., the source element). {$partId} - The Onshape ID for the current or selected part. {$partNumber} - The Part number property for the current or selected part, assembly or drawing. {$revision} - The Revision property for the current or selected part, assembly or drawing. {$companyId} - The ID for the company that owns the document. {$mimeType} - The mime type if the current or selected element is a blob. {$featureId} - In case of feature selected in the Feature list in a Part Studio. {$nodeId} - In case of mate or mate feature selected in the Assembly list. {$occurrencePath} - In case of part instances, mates, mate connectors and sub assemblies. {$configuration} - In case of extensions inside the document, this attribute will be replaced by current element active configuration. The attributes can exist as path parameters or query parameters or attributes in the POST body. For example:\n[https://whispering-sea-42267.herokuapp.com/oauthSignin?documentId={$documentId}\u0026workspaceOrVersion={workspaceOrVersion}\u0026workspaceOrVersionId={$workspaceOrVersionId}\u0026elementId={$elementId}\u0026partId={$partId}\u0026server=https://cad.onshape.com\u0026companyId=cad\u0026userId=5f1eba76c14a434817d9c588\u0026locale=en-US](https://whispering-sea-42267.herokuapp.com/oauthSignin?documentId=%7B$documentId%7D\u0026workspaceId=%7B$workspaceId%7D\u0026elementId=%7B$elementId%7D\u0026partId=%7B$partId) or\n[https://cad.onshape.com/api/partstudios/d/{$documentId}/{$workspaceOrVersion}/{$workspaceOrVersionId}/e/{$elementId}/stl?server=https://cad.onshape.com\u0026companyId=cad\u0026userId=5f1eba76c14a434817d9c588\u0026locale=en-US](https://cad.onshape.com/api/partstudios/d/%7B$documentId%7D/w/%7B$workspaceId%7D/e/%7B$elementId%7D/stl) The attributes available for replacement differ by location and context selection. You can see the available attributes for each location here.\nThe timeout for action_url of type GET or POST is 180 seconds.\nAction type: The action type is only applicable for locations that act as actions and not for locations that embed UIs. Check if action type is valid for a location here. The supported action types are:\nGET - This makes a GET API call using the action URL. Parameter replacement is done on the action URL. POST - This makes a POST API call using the action URL and the action body as the post body. Parameter replacement is done on both the action URL and the action body. Open in new window - This opens the action URL in a new browser window. Parameter replacement is done on the action URL. Action body: This is only applicable if the action type is POST. The action body is passed in a POST API call and must be in a valid json format.\nShow response: This is only applicable if the action type is GET or POST. If this is checked, the UI will wait for a response and show the response in a dialog in the UI. The response must be in a valid json format.\nIcon: The icon will be shown where the extension exists. This can be an icon in an Info panel, context menu action, toolbar button, action button in a dialog, or other supported locations.\nSupported Locations and Contexts This is the list of supported locations, their valid contexts, and whether they support action types.\nElement context menu This is the context menu for elements.\nSupported contexts:\nPart Studio Assembly Drawing Blob element Supported parameters for replacements:\n{$documentId} {$workspaceOrVersion} {$workspaceOrVersionId} {$workspaceId} DEPRECATED {$versionId} DEPRECATED {$elementId} {$partNumber} {$mimeType} {$configuration} Default parameters as query string:\nserver companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location supports action types.\nTree context menu This is the context menu for the part tree, assembly tree and feature tree in part studios.\nSupported contexts:\nPart Sub assembly Feature Mate Mate feature Instance Supported parameters for replacement:\n{$documentId} {$workspaceOrVersion} {$workspaceOrVersionId} {$workspaceId} DEPRECATED {$versionId} DEPRECATED {$elementId} {$partNumber} {$revision} {$featureId} {$nodeId} {$occurrencePath} {$configuration} Default parameters as query string:\nserver companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location supports action types.\nDocument list context menu This the context menu available on items in the document list. This is normally documents but can be multiple types based on search results.\nSupported contexts:\nPart Document Part Studio Assembly Drawing Blob element Supported parameters for replacement:\n{$documentId} {$workspaceOrVersion} {$workspaceOrVersionId} {$workspaceId} DEPRECATED {$versionId} DEPRECATED {$elementId} {$partNumber} {$revision} {$configuration} Default parameters as query string:\nserver companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location supports action types.\nDocument list info panel This is the Info panel to the right in the document list. The document list normally contains documents, but can contain other entities as the result of a search.\nSupported contexts:\nPart Document Part Studio Assembly Drawing Blob element Supported parameters for replacement:\n{$documentId} {$workspaceOrVersion} {$workspaceOrVersionId} {$workspaceId} DEPRECATED {$versionId} DEPRECATED {$elementId} {$partId} Default parameters as query string:\nserver companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location does NOT support action types.\nElement right panel This is the panel inside a document. It currently houses the BOM, configurations, etc. Applications can use this extension location to add items in this panel.\nSupported contexts:\nPart Document Part Studio Assembly Sub assembly Feature Mate Mate feature Supported parameters for replacement:\n{$documentId} {$workspaceOrVersion} {$workspaceOrVersionId} {$workspaceId} DEPRECATED {$versionId} DEPRECATED {$elementId} {$partNumber} {$revision} {$featureId} {$nodeId} {$occurrencePath} {$configuration} Default parameters as query string:\nserver companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location does NOT support action types.\nNew Element tab This is the menu option for + menu -\u003e Add application inside a document . After menu click, a new tab will be created with the action url associated with this extension.\nSupported contexts:\nThere are no supported contexts. Supported parameters for replacement:\nParameter replacement not supported. Default parameters as query string:\ndocumentId workspaceId versionId elementId server companyId - Default value is ‚Äòcad‚Äô. If the document owner is company/enterprise, then the value is company/enterprise ID. userId locale clientId This location supports action types.\nPart number generator This extension helps partners to embed their own custom part number generation scheme in Onshape. Each application can have only one extension of this type. Once defined, these extensions are listed as one of the part numbering schemes in the release management configuration in Company settings.\nIn the above screen shot, ‚ÄòPart number generation scheme‚Äô is the user-defined name of the extension.\nSupported contexts:\nThere are no supported contexts. Supported parameters for replacement:\nParameter replacement is not supported. Default parameters as query string:\nNo default query parameters Action URL defined by the user is assumed to be a POST API. This API should consume a predefined request body as shown below. This definition may have additional attributes in future.\n[ { \"id\" : \u003cinternal part number id\u003e, \"documentId\" : \u003cdocumentId\u003e, \"elementId\" : \u003celementId\u003e, \"workspaceId\" : \u003cworkspaceId\u003e, \"elementType\" : \u003celementType\u003e, \"partId\" : \u003cpartId\u003e, \"companyId\" : \u003ccompanyId\u003e, // Id of the company that owns the document, else the text ‚Äúcad‚Äù \"partNumber\" : \u003ccurrent part number\u003e, \"configuration\" : \u003cconfiguration string\u003e, \"categories\" : \u003carray of category ids and names\u003e // [ { \"id\": \u003cString\u003e, \"name\": \u003cstring\u003e } ] } ] Note: Categories are only passed from the Release dialog and properties dialogs for now. They are empty when part number generation is called from the BOM table or configuration table.\nExpected response sent to Onshape is as follows:\n[ { \"id\" : \u003cinternal part number id\u003e, \"documentId\" : \u003cdocumentId\u003e, \"elementId\" : \u003celementId\u003e, \"workspaceId\" : \u003cworkspaceId\u003e, \"elementType\" : \u003celementType\u003e, \"partId\" : \u003cpartId\u003e, \"partNumber\" : \u003cnext part number generated by third party numbering scheme\u003e } ] Third-party applications can simply fill the \"partNumber\" attribute with the part number generated by the custom numbering scheme and send it as a response. However, the response should at least contain \"id\" and \"partNumber\" as highlighted above; other attributes are optional.\nCustom numbering schemes for part generation, once set in the Release management page, can be invoked from all the places where we set part numbers, including the Release candidate dialog shown below:\nSample code We have provided a sample application that supports the features described in this document.\nThe source code for this Inventory management application can be found in our public GitHub repository.\nThe instructions to install and the application are available in the README.md file in the repository.\nThe application is built on the Passport node module. It is based on this article. Please read the article before proceeding with this section.\nSome structural information about the application:\nThe dependencies are defined in package.json The routing for inbound calls is defined in server.js. This includes routing for OAuth2 calls as well as calls for the rest APIs we expose that Onshape can call via the extensions. The OAuth2 calls are routed to controllers/oauth2.js. These include calls to authenticate as calls to get the bearer token. controllers/oauth2.js uses controllers/auth.js to interact with Passport to manage the authentication and storage. Other API calls to get part number, etc, route to the appropriate controller in the controllers directory. The controllers use the model defined in the model directory. The application is defined in the Developer Portal with extensions that use the exposed APIs.\nThe following screenshots define the base configuration of the application and some of the sample extensions.\n","categories":"","description":"","excerpt":"This page provides information for some of the more common options for ‚Ä¶","ref":"/docs/app-dev/extensions/","tags":"","title":"Extensions"},{"body":"Application extensions and the Onshape JavaScript web client need to communicate directly, calling across the iframe containing the application extension using post message.\nOnshape Client Messaging examples can be split into those that are initiated from the application extension and those that are initiated from the Onshape client.\nMessages from the Extension These Client Messaging examples can be initiated from the application extension:\nClick/close flyouts events: Notify the Onshape client that the user has clicked in the application extension, which should cause Onshape flyouts (versions, history, uploads, etc.) and dropdown menus (profile dropdown menu, document menu) to close. Without this, flyouts and menus might remain open over the application extension. Shortcut keyboard events: Shortcut keys (such as ?, which opens the Onshape Help dialog), can be handled by the application extension by posting a message to the Onshape client to open the dialog. keepAlive: Notify the Onshape client that the user is actively working in the application extension, which triggers the Onshape client to send a message to the server to keep the browser session alive. Without this, the Onshape browser session will timeout and ask the user to sign in again. Standard Onshape dialogs: Request from the application extension to the Onshape client to open one of the Onshape standard dialogs and send the user‚Äôs choices back to the application extension. For example, if the application extension needs the user to choose a part or assembly to be operated on, the application extension can post a message to the Onshape client requesting that dialog be opened and the selected part or assembly information sent back to the application extension. UI customization\": Request from the application extension to the Onshape client to customize the Onshape UI (e.g., add commands to menus, add buttons to the toolbars, etc). When these commands or toolbar buttons are clicked, the Onshape client posts a message to the application extension with the available context. Note: This is limited to cases where the application extension is made active by the user; application extensions are not automatically loaded when a document is opened. Most UI customizations should be done when you register the application with Onshape, as those change the Onshape client automatically without needing to load the application extension first. Content/material insertion: Request from the application extension to insert content into the Onshape document. For example, insert a part into a new or existing Part Studio, apply a material to a part, add a material to a material library, etc. Messages from Onshape The following examples can be initiated from the Onshape client:\nUser action notification: The Onshape client can notify an application extension when various user actions occur. For example, the Onshape client might notify when the user has made the application extension active or inactive (when the user clicks on document tabs). When an application extension is made inactive, it is moved off the edges of the browser, so it cannot be seen, but is still active, preserving its state. Printing: The Onshape client can notify an application extension when the user has chosen the Print command from the main Onshape document menu, enabling the application extension to perform a print operation. Security Considerations To ensure security, an application extension must:\nParse for document, workspace, and element IDs: Parse for the documentId, workspaceId, and elementId that were passed as query parameters within the application extension‚Äôs iframe src URL. You must post these back in each POST message. Parse for the server: Parse for the server that was passed as a query parameter within the application extension‚Äôs iframe src URL. You must use this to validate messages received. If the application extension uses a JavaScript library or framework (e.g., BackboneJS or AngularJS), it can parse the query parameters and maintain state in other ways. Not redirect to another base URL: The browser tells the Onshape client the origin base URL from which a POST message is received. The Onshape client ignores messages posted from an origin URL that doesn‚Äôt match the original iframe src URL. It is extremely important to the security of your application that you verify that the origin of all messages you receive is the same as the original server query parameter in the iframe src (i.e., if (server === e.origin)). In production operation especially, the message IS NOT SAFE if the message origin does not match the iframe src server query parameter. Application extensions should not redirect to another base URL after the iframe has been opened, or the messages will be ignored. Post a message on startup: Onshape will not post messages until a newly started application extension has first posted a valid message to Onshape. This constraint is in effect anytime an application extension is (re)started and exists to avoid posting messages to application extensions that are not ready to handle them, are not fully loaded, etc. After your application extension is fully loaded and ready to receive messages, post a message to Onshape. A keepAlive message is a great first message to send to Onshape. Once Onshape receives a valid message, Onshape will start posting messages to the application extension. If the application extension later sends an invalid message Onshape will stop sending messages until a valid message is posted to Onshape. POST messages submitted by application extensions to Onshape will be ignored if any of the following are true:\nThe documentId, workspaceId, or elementId are missing or not valid. The message name is missing or not recognized. The origin of the POST message does not match the original iframe src URL. Element Tab Messages may be sent and received by element tab application extensions.\nThe following messages can be sent by Element tab application extensions:\nmessageName (case sensitive) other message properties? comment applicationInit yes notifyWhenSaveRequired: whether Onshape should send a notification to save pending changes during certain operations (default is false) Send once on application startup. closeFlyoutsAndMenus no Send when a mouse click or other event happens in the application extension. Closes Onshape flyouts and dropdown menus. closeSelectItemDialog no Closes the select item dialog. connectionLost no Displays the standard Onshape connection lost message in a message bubble, forcing the user to either reload the document or return to the documents page. errorReload yes message: your message Similar to the connectionLost message, but enables an application to specify the first part of the message, which will be used instead of \"Onshape is not connected.\" The user must reload the document or return to the documents page. finishedSaving yes messageId: the id sent in the corresponding 'saveChanges' message Response to a 'saveChanges' message sent from Onshape. Should be sent after application has cleaned up any pending edits. keepAlive no Send periodically while while the user is actively working to avoid the session from timing out. saveAVersion no Send when the user types ‚ÄúShift-S‚Äù in the application extension, the keyboard shortcut for save a version. showKeyboardShortcutsHelp no Send when the user types ‚Äú?‚Äù (Shift-? on most keyboards) in the application extension, the keyboard shortcut for the keyboard shortcuts help dialog. showMessageBubble yes message: your message Send when you want to show a string in the blue message bubble at the top of the Onshape app. startLoadingSpinner yes message: your message Send to start a large spinner in the middle of the browser window with your message underneath it. stopLoadingSpinner no Send to stop the large spinner. startWorkingSpinner no Send to start a small spinner in the middle bottom of the browser window. stopWorkingSpinner no Send to stop the small spinner. openSelectItemDialog yes dialogTitle: your dialog title (default is no title), selectBlobs: true or false (default is false), selectParts: true or false (default is false), selectPartStudios: true or false (default is false), selectAssemblies: true or false (default is false), selectMultiple: true or false (default is false), selectBlobMimeTypes: ‚Äòcomma-delimited string of blob mime types to show in dialog (e.g. ‚Äúapplication/dwt,application/dwg‚Äù)‚Äô (default is an empty string) showBrowseDocuments: true or false - controls whether ‚ÄòOther documents‚Äô choice should be available (default is true) showStandardContent: true or false - controls whether ‚ÄòStandard content‚Äô choice should be available (default is false) Send when your application wants to open a dialog in which the user will select one or multiple items - blobs, parts, part studios or assemblies. requestCameraProperties yes graphicsElementId: string , Element ID of the part studio or assembly Send to request camera properties of a specific part studio or assembly element. Note: The element should have been opened at least once in the current session. The messageName of the response is cameraProperties The following messages can be received by Element tab application extensions:\nmessageName (case sensitive) other message properties? comment show no Sent when an element tab application extension is shown (made active) within the Onshape client. This message is NOT sent when the element tab application extension is created. hide no Sent when an element tab application extension is made inactive within the Onshape client. This message is NOT sent when an element tab application extension is deleted. itemSelectedInSelectItemDialog yes documentId: id of selected item‚Äôs document, workspaceId: id of selected item‚Äôs workspace, empty if versionId not empty, versionId: id of selected item‚Äôs version, empty if workspaceId not empty, elementId: id of element selected or containing the selected part, elementName: name of element selected or containing the selected part, elementType: type of element selected or containing the selected part - ‚Äòpartstudio‚Äô, ‚Äòassembly‚Äô or ‚Äòblob‚Äô, elementMicroversionId: microversion id of the element, itemType: type of item selected: ‚Äòpart‚Äô,‚ÄòpartStudio‚Äô or ‚Äòassembly‚Äô, partName: name of part selected, empty if itemType is not ‚Äòpart‚Äô, idTag: id of part, empty if no part selected Sent when the user selects an item (blob, part, part studio or assembly) in the select item dialog that was opened due to an openSelectItemDialog message sent earlier. When a part is not selected, the partXxx message properties will be empty strings. print no Sent when the user chooses the Print command while the application is the active element. The application can choose to handle this as either a print or an export to a PDF or other format. selectItemDialogClosed no Sent when the select item dialog closes, either because the user selected an item and selectMultiple is false, or the user changed the active element or the user closed the dialog with the \"X\" button. startFirstViewCommand yes documentId: id of selected item‚Äôs document, workspaceId: id of selected item‚Äôs workspace, empty if versionId not empty, versionId: id of selected item‚Äôs version, empty if workspaceId not empty, elementId: id of element selected or containing the selected part, elementName: name of element selected or containing the selected part, elementType: type of element selected or containing the selected part - ‚Äòpartstudio‚Äô, ‚Äòassembly‚Äô or ‚Äòblob‚Äô, elementMicroversionId: microversion id of the element, itemType: type of item selected: ‚Äòpart‚Äô,‚Äòpartstudio‚Äô or ‚Äòassembly‚Äô, partName: name of part selected, empty if itemType is not ‚Äòpart‚Äô, idTag: id of part Sent to a drawings application extension when the drawing is created with zero views. If other types of applications need a message posted to them with creation context, contact Onshape and we can discuss using this sort of message for your application also.\nexport yes fileExtension: the file extension of the export type the user chose - ‚Äú.dwg‚Äù, ‚Äú.dxf‚Äù are the types currently supported. baseFileName: the base portion of the expected output file. This is currently set to ‚Äú\u003cdocument name\u003e - \u003celement name\u003e‚Äù Sent when the user chooses a command to export the contents of the application to a file. cameraProperties yes graphicsElementId: string , Element ID of the part studio or assembly isValid: boolean, Indicates if the properties are valid or not. false if element ID is invalid or element has not been open in the current session projectionType: string, Denotes the projection method. Values are ‚Äòorthographic‚Äô, ‚Äòperspective‚Äô . Empty string ‚Äò‚Äô if isValid is false viewMatrix: 16 element numeric matrix with elements at index 13, 14, 15 corresponding to position of the camera projectionMatrix: 16 element numeric matrix verticalFieldOfView: number, 0 in case of orthographic projection viewportHeight: number, eight of the viewport viewportWidth: number, width of the viewport Sent when application posts a requestCameraProperties message takeFocus no Sent when the Onshape client sets focus on the content window of the element tab application extension. saveChanges yes messageId: a unique identifier for this message. Should be passed back in the 'finishedSaving' message. Sent if the application specified 'notifyWhenSaveRequired' in the 'applicationInit' message. Indicates that the application should cleanup any pending edits before an Onshape process continues (i.e. version save). Element Right Panel Most client messaging functionality had been limited to that occurring between the Onshape client and application elements (the Element tab location). Limited functionality in now also available for client messaging to work with application extensions in the Element right panel location.\nEnabled messaging to Element right panel extensions includes the communication of selections that the user makes for the following application extension contexts:\nPart Studio Assembly Document All Security Considerations above apply to both Element tab and Element right panel extensions, with the following notes:\nInitial message from the application extension to the Onshape client, in the form of an applicationInit message (or one of any other messages supported by the element right panel extensions), is required to ensure the Onshape client does not send messages to the extension until it is ready. Once a valid applicationInit message is received by the Onshape client, it will start sending messages with the messageName value SELECTION upon user selection interactions. Prior to accepting any message from the Onshape client as secure, the origin attribute value included in incoming messages must be validated as equal to the original server query parameter value used to load the application extension. Code Snippets Parse query parameters This JavaScript code parses the iframe src query parameters and uses them to post a message:\nvar documentId; var workspaceId; var elementId; var server; // Parse query parameters var queryParameters = decodeURIComponent(window.location.search.substr(1)); var queryParametersArray = queryParameters.split('\u0026'); for (var i = 0; i \u003c queryParametersArray.length; i++) { var parameterArray = queryParametersArray[i].split('='); if (parameterArray.length === 2) { switch (parameterArray[0]) { case 'documentId': documentId = parameterArray[1]; break; case 'workspaceId': workspaceId = parameterArray[1]; break; case 'elementId': elementId = parameterArray[1]; break; case 'server': server = parameterArray[1]; break; } } } // Listen for clicks and post a message to the Onshape client document.getElementById('\u003cid of your topmost element\u003e'). addEventListener('click', function() { var message = {documentId: documentId, workspaceId: workspaceId, elementId: elementId, messageName: 'closeFlyoutsAndMenus'}; window.parent.postMessage(message, '*'); }, true); Create a message object The message object posted to the Onshape client is of the form:\n{ documentId: documentId, workspaceId: workspaceId, elementId: elementId, messageName: '\u003cmessage name\u003e', // ‚Ä¶ other properties as needed for other message types ‚Ä¶ } The message data object posted to the application extension is of the form:\n{ messageName: '\u003cmessage name\u003e', // ‚Ä¶ other properties as needed for other message types ‚Ä¶ } The message will always have a messageName property.\nListen for messages To listen for messages from the Onshape client:\n// server is one of the iframe src query parameters - see above var handlePostMessage = function(e) { console.log(\"Post message received in application extension.\"); console.log(\"e.origin = \" + e.origin); // Verify the origin matches the server iframe src query parameter if (server === e.origin) { console.log(\"Message safe and can be handled as it is from origin '\" + e.origin + \"', which matches server query parameter '\" + server + \"'.\"); if (e.data \u0026\u0026 e.data.messageName) { console.log(\"Message name = '\" + e.data.messageName + \"'\"); } else { console.log(\"Message name not found. Ignoring message.\"); } } else { console.log(\"Message NOT safe and should be ignored.\"); } }; window.addEventListener('message', handlePostMessage, false); Send and handle messages The following is an example of how one might send an initialization message to, and handle post messages from, the Onshape client.\nNote: Proper clean-up of event listeners is not included in the snippet\nfunction handlePostMessage(event) { // ensure that the event data is from a legit source: if(theServerStringFromActionUrl !== event.origin) { console.error('origin of message is not legitimate'); return; } // branch based on messageName attribute switch(event.data.messageName) { case 'SELECTION': console.debug('SELECTION event data: %o', event.data); break; default: console.debug(`${event.data.messageName} not handled`); } } window.addEventListener('message', handlePostMessage); const initMessage = { documentId: theDocumentId, // required - parsed from action url workspaceId: theWorkspaceId, // required - parsed from action url elementId: theElementId, // required - parsed from action url messageName: 'applicationInit' // required }; window.parent.postMessage(initMessage, '*'); Right panel interaction sequence The sequence diagram below illustrates the interaction between an Element right panel application extension and the Onshape client:\n%%{ init: { \"theme\": \"default\", \"sequence\": { \"mirrorActors\": false, \"showSequenceNumbers\": false, \"width\": 75, \"height\": 60, \"actorMargin\": 25, \"messageFontSize\": 13, \"messageFontFamily\": \"monospace\", \"messageFontWeight\": 2 } } }%% sequenceDiagram actor user participant OSC AS Onshape Client participant AE AS Application Extension user-\u003e\u003e+OSC: start element right panel extension Note right of user: via configured button OSC-\u003e\u003e+AE: invoke action url (with query params) AE-\u003e\u003eOSC: postMessage(messageName: 'applicationInit') loop selection interactions user-\u003e\u003eOSC: select OSC-\u003e\u003eAE: postMessage(messageName: 'SELECTION') end user-\u003e\u003eOSC: stop element right panel extension Note right of user: via configured button deactivate AE OSC-XAE: destroy deactivate OSC Right panel message exchange The following messages are exchanged for application extensions located in the element right panel and configured for Part Studio, Assembly, or Document contexts.\nThe first message with messageName attribute set to applicationInit is sent to the Onshape client by an application extension once it is loaded and ready to receive and process incoming messages:\n{ documentId: '\u003cdocument id\u003e', workspaceId: '\u003cworkspace id\u003e', elementId: '\u003celement id\u003e', messageName: 'applicationInit' } The values \u003cdocument id\u003e, \u003cworkspace id\u003e, \u003celement id\u003e, and \u003cserver id\u003e:\nAre originally included as query parameters in the action URL used to request the content of the application extension Must be included in messages sent to the Onshape client While initialization is the specific intent of the applicationInit message, other supported messageName attributes have the same initialization effect upon their first receipt by the Onshape client.\nNext, as the user interacts with Onshape by selecting various parts of the model, messages with the messageName attribute set to SELECTION are sent to the application extension:\n{ messageName: 'SELECTION', selections: [ { selectionType: 'ENTITY', selectionId: 'KRiB', entityType: 'FACE', occurrencePath: [ 'MfOieM8xKIDGHe37c' ], workspaceMicroversionId: 'a781c53fbd1095e3462d2b70' }, { selectionType: 'ENTITY', selectionId: 'KRdC', entityType: 'EDGE', occurrencePath: [ 'MfOieM8xKIDGHe37c' ], workspaceMicroversionId: 'a781c53fbd1095e3462d2b70' } ] } Notes Keyboard focus Keyboard focus will not be transferred to an application until the user clicks in the application or the application programmatically takes focus. An application should programmatically take focus when it is first loaded and when it receives a show message from Onshape. Shortcut keys will work immediately when the application is shown.\nFuture work New message types will be added as needed. If your application extension needs a message not listed in this document, please notify us, and we‚Äôll work with you on it. Mobile client support is unclear at this time. Onshape is considering using promises to wrap POST messages, which would make the application extension‚Äôs JavaScript simpler and enable chaining POSTs with other operations. Promises would make some interactions with multiple responses difficult (e.g., when you open a dialog, like the Select Item dialog, and want to receive multiple POST messages back due to the user clicking on multiple items in the dialog). ","categories":"","description":"","excerpt":"Application extensions and the Onshape JavaScript web client need to ‚Ä¶","ref":"/docs/app-dev/clientmessaging/","tags":"","title":"Client Messaging"},{"body":"Sub Elements Onshape provides application elements storage that is controlled by applications through the API. These elements allow a set of named sub-elements.\nThe application can make changes to sub-elements independently or in arbitrary groupings. Changes may be wholesale replacements, or may be deltas. When performing a delta update, the application may post a full version as well, which allows the api to return a smaller number of deltas for subsequent queries.\nAn application may need to perform multiple versionable actions in the course of performing a user-level action, and we want to allow the individual actions to be collected into a single action from the perspective of document history. We do this by providing support for creation of a private transaction and support for atomically committing the transaction to the document workspace as a single user-visible action.\nOnshape does not assume any knowledge about the semantics of application deltas. All merging of deltas into a consolidated form is done by the application. Applications should typically send checkpoint state for a sub-element if many delta changes have been made since the last checkpoint.\nDocument content and changes are logically an array of bytes, but since they are transmitted through JSON, then are expected to be presented a Base-64 encoding of the array into string form.\nWe use some terminology in this document that is new.\nchangeId - an opaque identifier for the state of an application element. Each change to the application element results in a new changeId\ntransaction - a private workspace within a document workspace for composing modifications to an application element. These changes are not visible to the user until committed.\ntransaction commit - an operation that moves the changes performed within a transaction to the application element workspace as a single user-visible action.\nConcurrent access by multiple users\nIf the element is being concurrently accessed by multiple sessions, updates may encounter conflicts during update. If the application has a mechanism that ensures that all accesses to the element are mediated by a single process, as is done with our part studio and assemblies, this can be addressed directly by the application. However, if the application is not able to mediate access in this way, updates by one session may invalidate state held by another session. We address this by notifying updaters when an update cannot be directly applied because their state is out of date and allowing them to refresh their state before re-applying the change.\nThis policy of requiring the application have current state when posting updates could be overly conservative in some cases. Detecting conflict at the sub-element level might provide for better concurrent access performance, but there probably are cases where this fails, so it probably would need some level of application control.\nJSON Tree In contrast with sub elements, JSON tree storage is a more managed data storage mechanism that Onshape itself can merge and diff. At the root of it, the data structure is a single JSON object per Application Element. The user submits incremental changes that are then applied by Onshape to the JSON tree. Onshape stores these ‚Äòdiffs‚Äô in a new microversion created as a result of the update request, or during a subsequent transaction commit request. When the user then performs a merge or restore operation, Onshape can sum and apply the requisite incremental changes. By storing diffs, Onshape provides to the user a storage mechanism that is more robust to race conditions, since multiple simultaneous edits can be optionally merged by Onshape. All of these qualities make JSON tree a preferred way to store application element data in an Onshape-native manner.\nJSON Tree Edit Semantics BTJEdit Encoding A JSON tree edit represents an incremental change to an application element‚Äôs JSON tree. The edit is a BTJEdit class, which is encoded as one of the following:\nDeletion: { \"btType\" : \"BTJEditDelete-1992\", \"path\" : \"path\" } Insertion: { \"btType\" : \"BTJEditInsert-2523\", \"path\" : \"path\", \"value\" : \"newValue\" } Change: { \"btType\" : \"BTJEditChange-2636\", \"path\" : \"path\", \"value\" : \"newValue\" } Move: { \"btType\" : \"BTJEditMove-3245\", \"sourcePath\" : \"path\", \"destinationPath\" : \"path\" } List (where edit1, edit2, etc. are zero or more edits.): { \"btType\" : \"BTJEditList-2707\", \"edits\" : [ \"edit1\", \"edit2\", \"...\"] } Within the above encoding, newValue is a stand in for any valid JSON, and path is a stand in for an object representing a path to the node at which to perform the edit.\nBTJPath Encoding The BTJPath object describes a path through the JSON tree to a particular node, and is encoded as follows:\n{ \"btType\" : \"BTJPath-3073\", \"startNode\" : \"startNode\", \"path\" : [ \"pathElement1\", \"pathElement2\", \"...\"] } where startNode is a string that is either empty to specify the root node or a nodeId of a node in the tree. The pathElement is one of:\nKey: { \"btType\" : \"BTJPathKey-3221\", \"key\" : \"string\" } Index: { \"btType\" : \"BTJPathIndex-1871\", \"index\" : \"integer\" } In the insertion and move type edits the path elements can describe a path that doesn‚Äôt currently exist. Onshape will generate the proper keys and values as needed to place the node value in the proper location.\nJSON Tree Examples Below are some examples that show the body required to perform the particular edit on a JSON tree.\nDeletion Example If the pre-existing JSON tree looks like:\n{\"myKey\": \"myValue\"} and a delete edit looks like:\n{\"btType\": \"BTJEditDelete-1992\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}]}} then the resulting JSON is the result of deleting the node specified by path:\n{} Insert Example If the pre-existing JSON tree looks like:\n{} and the insertion edit looks like:\n{\"btType\": \"BTJEditInsert-2523\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"insertedKey\"}]}, \"value\": \"myValue\"} then the resulting JSON is the result of inserting the node described by value at the node specified by path:\n{\"insertedKey\": \"myValue\"} Change Example If the pre-existing JSON tree looks like:\n{\"myKey\": \"myValue\"} and the change edit looks like:\n{\"btType\": \"BTJEditChange-2636\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}]}, \"value\": \"myOtherValue\"} then the resulting JSON is the result of changing the node specified by path to the node described by value:\n{\"myKey\": \"myOtherValue\"} Move Example If the pre-existing JSON tree looks like:\n{\"myKey\": \"myValue\", \"myOtherKey\": \"myOtherValue\"} and the move edit looks like:\n{\"btType\": \"BTJEditMove-3245\", \"sourcePath\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}]}, \"destinationPath\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"keyCreatedFromMove\"}]}} then the resulting JSON is the result of moving the node from the specified sourcePath to the destinationPath:\n{\"keyCreatedFromMove\": \"myValue\"} List Example If the pre-existing JSON tree looks like:\n{} and the list edit looks like:\n{\"btType\": \"BTJEditList-2707\", \"edits\": [ {\"btType\": \"BTJEditInsert-2523\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}]}, \"value\": \"myValue\"}, {\"btType\": \"BTJEditChange-2636\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}]}, \"value\": [\"firstValue\", \"secondValue\"]}, {\"btType\": \"BTJEditInsert-2523\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}, {\"btType\": \"BTJPathIndex-1871\", \"index\": 1}]}, \"value\": \"myBetterSecondValue\"}, {\"btType\": \"BTJEditDelete-1992\", \"path\": {\"btType\": \"BTJPath-3073\", \"startNode\": \"\", \"path\": [{\"btType\": \"BTJPathKey-3221\", \"key\": \"myKey\"}, {\"btType\": \"BTJPathIndex-1871\", \"index\": 2}]}} ]} then the resulting JSON is the result of applying all the given edits in order:\n{\"myKey\": [\"firstValue\", \"myBetterSecondValue\"]} The intermediate steps were:\nInsertion: {\"myKey\": \"myValue\"} Change: {\"myKey\": [\"firstValue\", \"secondValue\"]} List insertion: {\"myKey\": [\"firstValue\", \"myBetterSecondValue\", \"secondValue\"]} List deletion: {\"myKey\": [\"firstValue\", \"myBetterSecondValue\"]} All the examples above were tested and validated using the Python client here.\n","categories":"","description":"","excerpt":"Sub Elements Onshape provides application elements storage that is ‚Ä¶","ref":"/docs/app-dev/structuredstorage/","tags":"","title":"Structured Storage"},{"body":"This page describes the Webhook APIs Onshape provides for working with notifications.\nNotifications are delivered to an application as an HTTP POST with a JSON body, which includes information about the identity of the registration request and information specific to the event and notification message.\nWebhooks are an alternative approach to polling; instead of your application continuously asking Onshape for new information, webhooks automatically send a notification from Onshape any time an event you are subscribed to occurs.\nAn application may register for notifications to a URL that uses either HTTP or HTTPS. If HTTPS is specified by the URL template, the notification server must supply a certificate that is signed by a certificate authority (CA) recognized by Onshape. Self-signed certificates (as well as certificates signed by unrecognized CAs) will be rejected, causing notification delivery to fail.\nüìò Notes\nThis page provides sample code as curls. See the curl documentation for more information. All Onshape API calls must be properly authenticated by replacing the CREDENTIALS variable in the curls below. See the API Keys page for instructions and the Quick Start for an example. All applications submitted to the Onshape App Store must authenticate with OAuth2. This documentation refers to Onshape IDs in the following format: {did}, {wid}, {eid}, {pid}, {otherId}. These represent document, workspace, element, part, and other IDs (respectively) that are needed make the API calls. We sometimes abbreviate these variables as DWVEM Please see API Guide: API Intro for information on what these IDs mean and how to obtain them from your documents. Sometimes, this page will use a stand-in string to represent these IDs (000000000000000000000000). Never include the curly braces ({}) in your API calls. For Enterprise accounts, replace cad in all Onshape URLs with your company domain. https://cad.onshape.com \u003e https://companyName.onshape.com Events Each type of event that an application may receive notifications for has a unique identifier known as the event type. Event types are grouped into Event Groups. Each group shares specification requirements.\nEvent types are categorized into several different groups based on the dominant user resource of the event. The group that a given event is part of defines the required parameters needed in the registration process to identify the resource or group of resources to watch. For instance, if registering for an event in the document event group, the application must identify either a specific document‚Äôs id or a specific company‚Äôs id. If registered for a company, the event will be registered for all present and future documents owned by the company.\nüìò Note\nYou can see the full list of available events in the Glassworks API Explorer. Expand the createWebhook endpoint, then click Callbacks.\nApplication Group Monitor changes to applications.\nSupported Event Types\nonshape.user.lifecycle.updateappsettings - Occurs when user application settings are modified Registration Requirements\nclientId - Must be specified in the registration body event - Must be set to onshape.user.lifecycle.updateappsettings options.collapseEvents - Must be set to true or false url - Must be provided to receive the webhook notifications { \"clientId\": \"000000000000000000000000\", \"events\": [ \"onshape.user.lifecycle.updateappsettings\" ], \"options\": { \"collapseEvents\": false }, \"url\": \"https://sampleUrl.org\" } Document Group Monitor various aspects of document changes.\nSupported Event Types\nonshape.model.lifecycle.changed - Occurs when a change to a model is made onshape.model.translation.complete - Occurs when a translation request is complete onshape.model.lifecycle.metadata - Occurs when Part or element metadata is modified onshape.model.lifecycle.createversion - Occurs when a new version of a document is created onshape.model.lifecycle.createworkspace - Occurs when a new workspace is created onshape.model.lifecycle.createelement - Occurs when a new element is created onshape.model.lifecycle.deleteelement - Occurs when an element is deleted onshape.document.lifecycle.statechange - Occurs when a document changes state onshape.model.lifecycle.changed.externalreferences - Occurs when an external reference changes onshape.document.lifecycle.created - Occurs when a document is created onshape.revision.created - Occurs when a revision is created onshape.comment.create - Occurs when a comment is created in a document onshape.comment.update - Occurs when a comment is updated in a document onshape.comment.delete - Occurs when a comment is deleted in a document Registration Requirements\ndocumentId OR companyId must be specified in the registration body\nOnly documentId is valid for the onshape.document.lifecycle.statechange event - Must be set to one of the supported event types listed above\nMay be set to false if the application is always listening to webhook notifications and companyId is specified. If false, unregister the webhook when it is no longer needed. options.collapseEvents - Must be set to true or false\nurl - Must be provided to receive the webhook notifications\n{ \"documentId\": \"000000000000000000000000\", \"events\": [ \"onshape.user.lifecycle.updateappsettings\" ], \"options\": { \"collapseEvents\": false }, \"url\": \"https://sampleUrl.org\" } Workflow Group Monitor release management actions.\nSupported Event Types\nonshape.workflow.transition - Occurs when a revision or release package transitions through workflow states Registration Requirements\ncompanyId - Must be specified in the registration body event - Must be set to onshape.workflow.transition May be set to false if the application is always listening to webhook notifications. If false, unregister the webhook when it is no longer needed. options.collapseEvents - Must be set to true or false url - Must be provided to receive the webhook notifications { \"companyId\": \"000000000000000000000000\", \"events\": [ \"onshape.workflow.transition\" ], \"options\": { \"collapseEvents\": false }, \"url\": \"https://sampleUrl.org\" } Lifecycle Group Monitor webhook changes. You do not need to register for these events; they are sent automatically when a webhook for another event type is registered, unregistered, or pinged.\nSupported Event Types\nwebhook.register - Occurs in response to a notification registration API call webhook.unregister - Occurs in response to a notification deregistation API call webhook.ping - Occurs either: In response to a request by an application to call the pingWebook endpoint. As a post-registration validation initiated by Onshape Example Notifications webhook.register\n{ \"timestamp\": \"2024-05-05T23:45:10.611-0500\", \"event\": \"webhook.register\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"versionId\": \"000000000000000000000000\" } webhook.ping\n{ \"timestamp\": \"2024-05-05T23:45:10.611-0500\", \"event\": \"webhook.ping\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"versionId\": \"000000000000000000000000\" } onshape.model.lifecycle.changed\n{ \"timestamp\": \"2024-05-05T23:46:29.284-0500\", \"event\": \"onshape.model.lifecycle.changed\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"versionId\": \"000000000000000000000000\" } onshape.document.lifecycle.statechange\n{ \"timestamp\": \"2024-05-05T23:46:29.284-0500\", \"event\": \"onshape.document.lifecycle.statechange\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"versionId\": \"000000000000000000000000\", \"documentState\": \"TRASH\" } Possible values of documentState are:\nACTIVE - Document is in a normal, usable state. TRASH - Document has been moved to the trash; user can move document back to ACTIVE state. DELETED - Document has been deleted; user cannot access document. onshape.user.lifecycle.updateappsettings\n{ \"timestamp\": \"2024-05-05T23:46:29.284-0500\", \"event\": \"onshape.user.lifecycle.updateappsettings\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"userId\": \"000000000000000000000000\", \"clientId\":\"000000000000000000000000\" } onshape.model.translation.complete\n{ \"timestamp\": \"2024-05-05T23:46:29.284-0500\", \"event\": \"onshape.model.translation.complete\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"userId\": \"000000000000000000000000\", \"translationId\": \"000000000000000000000000\" } onshape.comment.create\n{ \"timestamp\": \"2024-05-05T23:46:29.284-0500\", \"event\": \"onshape.comment.create\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"000000000000000000000000\", \"messageId\": \"000000000000000000000000\", \"documentId\": \"000000000000000000000000\", \"commentId\": \"000000000000000000000000\" } Endpoints Webhook notifications allow an application to register to receive notifications of certain events that occur within the Onshape environment. To receive a notification, an application must expose an endpoint that Onshape can call.\nWebhook/getWebhooks curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/webhooks?user={uid}\u0026offset=0\u0026limit=20' \\ -H 'aAccept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Webhook/createWebhook curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/webhooks' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"events\": [ \"eventType\" // See the [Events](#events) section above for valid event types. ], \"options\": { \"collapseEvents\": true | false }, \"url\": \"https://sampleUrl.org\" //Other parameters may be required. See the [Events](#events) section above. }' Webhook/getWebhook curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/webhooks/webhookId' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Webhook/updateWebhook curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/webhooks/webhookId' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"id\": \"webhookId\", \"options\": { \"collapseEvents\": true | false } }' Note that the webhook id must be sent in both the URL and the request body. Webhook/unregisterWebhook curl -X 'DELETE' \\ 'https://cad.onshape.com/api/v6/webhooks/{webhookId}?blockNotification=false' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Webhook/pingWebhook curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/webhooks/{webhookId}/ping' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' Sample Workflows Create a webhook An application registers for event notification by:\nMaking a REST call to the Onshape web service Providing a URL to notify Providing the required parameters for the event types to be registered If the registration request is well-formed, the registration API call returns information about the registration, including a unique id string that identifies the webhook registration. This corresponds to the webhookId field in other endpoints. No de-duplication of notification registrations is performed by the API. Each registration call will yield a new registrationId, even if the parameters are identical to those passed in a prior call.\nShortly after an application calls the notification registration API, Onshape will make make an asynchronous trial notification call to the URL generated from the URL template with an event type of webhook.register to test if the application notification server is accessible. If the trial notification delivery fails to return an HTTP 200 status code, the notification registration is cancelled. The trial notification is usually delivered after the notification registration has been received by the application. However, variations in network delays may result in the trial notification occurring before the response is received and processed by the application, so the notification handler should be ready to process notifications before the registration call is made.\nIn this example, we use a webhook to send information from Onshape to another server. You need a URL for Onshape to send notifications to, and a way to view the messages sent with those notifications.\nOpen an Onshape document, or create a new one. In this example, we want to receive a notification from Onshape any time a new version is created in the specified document. For this, we‚Äôll use onshape.model.lifecycle.createversion as our event. The event type requires one parameter. We‚Äôll use our documentId for this field (shown as 000000000000000000000000 in the example below). All event types require specifying true or false for the options.collapseEvents field. In this case, set the field to false. Next, we need the URL to send the notification to. You must provide your own URL to receive notifications here. Confirm your createWebhook call looks like this (substitute your own authorization credentials, document ID, and URL), then make the call. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/webhooks' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"documentId\": \"000000000000000000000000\", \"events\": [ \"onshape.model.lifecycle.createversion\" ], \"options\": { \"collapseEvents\": false }, \"url\": \"https://sampleUrl.org\" }' In your application, confirm that you received the webhook.register event from Onshape. In Onshape, create a new version in your document. In your application, confirm that you received the onshape.model.lifecycle.createversion event from Onshape. Make note of the id in the response; use this as your webhookId in subsequent examples. Get webhook info Complete the Create a webhook steps above to obtain a webhookId. Create your getWebhook call. substitute your own authorization credentials and webhookId (shown as 000000000000000000000000 in the example below), then make the call. curl -X 'GET' \\ 'https://cad.onshape.com/api/v6/webhooks/000000000000000000000000' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ Confirm that the event in the response is onshape.model.lifecycle.createversion. Update a webhook Complete the Create a webhook steps above to obtain a webhookId. Note that in the same response, the webhook description is null. Create your updateWebhook call. In this example, ww update the webhook‚Äôs description. Substitute your own authorization credentials and webhookId (shown as 000000000000000000000000 in the example below in both the URL and request body). Then make the call. curl -X 'POST' \\ 'https://cad.onshape.com/api/v6/webhooks/000000000000000000000000' \\ -H 'accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS' \\ -H 'Content-Type: application/json;charset=UTF-8; qs=0.09' \\ -d '{ \"id\": \"000000000000000000000000\", \"description\": \"Send a notification each time a document version is created.\", \"options\": { \"collapseEvents\": false } }' Confirm in the response that the webhook description is set to Send a notification each time a document version is created. Delete a webhook When an application no longer needs to be notified of changes specified by a particular notification registration, it should normally deregister the notification request. Deregistration is performed by making an HTTP that specifies the hook to deregister. Onshape will attempt to call the deregistered hook with an event type of webhook.unregister as validation that the deregistration is complete. If the application does not deregister the webhook, Onshape will continue delivering notifications until the the application either returns an error in response to a notification for the webhook or fails to respond at all for an extended period of time.\nComplete the Create a webhook steps above to obtain a webhookId. Create your deleteWebhook call. substitute your own authorization credentials and webhookId (shown as 000000000000000000000000 in the example below), then make the call. curl -X 'DELETE' \\ 'https://cad.onshape.com/api/v6/webhooks/000000000000000000000000' \\ -H 'Accept: application/json;charset=UTF-8; qs=0.09' \\ -H 'Authorization: Basic CREDENTIALS=' \\ In your application, confirm that you received the webhook.unregister event from Onshape. In Onshape, create a new version in your document. In your application, confirm that no new events have been received. Additional Resources Onshape Help: Webhooks API Guide: API Explorer API Explorer: Webhooks Sample Code: Python Webhooks ","categories":"","description":"","excerpt":"This page describes the Webhook APIs Onshape provides for working with ‚Ä¶","ref":"/docs/app-dev/webhook/","tags":"","title":"Webhooks"},{"body":"Onshape makes applications available through the Onshape App Store. The App Store is actively promoted to users, making it easy for users to find, purchase, and use third-party applications.\nTo submit an application to the Onshape App Store, complete the Launch Checklist, which provides a step-by-step guide that you can follow to make your app public.\nEnd User Experience Users can browse the Onshape App Store and install third-party applications:\nWhen a user registers an application, there are several possible integration points to expose the application within the Onshape user experience. At this time, applications that provide a UI in an Onshape tab will be added to the + button menu on the Onshape tab bar. See the Extensions page for more information on supported app locations and contexts.\nMobile Clients Onshape expects to enable applications tabs in iOS and Android environments in the future.\nFeedback Your comments, questions, and concerns are always welcome!\nFor API support, email us at api-support@onshape.com at any time. For all other developer-related feedback, email us at onshape-developer-relations@ptc.com. ","categories":"","description":"","excerpt":"Onshape makes applications available through the Onshape App Store. ‚Ä¶","ref":"/docs/app-store/","tags":"","title":"Onshape App Store"},{"body":"This checklist brings together the processes you should follow to ensure your app is launched successfully. While all tasks must be completed to submit your app to the Onshape App Store, the task sequence provided here is a suggestion.\n1. Understand quality expectations These are to ensure that the Onshape App Store remains a trusted resource and that quality is maintained Review the Quality Considerations page, and reach out to the Developer Relations team with any questions.\n2. Sign in to your developer account Sign in to your developer account at dev-portal.onshape.com, and ensure your developer account details are accurate. Contact our API Support team if you need assistance.\n3. Authenticate your app Please refer to the OAuth documentation for information on authenticating your app with OAuth2.\n4. Build your app While building your app, use the resources in our Onshape Developer Documentation, including this API Guide and our API Explorer. We recommend familiarizing yourself with the following pages:\nIntroduction to the Onshape REST API Onshape Architecture Onshape App Development Extensions Client Messaging Onshape App Store 5. Prepare your store entry Prepare the descriptions, promotional graphics, screenshots, and videos you‚Äôll add to your store entry. Make sure you include a link to if required. Watch this video for more details.\nSee the video below for a walkthrough:\n6. Run beta tests During the beta period, try to enlist at least 5 active testers to get feedback before making your app available to the general public.\nTo find beta testers, contact our Developer Relations team, and recruit via the Onshape forum. To give beta users early visibility, first create a team, then ensure your app is shared with that team in the Developer Portal. See the Create a Team in Onshape video for a walkthrough. 7. Determine your app‚Äôs price Once you‚Äôve determined your monetization model, set up your price, billing, and other details. Billing should be tested, and to do so a staging environment is available. See the Billing API page for more details.\n8. Sign and return the developer agreement Email to the Developer Relations team to obtain yours.\n9. Submit your app for final testing Once you‚Äôve returned the developer agreement, you can submit your app to the Developer Relations team for final testing. This is a comprehensive functionality and design test. During this testing period (expect up to a week, depending on complexity), changes to code are prohibited unless requested. At the conclusion of the test, you will receive one of the following notifications from our Developer Relations team:\nApproved for release Approved for release with feedback Changes required before another round of testing 10. Integrate your support systems Whether you use Zendesk, Jira, or email support, we‚Äôll help you determine and set up this integration. Contact the Developer Relations team to explore these options. This is the channel we will use to test your app and provide feedback.\n11. Connect via Slack Connecting directly with our Support, Tech, and Sales teams has proven to be valuable to app developers. This dedicated channel is simple to implement if you already have a paid Slack account. If not (or if you want to use the free version of Slack), we can add members of your team as guests to our account. Please contact Aaron Magnin to establish this connection.\n12. Final check and publish First, double-check you‚Äôve done everything on this list. Now you‚Äôre ready to publish your app to the production channel! Send an email detailing when you‚Äôd like this to happen to the Developer Relations team.\n13. Promote your app Start promoting your app with the Onshape badge and by presenting it to our internal teams in one of the following ways:\nTo the Onshape Tech and Sales teams in a small meeting (~1 hour, Wednesdays at noon Eastern Time) To the entire Onshape organization in a company-wide meeting (~5-10 minutes, Thursdays at 11am Eastern Time). 14. Encourage reviews from users The value of reviews is not to be underestimated. Reviews give users an opportunity to provide feedback, and can also signal to others that your app is worth investigating.\n15. Maintain your app Continually fix stability and performance issues. Improving the user experience will result in more engaged users, higher ratings, and in turn, more success.\nFailure to respond to customer tickets in a reasonable time will lead to the removal of your app from the Onshape App Store.\n16. Increase engagement and retention Aim to increase user engagement, retain and grow your audience, and earn more revenue by:\nEncouraging repeat visits with a nurture stream and training materials Integrating more features from user requests Interacting with and understanding your audience via the Onshape forum, social media, etc. 17. Address app security At some point, a prospect or user will enquire about your app‚Äôs security controls. To address this, we recommend that you understand SOC 2 Compliance requirements, and consider filling out the Consensus Assessment Initiative Questionnaire (CAIQ). Onshape/PTC cannot and will not attest to your compliance. More on SOC Compliance can be found at the following links:\nAICPA.org Wikipedia: System and Organization Controls ","categories":"","description":"","excerpt":"This checklist brings together the processes you should follow to ‚Ä¶","ref":"/docs/app-store/checklist/","tags":"","title":"Launch Checklist"},{"body":"The purpose of this document is to help you get your application and App Store entry ready for QA testing.\nApplication Release Workflow (ARW) Each application submitted to the Onshape App Store goes through a series of stage-gates:\nStarting state: Ok to deploy to limited visibility on Production (Beta testing) Ok to make Public Goal state: Application is Public To advance to the next stage, your application must pass testing, and your App Store entry must pass review.\nKick Off Testing While completing the Launch Checklist, you will need to use Jira to request testing and release for your application. You can initiate the following tasks from Jira:\nRequest application testing: This puts your application in the testing queue. We will note when testing has started (in progress) and when concluded, the ticket will be closed. The outcome will include notes and links to any issues generated (tickets). This phase may include as many iterations as needed to get your application ready. Request public (general) authorization: We will note when testing has started (in progress), and this request will trigger a review of your app store entry and any outstanding bugs. Note there is no implied testing of your application, simply a review of outstanding issues (tickets) and of the App Store entry. Success at this stage will advance the Application Release Workflow (ARW), and you can request public release. Request public (general) release: This request states that you have coordinated with the Developer Relations team and the Onshape Marketing team, and agreement has been reached that the app is ready for launch. Congratulations! Testing Protocol Applications are first tested against the checklist in Addendum A. Production App Store entries are then performed against the checklist in Addendum B.\nResults will be viewable in your Onshape support system (i.e., Zendesk, Jira). The result of each test will be one of:\nPass: No action needed. No notification issued. Enhancement: Suggestions we believe would make the application better. Will NOT prevent the application from being turned on for public access. Bug (low priority): Slight deviations from the criteria that have low end user impact. Will NOT prevent the application being turned on for public access. No stipulated time-frame for resolution. Bug (medium priority): Material deviations from the criteria that are noticeable to the end-user. Represents a minor problem that requires a work-around. Will NOT prevent the application from being turned on for public access. Must be fixed within 30 days. Bug (high priority): Significant deviation from the criteria. WILL prevent the application from being turned on for public access. Bug (MUST FIX): Significant deviation from protocol or security violation. WILL prevent the application from being turned on for public access. If the application is already public, it may be temporarily suspended from the App Store. Testing Notes Testing may be requested at any time. Testing is done on a first-come basis. When testing is complete (pass or fail), you go to the back of the queue. Addendum A Application Test Criteria\nThe application must use the Onshape OAUTH mechanism The OAUTH must be against the correct stack To be promoted to the Production stack, and hosted service must be on a monitored production server with worldwide 24/7 availability. The application should not generate any avoidable console (browser) errors The application should should provide one or more of the following options. The user should not have to leave the registration workflow to complete a pre-requisite. Sign in using the Onshape ID (account created silently on first use) Sign in with partner product account credentials Create a new partner account The application must be capable of managing/displaying documents in excess of 20. The application must display reasonable performance when reading documents, workspaces, elements, and parts. At scale, an account may have thousands of documents, many with multiple workspaces and each with multiple elements. Suggested strategies include: Using a Next button to load the next 20 documents Using infinite scroll (loading the next 20 if the scrollbar reaches the bottom of the dialog) Displaying the most recently-opened documents first Displaying a counter of documents/workspaces/elements read Using progressive loading The application should correctly list valid documents when per document app access is turned on. The application should correctly handle selection of versions. The application should correctly handle selection of workspaces (branches). The application should correctly handle/display elements that are: Part Studios that contain nothing Assemblies that contain nothing Part Studios that contain only surfaces Part Studios that contain only wire data (e.g., helices) The application should appropriately handle revocation of a grant. Addendum B App Store Testing Criteria\nThe application should have a descriptive name The application summary should be accurate The redirect URLS should be valid The iframe URL should be valid The Grant (permissions) request should be no more than is needed The Application Type should be correctly set Team visibility should be set (optional) The category should be appropriate The application description should be accurate The Sign-In URL should be valid The pricing summary should be accurate i.e., trials should not be listed as Free; Free for xx days and then $xx/month is more accurate. All pay plans should have accurate descriptions. The support URL should point to a resource for help (the resource should NOT be an FAQ page, unless that page also contains one of the other options): Support ticketing system (e.g., Zendesk, Jira, etc.) Web page with a telephone number Web page with an email address Forum The EULA link should point to an English Language EULA. ","categories":"","description":"","excerpt":"The purpose of this document is to help you get your application and ‚Ä¶","ref":"/docs/app-store/testingguidelines/","tags":"","title":"Testing Guidelines"},{"body":"Core App Quality Onshape users expect high-quality apps. App quality directly influences the long-term success of your app in terms of installs, user rating and reviews, engagement, and user retention.\nThis page helps you assess the core aspects of quality in your app, through a compact set of quality criteria and associated tests. All Onshape apps should meet these criteria.\nBefore publishing your apps, test them against these criteria to ensure that they function well. Your testing should go well beyond what‚Äôs described here; the purpose of this page is to specify the essential quality characteristics all apps should display, so that you can cover them in your test plans.\nFunctionality These criteria ensure that your app provides the expected functional behavior, with the appropriate level of permissions.\nArea Description Permissions The app requests only the absolute minimum permissions that it needs to support core functionality. Compatibility, Performance, and Stability These criteria ensure that apps provide the compatibility, performance, stability, and responsiveness expected by users.\nArea Description Stability The app does not crash, force close, freeze, or otherwise function abnormally. Performance The app loads quickly or provides onscreen feedback to the user (e.g., a progress indicator or similar cue) if the app takes longer than two (2) seconds to load. Visual quality The app displays graphics, text, images, and other UI elements without noticeable distortion, blurring, or pixelation. Security These criteria ensure that apps handle user data and personal information safely.\nArea Description Data All private data is stored in the app‚Äôs internal storage. All data from external storage is verified before being accessed. No personal or sensitive user data is logged to the system or app-specific log. Networking All network traffic is sent over SSL. Onshape App Store These criteria ensure that your apps are ready to publish on Onshape App Store.\nArea Description App Details page The app‚Äôs feature graphic follows guidelines such as: - The app listing includes a high-quality feature graphic.- The feature graphic does not resemble an advertisement.- The app‚Äôs screenshots or videos do not represent the content and experience of your app in a misleading way. User support User-reported bugs are addressed if they are reproducible. Test procedures These test procedures help you discover various types of quality issues in your app. You can combine the tests or integrate groups of tests together in your own test plans. See the sections above for references that associate criteria with these test procedures.\nType Description Core suite Navigate to all parts of the app: all screens, dialogs, settings, and all user flows. Security - Review all data stored in external storage. - Review how data loaded from external storage is handled and processed. ","categories":"","description":"","excerpt":"Core App Quality Onshape users expect high-quality apps. App quality ‚Ä¶","ref":"/docs/app-store/quality/","tags":"","title":"Quality Considerations"},{"body":"The easiest way to get started with the Onshape API is to look at our sample applications. Each sample application is provided as a Github repository. For access, go to https://github.com/onshape-public.\nSample Apps and Tutorials In Sync Data and Metadata, we set up a third-party OAuth application and pull part numbers into it from Onshape. Whether data is released initially in Onshape or in the third-party application, those releases must be kept in sync. In Sync Releases and Revisions, we use part number data (pushed to the third-party application in the previous tutorial) to release data and push notifications back to Onshape. Generate Derivative Files deals with the creation of derivative files (such as PDF, STEP, etc.) once the release has been successfully completed. In the Extensions tutorial, we add our app to an extension in the right-hand fly-out panel in Onshape. In the glTF Viewer app, we authenticate with OAuth2 and fetch a glTF representation of an Onshape model. ","categories":"","description":"","excerpt":"The easiest way to get started with the Onshape API is to look at our ‚Ä¶","ref":"/docs/tutorials/","tags":"","title":"Sample Apps"},{"body":"The first business case is probably the most common, ‚ÄúHow do I sync data that I create in Onshape with my ERP or PLM system?‚Äù. There could be many reasons why you would want to sync data between two different systems. Primarily Onshape is a system that creates new data. This data is created by designers as they perform their daily tasks. While the designer works primarily in Onshape, the actual data that they create does not exist in a vacuum, it is used by other departments, other processes within the organization. These departments and processes probably do not have access to Onshape or the required knowledge of how to use Onshape. In addition, quite often, the data generated by Onshape will be augmented with additional data as the product lifecycle process progresses.\nTherefore, Onshape could be considered the genesis of the data that will be used to develop a product, yet it is not the only data that will be required.\nOverview In this business case we examine how a designer could work in Onshape and how the data generated by Onshape can be used to make decisions in other systems. Based upon the decisions made, data is pushed back to Onshape as values calculated in another system. Let‚Äôs look at the process in much more detail.\nStep 1: Define Properties in Onshape In the first step, the designer starts a new part in Onshape ‚Äì remember that in Onshape a Part can be created along with other parts in a Part Studio, so we can assume that there could be multiple parts created in the single document. Obviously, we want the designer to have the freedom to use all Onshape functionality without constraints placed by the demands of the integration.\nAt some point in the design process, the designer will be required to enter property values for the part ‚Äì these could include values such as the Part Name, the description, material and so on.\nThe designer clicks the ‚ÄúSave‚Äù or ‚ÄúApply‚Äù button for the properties and closes the properties window.\nA web hook that listens to any changes in the properties has been defined. As the user saves the properties, the web hook is triggered, and it will send a notification through the defined web hook to the third-party system.\nNote: There are Part properties, workspace properties and document properties ‚Äì all these properties live at different levels of the document. While the trigger could pick up changes to any to these properties, we are currently focused on just Part properties ‚Äì the event will be triggered on any saving of properties, however our third-party code can ignore anything that‚Äôs not a Part (or an Assembly). In this next step we assume that a new object is being created in the third-party application.\nStep 2: Create Corresponding Object Once the designer made changes to the properties in Onshape and saved those changes, a message is sent to our third-party application. This message is in JSON format and contains minimal information such as the Workspace ID, the Document ID, the Element ID, the Part ID (if it‚Äôs a Part) and information regarding the event that was triggered. The third-party application receives this information to an endpoint that was defined during the setup of the web hook.\nThe code in our application can now use the ID‚Äôs sent over to check if an object with corresponding IDs exists in our system. Here we are assuming that no such object exists. This does mean that we must store Onshape IDs into our objects in the third-party system.\nWe then create a new object and populate the ID information and save it to the database. Note that at this point in time, we only have minimal information that provides no more than the identity of the Onshape Part.\nNext, in order to get the complete metadata, we must make a REST API call to Onshape in order to get the metadata for the part. Since we were provided the ID information in the web hook, we have enough information to go back to Onshape and request the metadata for a specific, document, element, workspace and part.\nNote that you can either store the Onshape IDs in separate fields in your database or as one long unique string which can be used to easily identify the part in your application.\nStep 3: Get Onshape Metadata The response from the call to the Onshape API is sent back as JSON. The data will contain a lot of different objects that represent the property values, their types, the IDs, name of the property, value of the property, etc.\nOnce received this data must be parsed by your third-party application code and the corresponding object updated as required. For bi-directional update, it is important to store the Onshape property IDs of any data that will need to be synced back to Onshape from the third-party application.\nThis is an optional stage. Once you have all the metadata values imported, you could now calculate any values that are based off the metadata. The most common use case scenario is the generation of intelligent part numbers. Based off configuration, part type, etc., you could generate a part number that has specific meaning within the context of the company.\nIf you calculated specific values, you can now store them in your database.\nStep 4: Modify Properties in Onshape As in Step 1 the designer updates the properties in Onshape ‚Äì this is obviously something that can happen multiple times\nThe web hook is triggered when the designer saves the property changes\nOur third-party application is listening for property changes\nThe third-party application‚Äôs code will check if the corresponding object exists based off the IDs sent from Onshape.\nIn this scenario the corresponding object has already been saved in our system\nWe make a REST API call to Onshape to get the metadata based off the IDs sent from Onshape.\nOnshape returns the JSON that represents the updated properties\nWe ingest the updated metadata and update our existing object in the third-party system.\nStep 5: Request Part Number As we will see later, Onshape has the built in capability to pull custom part numbers from a third-party system. From either the properties window or the release candidate window, click the button to request a part number\nOnshape sends basic ID information to a predefined endpoint in our third-party app.\nThe ID information sent by Onshape is enough data to find the corresponding object in our database. We then extract from that object the pre-calculated intelligent part number ‚Äì or we can calculate it at this point.\nThe part number is returned to Onshape and populated in the Part Number field\nNote that in order to pull a part number from a third-party application we will need to implement OAuth2 in our application and grant Onshape access to the resources of our application. Onshape has a very good mechanism for achieving this and we will be explaining this in detail in this section.\nNote that by default Onshape uses its own internal Part number generator, in order to use a custom third-party generator, we will need to define an app extension and then define in the Enterprise release settings to use our custom part number generator.\nStep 6: Push Updates from Third-Party Application In this scenario we are updating an Object in our third-party application and expecting that some of the property values will be updated in Onshape. We can either send over all the properties populated for this object, or a subset of properties and values\nThe REST API to update properties in Onshape requires that we reference the IDs of the properties that we are updating. For this reason we have stored the Onshape property IDs with our metadata object in our database.\nWe construct the correct JSON that contains all the properties to update and the new values. We can then call the Onshape REST API to update the properties in Onshape with the new data.\nOnce successfully completed, the Onshape REST API call will return HTTP 200 and we can notify the user if needed.\nNote that updates to Onshape will happen behind the scenes in real-time, therefore someone working on the document in Onshape will be able to see the updates as soon as they have been made. There is no notification in Onshape that notifies the user that properties have been updated, however you can open the properties window and view the updated data.\nImplementation We‚Äôll start by defining an App Extension in Onshape so that we can receive custom part numbers.\nDebug All Browsers now have developer tools exposed in their interface. These tools provide us ways to debug client code, view console messages and most importantly for our use case, view Network requests and their response.\nIn this example I am using Chrome‚Äôs developer tools. Most other Browsers have more or less copied Chrome‚Äôs layout for the developer tools so it should be easy to find the network section.\nFigure 24 Accessing Chrome‚Äôs Developer Tools\nLet‚Äôs take the simple use case of trying to understand which endpoint Onshape uses for saving Metadata.\nOpen a document in Onshape and define some properties ‚Äì don‚Äôt save yet.\nPrior to saving open the developer tools and click on the ‚ÄúNetwork‚Äù tab.\nFigure 25 Developer Tools Network Tab\nNext save the updated properties by clicking either the Apply Button or the Save Button\nIn the Network tab you will see a new web request ‚Äì select it:\nFigure 26 Network Request Sample\nWhat we are seeing here is the response from the call to Save the properties. We can expand this response to view the complete JSON.\nBy clicking on the Headers we can view the actual request:\nFigure 27 HTTP POST Request for Saving Properties\nHere we can see that this will correspond to the APIs listed in the API Explorer.\nMost importantly the ‚ÄúPayload‚Äù tab is our definition of the body of the request. This is provided in JSON format and can be expanded. As shown here:\nFigure 28 HTTP POST Body\nWe now have the correct API call and the format of the body to successfully make the API call. We can also see from the body that if we wish to update properties in Onshape from our third-party application, we need to store the propertyID value.\nIt is important to mention ‚Äì ALWAYS use cad.onshape.com to make API calls (no matter what you see in the Headers tab or is shown in the Payload tab.\nDefine an Application Extension An application extension is how Onshape embeds third-party application features in its UI. There are two types of extension:\nAn extension that embeds its UI from the application into the Onshape UI in an iFrame. Such a application my call Onshape REST APIs or just expose an application interface inside Onshape.\nAn extension that embeds and that calls a REST API exposed by the application from the Onshape UI. For instance, embedding application functionality in the context menus or toolbars. This type of application extension relies on external OAuth information in order to authenticate the call. In this case Onshape acts as the client and the application as the server.\nEach extension will exist at a specific location in the Onshape UI and will work within the context of that location or a specific selection, passing the relative information to the application.\nIn order to define the Application Extension we return to the development portal at https://dev-portal.onshape.com/oauthApps where we initially defined our OAuth Application.\nSelect the OAuth Application that you previously defined and click on the Extensions tab.\nFigure 29 - Oauth Applications - Extensions\nStart by clicking the Add Extension button.\nNote that you can create as many extensions as you need for your application within the Onshape UI.\nThis is the interface where you define where in the Onshape UI the command will appear, and what endpoint in your application the command will reference. Changing the Location dropdown will provide additional fields that can be defined to specify context and other relevant fields.\nFor our use case, Define a name, i.e. ‚ÄúCustom Part Number Generator‚Äù, define a description of the extension and select ‚ÄúPart Number Generator‚Äù from the Location dropdown. The only other field that you need to define is the Action URL. This is the endpoint in your application where you will fetch the part number from.\nFigure 30 - Define Application Extension\nOnce you save the definition you will see it in the list of extensions. You can always come back and edit the definition of the extension.\nGrant Onshape Access to 3rd Party Data If you require Onshape to access the resources of your application, then you will need to define the external OAuth parameters. In our use case we will need Onshape to access data in our application in order to pull the part numbers into Onshape.\nClick on the External OAuth tab, the final tab on the OAuth Applications page.\nFigure 31 - Define External OAuth\nIn this guide we‚Äôre not detailing the implementation of OAuth2 inside your application, this is explained very well in many on-line guides. My favorite of these can be found at: https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\nOnshape provides the fields that are required for it to make a secure request to your application, receive an access Token and refresh it when required. In this case Onshape acts as the client and your application as the server ‚Äì this is the inverse to what we defined when we enabled the third-party application to access Onshape.\nOnce you have defined the fields, Save/Update the definitions. We have now completed defining the application extension and enabling Onshape to access your applications resources.\nNote if you haven‚Äôt defined all the endpoints at this time, you can come back later and update the information once you have it defined in your application.\nThe last thing we need to do is for the user to grant access for Onshape to access your applications resources. We can do this through the same interface that we used to grant access to Onshape.\nFrom inside Onshape go to your account settings, from the top right dropdown menu. Click on the applications page.\nFor applications that have an application extension and External OAuth defined we have the ‚ÄúGrant‚Äù button available in the ‚Äúexternal Access‚Äù column as shown here:\nFigure 32 - Grant External Access\nClick the ‚ÄúGrant‚Äù Button in the External Access column.\nYour third-party application will present the user with option to authorize access to the application ‚Äì similar to this simple interface:\nFigure 33 - Enabling Onshape to access a 3rd parties data\nIf you click ‚ÄúAllow‚Äù, you will be returned to Onshapes Applications page and external access will be granted.\nDefining Webhooks Now that we‚Äôve defined our application extension and OAuth access to our application, we can start on receiving notifications in our application when events happen in Onshape.\nOnshape supports webhook notification for many different types of events. We will register an endpoint in our application that will receive a notification whenever something occurs in Onshape. In our specific scenario this will be when the user updates the Onshape properties ‚Äì as we defined in Step 1 Define Properties in Onshape:\nFor our purposes we will be registering to receive web hook notifications for the onshape.model.lifecycle.metadata event. When registering for an event in Onshape there are only two pieces of information required:\nThe event (onshape.model.lifecycle.metadata)\nThe Enterprise ID\nTo easily find your enterprise ID, in Onshape select the Enterprise Settings option from the top right dropdown menu and then click on the ‚ÄúDetails‚Äù menu option on the left-hand menu bar.\nYou will see your Enterprise ID and a ‚ÄúCopy to Clipboard‚Äù button next to it. This will enable you to directly copy this unique ID into your code.\nFigure 34 - Finding Your Enterprise ID\nThe following code shows how we can register a webhook in Onshape.\nIn this example I‚Äôve hard-coded a few of the values for clarity, however this method could be re-written to be a generic model for registering various webhooks. Some good examples of registering for webhooks exist at https://github.com/onshape-public.\nAs with other calls to Onshape that we‚Äôve seen, we are passing the accessToken in the header in order to establish a secure call to Onshape‚Äôs resources.\nThe information coming back from the registration call will be similar to the following:\n{ \"timestamp\": \"2014-12-16T23:45:10.611-0500\", \"event\": \"webhook.register\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"544e91f7fb88ed44f5de1508\", \"messageId\": \"34795d2e5f5f44eeb61fb7b1\", \"data\": \"Some data\", \"documentId\": \"000000000000000000000000\", \"versionId\": \"000000000000000000000000\" } In our example we are saving the event (onshape.model.lifecycle.metadata) and the returned webhookId to a database in order that we can later ping it to make sure that it is live.\nFollowing the registration of the webhook, Onshape will attempt to make a call to the Notify URL defined in the body of the registration request. This is the endpoint of your application that should be called when the event is fired in Onshape. The most common reason for registration failures is that the endpoint you defined, does not return an HTTP 200 status code. Therefore, even if you registered for an event and received a registration notification and a webhookId back from Onshape, your web hook is not in fact registered until Onshape validates the notify URL and receives the HTTP 200 notification back from it. Unfortunately there is no way to easily know if your web hook has been successfully registered until you either ping it, request to list it, or try to activate the event through Onshape.\nAlso it is important to know that even when your webhook is registered successfully, if you change your code later on and Onshape fails to receive an HTTP 200 status code back from the notify URL, the web hook will be removed.\nOne of the ways we can validate that a webhook is ‚Äúlive‚Äù is by pinging it using the Onshape REST API. The following code shows the implementation of a ping to the webhook. If an HTTP status code of 200 is returned, we know that the webhook is enabled, if not then we can re-register the webhook as needed.\nOnce we store the webhook ID in the database we can ping the webhook whenever the application is loaded and validate that it‚Äôs still registered. If we need to re-register the webhook (usually only occurs when changes are made to the code in the notify URL), we can create a new webhook registration and update the database record.\nNote that you can create many duplicate webhook registrations for the same event with the exact same notify URL. Onshape doesn‚Äôt limit how many registrations are created for a single webhook. In the event that this happens, the notify URL will be called as many times as there are webhooks registered for that event. You can validate the registered webhooks by calling the Webhook API.\nUse https://cad.onshape.com/glassworks to call APIs and validate the requirements for each REST API call. This interface lists all the available Onshape REST APIs and provides examples of the values returned from each call.\nReceiving Webhook Notifications Once your webhook is registered and confirmed to be working you should be getting a notification from the webhook to your notify URL. The notification should be similar to the following:\n{ \"timestamp\": \"2014-12-16T23:46:29.284-0500\", \"event\": \"onshape.document.lifecycle.metadata\", \"workspaceId\": \"000000000000000000000000\", \"elementId\": \"000000000000000000000000\", \"webhookId\": \"544e91f7fb88ed44f5de1508\", \"messageId\": \"60f54ac1cbc04179a6642d9a\", \"data\": \"Some data\", \"documentId\": \"0f9c4392e5934f30b48ab645\", \"versionId\": \"000000000000000000000000\", \"documentState\": \"IN PROGRESS\" } In your case the workspaceId, elementID, documentID, and PartId should be populated with the values from the Onshape document that was open when the properties were updated.\nIt is important to note that there is currently no OAuth validation on the webhook response, therefore the endpoint in your application will not receive any access token data for directly calling Onshape APIs. Therefore, if you need to make a call to the Onshape REST APIs inside the notify URL endpoint make a call to an endpoint in your application and include your application OAuth credentials in the body of the request. In this way, you can make a call to your application and load the passport and the Onshape credentials.\nOnshape takes security very seriously and for this reason, unauthenticated calls only provide minimal details such aa, in this case, id‚Äôs.\nGetting Onshape Properties In our specific use case, when we received the webhook notification, we want to use the ID data provided to find the corresponding object in our database (or create a new one) as shown in Step 2 Create Corresponding Object: Then we make a call to the Onshape REST API: /metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}\nAll the relevant data is provided in the response from the webhook so we can pass this to the method which will call this API as follows:\nFrom this call I am returning the ‚Äúproperties‚Äù part of the JSON ‚Äì this contains all the metadata definitions that I wish to store in my database and associate with the corresponding object. The following is an example of one of the property objects:\nIn fact there is probably only three key pairs that we‚Äôre interested in here:\nName ‚Äì name of the property. In this case ‚ÄúName‚Äù\nValue ‚Äì the value of the property. In this case ‚ÄúTop Plate‚Äù\npropertyId ‚Äì the ID of this property. We might need this if we want to enable a bi-directional sync between both applications.\nNote that for valueType CATEGORY the actual name, value and id will be embedded deeper in the object inside an array. I suggest copying and pasting the output from the API call into a JSON viewer such as http://jsonviewer.stack.hu/ so that it will be easier to find where the correct values are.\nWe can now update our corresponding object with the Onshape metadata values as described in Step 3 Get Onshape Metadata:\nUpdating Onshape So far we have pulled data from Onshape and populated it into our third-party application, however what if we make updates in our application that we want to propagate back to Onshape? This is certainly possible through Onshape‚Äôs REST API. Usually this would be implemented in your application on the click of a button ‚Äì such as ‚ÄúSave‚Äù, if you have multiple properties to update, or when a property is updated if you want to trigger the sync for the update of a specific field.\nEither way it is fairly straight forward to send the REST API call to Onshape to update properties. The following snippet of code shows how the call can be made:\nAs we can see here, we provide the body in the form of JSON that includes an array of items (in this case one item) and a nested array of properties (two property objects are listed here). Each property has a value and an ID of the property in Onshape to update.\nThe response from this API call should be an HTTP 200 status. If this is the case, we can update the user that the sync was successful.\nIf you know that you want to update Onshape with property values from your application, it will be important to build a data model that can store the properties with the unique ID provided by Onshape.\nImplementing Custom Part Numbers The final step in this business case is to pull the part numbers form our third-party application. The part numbers can be calculated based on metadata values that were previously synced from Onshape or they might be numbers being pulled from yet another system ‚Äì such as an ERP or even a Google Spreadsheet. The important thing is that when the user clicks a button in Onshape, the correct Part Numbers get populated.\nTo first understand how the setup for pulling part numbers from a third-party application we need to go back to the definition of our Application Extension in the Onshape developer‚Äôs portal.\nHere we can see that we gave the application extension a name, defined the location as ‚ÄúPart Number Generator‚Äù and defined the ‚ÄúAction URL‚Äù ‚Äì this is the endpoint in our application where we will fetch the part number from.\nOnce we have the application extension defined as Location = Part Number Generator, you will be able to use this option inside Onshape Release Management settings.\nNote that in order to use the Part Number Generator option you will have to define the External OAuth option and grant Onshape access to the resources of your application. This is because Onshape will need to access the defined endpoint in order to pull the part number from the application\nFrom within Onshape Select the ‚ÄúEnterprise Settings‚Äù from the top right dropdown menu. Navigate to the ‚ÄúRelease Management‚Äù settings and scroll down to the ‚ÄúRevisions and part numbers‚Äù section of the page.\nFigure 36 - Revisions and Part Number Settings\nIn the Part Number Generation dropdown select the ‚ÄúCustom Part Number Generator‚Äù. Note that this is the name that you defined in your Application Extension so it might differ from what‚Äôs shown here.\nFigure 37 - Selecting Custom Part Number Generator\nFinally scroll to the bottom of the page and save the settings.\nNote that you will need the Admin role in order to access the enterprise settings.\nImplementing Part Number Code Onshape will send a message to the endpoint defined in your application extension settings. The content of this message will be an array of the following data.\nThere might be one or more object depending upon where the user initiated the call for part numbers from. For instance, if the call was initiated from the Part properties window, there will only be one object, however if initiated from the release candidate window, multiple parts/assemblies and drawings might be requested in the single call. Therefore, your code should be able to handle these two situations.\nOnshape will expect a response back from your endpoint and it should be formatted in the following manner:\nNote that in fact only the id and partNumber fields are actually required ‚Äì the other fields are optional.\nThe following is an implementation of the getNextPartNumber endpoint that was defined in the application extension ‚ÄúAction URL‚Äù field:\nThis in turn calls a function that pulls the next part number from the corresponding object in the database (this was defined in, Step 5: Request Part Number). In this function I‚Äôm defining the object that will be sent to Onshape with the part number. This will be called multiple times depending how many objects were sent from Onshape.\nIn this case I‚Äôm sending back all the data required by Onshape, however it would be enough to just populate the id and the partNumber.\nOnce you load the Part Properties window or the Release candidate window, you can now request the Next Part number. The part number will be pulled from the third-party application and populated in the relevant fields as shown below.\nFigure 38 - Release Candidate Part Number generation\n","categories":"","description":"","excerpt":"The first business case is probably the most common, ‚ÄúHow do I sync ‚Ä¶","ref":"/docs/tutorials/sync/","tags":"","title":"Sync Data and Metadata"},{"body":"This tutorials builds off the Sync Data and Metadata tutorial. Please complete that one before starting on this one.\nIn this case, we‚Äôll be looking at the ability for Onshape to sync its release data with an external system and for that system to send information back to Onshape with regards to released data.\nThis specific business case will look at what happens when you wish for a PLM system to control the release of data instead of Onshape having that control ‚Äì this is in fact a common use case.\nOverview We have mentioned before that Onshape has the ability to release data ‚Äì it is totally integrated to Onshape since there is no division between CAD capabilities and PDM capabilities in Onshape ‚Äì they are all part of the same solution. See Versions and Releases for more information on how Onshape manages releases. There is importance in releasing data through Onshape. Onshape uses visual cues to show which parts are released in an assembly for instance and which parts might have a newer revision. Onshape can also add/remove watermarks to drawings and update the title block depending on release states. Also, the BOM table can pull a parts release data and display it. All this is dependent upon a release process being completed in Onshape.\nMany organizations have implemented Product Lifecycle management systems (PLM). One of the key benefits of a PLM system is that it manages more than just engineering data originating from the engineering department, it deals with all the data related to the product ‚Äì from concept through retirement. Therefore, it is a system that is used by many groups and departments throughout the organization.\nOften, in release processes or Engineering Change processes, additional input and approvals are required from various departments downstream from engineering. PLM systems are very good at routing the data for approval to users from multiple departments and groups throughout the organization. Onshape, on the other hand, is very focused on the engineering department and the data generated there. While it certainly has the capabilities to bring other groups into approval processes, it is not considered a process centric enterprise-wide system with the capabilities of a PLM system.\nMany companies will have well established processes that have been modeled in their PLM system, it is much easier for us to integrate into those processes than reinvent the wheel in Onshape.\nThis section looks at how we might have the best of both worlds, initiate release processes in Onshape and update our Onshape visual cues as well as have the PLM system manage the actual approvals and release.\nThis section uses concepts such as OAuth and web hooks that we have introduced in detail in previous sections, therefore feel free to reference those sections for more information on these topics.\nStep 1: Initiate Release In this first step we are using Onshape‚Äôs out-of-the-box capabilities to initiate a release candidate ‚Äì just as we would if we were releasing natively in Onshape.\nWe start by initiating the release on all the data that is required. In this step you should use a custom workflow that simply has one approval node.\nDefine the mandatory and any other release properties in the release candidate window. Figure 40 - Initiating a release candidate\nSince an approver is required, we must provide a fictious user/approver that has been defined in the system ‚Äì this could be named ‚ÄúRelease Approver‚Äù for instance. The process will be sent to this approver even though they are not a real person and will not be able to approve the release. Instead, our release process will be approved by an external source.\nFinally, when everything is defined, submit the release. The window will close. Since the release is pending approval, the parts involved in the release will enter the state of ‚ÄúPending‚Äù as shown here:\nFigure 41 - Pending Release\nThey will remain in this state until the release has been completed.\nIt is important to note that unlike traditional PDM systems where the files are locked for change until the release is completed or rejected, Onshape does not lock the files. As mentioned previously, Onshape views the releases as a point in time. As far as Onshape is concerned, time moves forward, parts can change and at a specific point in time, the parts are in a state of pending. It is important to mention that this does in fact prevent another release from being initiated on the parts until the previous release has been completed.\nStep 2: Initiate Release Process in 3rd Party App Once the user initiates the release candidate and the parts transition to the ‚Äúpending‚Äù state we can register for a webhook that will notify our third-party application that the parts have changed state.\nOnce the parts enter the workflow, the onshape.workflow.transition webhook will be triggered.\nOur third-party application should be listening for this event along with other data, we are provided with the objectId of the release package ‚Äì this is all the data associated with the parts that are to be released. The response also contains the objectType and the transitionName; for our use case we will only concern ourselves with requests that have an objectType of ‚ÄúRelease‚Äù and a transitionName of ‚ÄúSubmit‚Äù.\nUsing the ObjectId we make an API call to onshape; /api/releasepackages/\u003creleasePackageId\u003e?detailed=true\nThis API call will return to us a JSON response containing all assemblies and parts in the release package. The following information should be extracted from the release package:\nFor each line item (assembly or part) extract the documentId, the elementId, elementType, versionId and PartId\nIterate through the top level properties and record the propertyId for property with the name ‚Äúcomment‚Äù ‚Äì this will be used to update the release comments later on.\nNow that we have the relevant IDs we can update the state of our corresponding objects in the third party system and record any additional data such as the release comment field.\nFinally, we can kick off our official release process in the third-party application. This could be an automated process or a manual one.\nStep 3: Complete Release Process The release process continues in the third-party application until approvals have been received by all required actors. Meanwhile in Onshape the parts are in the pending state. In this step we close the loop once the release process is completed.\nThe release process managed by the third-party application is completed and the data in that system is released.\nOnce this happens, we make a call to the Onshape API; /api/releasepackages/\u003creleasePackageId\u003e the releasePackageId is the ID we were provided with at the start of this process ‚Äì While there are different ways of implementing this, I tend to store the ID and any other data related to the release in a custom ‚Äúrelease Object‚Äù in my database so I can retrieve and update the release as required. In addition to the passing the release package ID, in the body of the request we should pass the id of the release comment and a value for the comment. This will update the release in Onshape with any relevant data.\nOnshape releases the data that was included in the release candidate and that completes the workflow process.\nOnshape will return a status code that indicates success or failure\nFinally we can optionally update the corresponding object to indicate that it is in sync with the Onshape data.\nIn the event that the release process is rejected at anytime, we can send the releasePackages API request to Onshape with a REJECT workflow Action argument. This will cause Onshape to reject the workflow and the state of the parts at the specific release point in time, will be set to ‚ÄúRejected‚Äù.\nFigure 43 - release candidate rejected\nSince our timeline is moving forward this has no actual effect on the parts other than to cancel the pending release and enable them to be released at another future point in time.\nImplementation In this section we will take a closer look at how to implement the release scenario in our code. The first thing we need to do is define the correct web hook to listen for the initiation of the release ‚Äì this means that once the user clicks the submit button on the release candidate dialog, this web hook will be triggered.\nSet Up Webhook This code is very similar to what we defined previously for the metadata update, instead here we are defining a hook for the onshape.workflow.transition hook. As with other code examples that require authentication, we have included error handling in order to refresh that access token in the event that it has expired.\nThe onshape.workflow.transition will in fact fire whenever a revision or release package transitions through different workflow states. In his specific case we are only interested in catching the event when the workflow is initially submitted. This can be filtered by the information sent to the return URL, in this case https://myserver.com/api/getReleaseData\nIn this implementation we are storing he webhook ID in the database so that we can ping it when the application is loaded to make sure that it is still active. Other implementations delete the webhook after it is used and then recreate it as required. There is no specific preference for which methodology is better ‚Äì that depend s upon the requirements of your integration.\nReceive Web Hook Notifications Once the user who is initiating the release clicks the Submit button on the Release Candidate dialog, the webhook will be triggered and a message will be sent to the third-party application listening for that webhook.\nIn our example the URL that the webhook data from Onshape gets sent to is:\nhttps://myserver.com/api/getReleaseData\nIn our application we can define a router for that end point as follows:\nrouter.route(‚Äô/getReleaseData‚Äô).post(mymodule.getReleaseData);\nIn this case ‚Äúmymodule‚Äù is where I‚Äôve defined all the functionality for managing data coming from Onshape. Since the webhook data contains no authentication information (just minimal data is sent from the webhoom for security reasons), we can‚Äôt directly authenticate our application against Onshape, therefore we need to pass the data received from the webhook through a method that will then add the authentication data to our request object. The getReleaseData method simply passes the webhook information received by the application to another authenticated endpoint as follows:\nHere is the endpoint defined for processReleasePackage:\nrouter.route(‚Äô/processReleasePackage‚Äô).post(authController.isAuthenticated, releaseController.processReleasePackage);\nAs we can see here, we have now added in the authentication middleware - authController.isAuthenticated - and can make secure calls to Onsahpe‚Äôs API.\nGet Release Package Data The parameter that the web hook sent over to our application that we need to make use of is the ID of the release package. We can now make a call to Onshape to retrieve the complete release package with the ID.\nWe get the release package ID from the request object and make the REST API call to get the package as follows:\nThe complete release package should be returned in ‚Äúresponse‚Äù. We can now parse that data to retrieve the properties we need. The most important properties will the IDs of the parts that we are going to release ‚Äì these should already be synced with our system ‚Äì if not, we can create them from the data in the release package.\nSave Release Package Data The next step is to save the properties of the release package to a corresponding object in our database. We need at least the ID of the release package so we can later release it automatically from the third-party application. In this case I‚Äôm storing other properties that came from the release candidate such as release name and description.\nMost of this code deals with retrieving values from the release package and storing them as a new release object in the database. Additional values are associated with the part in the PLM system. In a typical production scenario this code would interface with the PLMs workflow capabilities and possibly kick off a release or change process in that system. For our basic example we are storing values from Onshape with our items and setting a state on the part so that users can see that the part is pending release and take actions required.\nAt this point in time, Onshape does not care that the part is pending a release. The part in Onshape will remain in a pending state until it is released by the PLM system. As noted previously, we used a user setup in the system to specifically initiate the release, therefore no other users will receive notifications from Onshape with regards to release actions on this part.\nComplete the Release Once the release or change workflow has completed in the PLM system and all approvals have been received, the Part/Item will be in a released state in the PLM system. However, we must now update Onshape with the correct release status of the parts. It is important that Onshape data is in sync with the corresponding data in the PLM system for reasons of data integrity and the visual cues used within Onshape to identify a part as released.\nIn a typical scenario Onshape will be automatically updated once the workflow completes in the PLM system. In our use case we are simplifying the process by clicking a button to release the item. This will update the state of the part in our system and send a REST API call to Onshape to release the data in the release package (be it one part, an assembly with multiple parts, or drawings).\nThis code snippet updates the database with the released status of a part. Since we stored data from the release package in our database we now retrieve the ‚ÄúComment‚Äù property so that we can send an updated value to Onshape with the release.\nlet attrid = rp.props.find(ob =\u003e ob.name == ‚ÄúComment‚Äù);\nThe important line of code here is the REST API call to Onshape:\naxios.post(‚Äòhttps://cad.onshape.com/api/releasepackages/' + id + ‚Äò?wfaction=RELEASE‚Äô\nThe id provided here is the ID of the release package that we stored when the web hook was called at the beginning of the process. The ‚Äúwfaction‚Äù argument indicates that the workflow action in Onshape should be to release the data associated with this release package.\nIn this example we are also updating the release comments in Onshape, for this reason we required the property ID of the Comment field ‚Äì which we also previously stored in our release object in the database.\nFigure 45 - Release completed automatically in Onshape\nFigure 46 - Release comments Updated from third-party system\n","categories":"","description":"","excerpt":"This tutorials builds off the Sync Data and Metadata tutorial. Please ‚Ä¶","ref":"/docs/tutorials/releases/","tags":"","title":"Sync Releases and Revisions"},{"body":"This tutorials builds off the Sync Releases and Revisions tutorial. Please complete that one before starting on this one.\nIt‚Äôs clear by now that Onshape doesn‚Äôt use files to store its data, instead it is a data driven solution that is always up to date. Files are a snapshot in time that provide a view of the design at a specific point in time - such as at a release or version. A new file is required for each ‚Äúsnapshot‚Äù and managing these files can get quite cumbersome. However, there are situations that require that files be generated from the Onshape data.\nIn general, we want files to be generated at defined points of time and within the context of a business process ‚Äì such as a release process. The derived file could be a format such as a PDF of the drawing that is generated following the successful release of the data. Also, a common requirement is to generate STEP files or JT files that can be used in 3D Printing or viewers embedded in PLM solutions. Regardless of the use case Onshape has very good export capabilities for many different file formats.\nThis business case examines how to automatically generate files derived from the Onshape data. The process described here can be plugged into many different use cases. In this specific example we are plugging the translation use case into the Release Business case just after the release is completed in the third-party application and Onshape is updated. Since we already have all the relevant ID information for the parts to translate from the release package data, we can directly call the translation APIs after receiving notification that the release was successfully executed in Onshape.\nOverview Once we have received an HTTP 200 status from the call to Onshape to release the release Package, we can proceed with the translation. The reason why we may want to wait till the release has successfully completed could be for several reasons:\nWe are generating a PDF of the drawing and want the ‚ÄúIn Progress‚Äù watermark removed, and the title block updated with release information\nWe are generating files for 3D printing or for sending to a vendor to manufacture and we only want to send released data\nWe can now make an API call to Onshape. In both the following cases we must pass the document Id, the version Id and element Id ‚Äì all values that were available in the release package. Other values are dependent upon your specific use case and can be referenced in https://cad.onshape.com/glassworks/explorer/#/PartStudio/createPartStudioTranslation\nFor Assembly translation we can POST to :/api /assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations.\nFor Parts we can POST to: /api/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations\nThree variables of importance are returned from the API call to translate: requestState, id (of the translation) and resultExternalDataIds. We should store or keep this data in memory until the translation is completed. Depending upon the requestState there might be additional data available in the response.\nWe can now periodically ping the translation web service with the id retrieved in the last step. Using the GET call to /api/translation/{id} we will receive one of three responses in the requestState:\nDONE\nACTIVE\nFAILED\nDepending on the response we can either continue to periodically ping the translation service if we received ACTIVE\nNotify the user of a failed translation attempt if we received a FAILED response\nMake a call to Onshape to GET the translated file if we received a DONE response. To retrieve the translated file make a GET request to /api/documents/d/{documentId}/externaldata/{externalDataId}\nThe file can now be stored in your third-party system or stored to an external drive depending upon your specific use case.\nImplementation As use cases go, this is a very straightforward process. The only complexity here is deciding how to receive the notification from Onshape that the translation has completed. There are several ways of implementing this including using a webhook to notify us when the translation completes. In the examples here I will show both the webhook methodology as well as pinging Onshape with a status request every couple of seconds. The status request can be initiated from the client through an AJAX call or, as in the example I use here, from the server.\nIn our example I have added a button to the interface of my third-party system that enables me to request a translated file. In this use case I have hard coded that the resulting file should be a STEP file ‚Äì in a production ready implementation, we would expect that one or more formats are available and possibly selected by the user. In addition, a production ready implementation might have automated the translation for whenever a part is released. Other considerations for automation might include identifying what is being released. I.e. if it‚Äôs a part then translate to STEP, if it‚Äôs a Drawing then translate to PDF, etc. These are all very common use cases.\nInitiate the Translation The code snippet shown here is fairly straightforward. First it gets the ID of the part that was sent from the client, it then uses that ID to retrieve the part from the database. The part stored in our database already has all the required values to successfully communicate with Onshape, such as the document ID, the workspace ID and the element ID ‚Äì all these values are used in the translation request.\nIn the body of the request we can see some of the required values that define how the part is to be translated to STEP. In this case I have only included the minimum required key pairs for this translation.\nThe REST API call to translate an Onshape element returns an object that includes the translationId ‚Äì this is the value that will be used to ping Onshape and request the status of the translation.\nPing Onshape for Translation In this code snippet I have simplified things by including a function that waits for a second and then pings Onshape again, It will continue pinging Onshape until it receives back a status that is not ‚ÄúACTIVE‚Äù. Once the status returned is anything except ‚ÄúACTIVE‚Äù it returns the resulting object back to the client.\nThe id used here is the translationId retrieved from the result object when the translation was initiated.\nOnce the requestState is changed, this will indicate that the translation has completed either with a FAIL or a DONE status. Depending on the result we can define our logic on the client appropriately.\nThe following shows the object returned to the client from the translation REST API. Note that the requestState is now set to ‚ÄúDONE‚Äù,, meaning that the translation has completed successfully.\nWith this data we can now request the file directly from Onshape. The ID that we need to use to retrieve the file is the ‚ÄúresultExternalDataIds‚Äù. Note that this is an array of values ‚Äì since it makes sense that we might be translating more than one part.\nRetrieve Translated File With the resultExternalDataIds we can now retrieve the translated file from Onshape. The following code snippet does exactly this.\nThe Onshape REST API\nhttps://cad.onshape.com/api/d/' + did + ‚Äò/externaldata/‚Äô + id\nretrieves the translated file ‚Äì in this case the ID is resultExternalDataIds[0] value.\nOnce this is completed, we use the response to save the file directly to our server where the application is hosted. Finally, I‚Äôm sending a JSON object to the client that provides a direct link to the file that is now hosted on our server.\nThe client can then request the translated file from our server, even though this is a function of the server and not related to Onshape, I have included a code snippet here that will send the file to the client.\nIn our sample implementation Once the translation has completed successfully I display a link to the translated file that calls the ‚Äúgetfile‚Äù endpoint shown above.\nClicking the link will cause the file to be downloaded as shown here.\nDefine Translation Webhooks As we mentioned at the beginning of this section there is more than one way to receive notification back from Onshape that the translation has completed. We can also define a webhook that will notify us once the translation completes. The drawback with this methodology is that the webhook must be created for each translation and then deleted.\nA complete example of this can be found at: https://github.com/onshape-public/app-gltf-viewer/blob/main/services/webhook-service.js\nThe following function is used in this application to define the webhook:\nThe following line would call this function once the user requests to initiate a translation.\nWebhookService.registerWebhook(req.user.accessToken, req.session.passport.user.id, did)\nFinally the endpoint registered with the webhook could be defined as follows:\nIn this case once the translation is completed, this endpoint receives a notification. If the event is equal to\nonshape.model.translation.complete\nWe can assume that the translation has completed and we can unregister the webhook and retrieve the translated file.\nThe complete sample including it setup and deployment can be found at: https://github.com/onshape-public/app-gltf-viewer\n","categories":"","description":"","excerpt":"This tutorials builds off the Sync Releases and Revisions tutorial. ‚Ä¶","ref":"/docs/tutorials/derivative/","tags":"","title":"Generate Derivative Files"},{"body":"In this example, you will create a custom web page (as shown in the image below) that is displayed in the right-hand fly-out panel. This interface displays metadata pulled from a third-party system when a part in Onshape is selected. This interface can also update metadata in Onshape through the Update functionality.\nYou can follow along with the steps below with this video: Define the extension This tutorials builds off the Generate Derivative Files tutorial. Please complete that one before starting on this one.\nNavigate to the Developer portal from https://dev-portal.onshape.com.\nClick OAuth applications in the left menu.\nSelect your application, and the click the Extensions tab. Click the Add Extension button on the top right.\nSelect Element Right Panel. Next, define the context. The context defines what parameters can be sent from Onshape to the application. Some basic parameters are automatically sent with any context, additional information can be passed to our application, depending on the context selected. Click the Selected part option. This sends the partId and partNumber to the application, along with the documentId, elementId, and the workspaceOrVersionId.\nIn the Action URL field, fill in the URL of the page to load in the right element panel. The parameters can be added as arguments (variable that get replaced with real values when the page is loaded from Onshape).\nhttps://ourserver.com/bom?documentId=${documentid}\u0026elementId=${elementid}\u0026partId={$partId}\u0026partNumber={$partNumber} Finally, select an icon for the extension. This will appear on the tab that opens the right element panel.\nYou have now defined the extension, and it will appear in the Onshape interface.\nCall a page in the extension The following code snippet shows how to use your previous definition to pull data from the third-party application and send it to the web page:\n//https://myserver.com/bom?documentId=${documentId}\u0026elementId=${elementId}\u0026 //partId=${partId}\u0026partNumber=${partNumber} app.get('/bom', (req, res) =\u003e { if (req.query.partNumber !== '${partNumber'}) { partController.getPartsList(req.query.partNumber).then((parts) =\u003e { catController.getCatById(parts.Category).then((cat) =\u003e { res.render('bomview', { parts: parts, cat: cat }) }) }) } else { res.render('bomview', { parts: { \"_id\": 0 }, cat: { \"_id\": 0 } }) } }) This code checks to see if the partNumber parameter was actually populated (i.e., that a part number was defined for the selected part). If defined, you can use the part number to retrieve information about the selected part from our third-party application.\nIf the part number isn‚Äôt defined, you can send an alert to the web page to notify the user that a part number must be defined to use this web page.\nYou can also use the document ID, the element ID, and the Part ID to retrieve the correct part as long as they are stored with the part in your application.\nUse the extension In Onshape, load a document. You will see your icon embedded in the location you chose for you extension.\nSelect a part in a Part Studio, and click the icon to open the extension application: If the part you selected has not yet been synced with your third-party application, no part number has been generated, and the system can‚Äôt find a corresponding object in our database.\nWhen you select a part that has been synced, and a part number has been generated, you will see the expected result:\nSince the context you selected for this application extension was Selected Part, a part must be selected to load anything in the extension. If no part is selected, you will see a notification similar to the following:\n","categories":"","description":"","excerpt":"In this example, you will create a custom web page (as shown in the ‚Ä¶","ref":"/docs/tutorials/createextension/","tags":"","title":"Create an Extension"},{"body":"The GLTF Viewer is a sample application that demonstrates:\nHow to fetch a glTF representation of an Onshape model How to create an app that runs as a tab inside an Onshape document OAuth2 authentication Use of REST APIs Use of document context The application is built using Express and is deployed on Heroku.\nRefer to the gltf-viewer-app README for instructions on running this sample app.\n","categories":"","description":"","excerpt":"The GLTF Viewer is a sample application that demonstrates:\nHow to ‚Ä¶","ref":"/docs/tutorials/gltf/","tags":"","title":"glTF Viewer"},{"body":"Onshape Help See the Onshape Help Docs at https://cad.onshape.com/help/Content (or https://\u003ccompanyName\u003e.onshape.com/help/Content for Enterprise accounts).\nContact Us You can contact the Onshape API Support team at api-support@onshape.com, or browse through our FAQs and troubleshooting tips below.\nFAQs What is the user experience of granting and revoking OAuth access? Once users have purchased the application from the App Store, they will start seeing actions and panel icons as described by the extensions. When they try to use these actions and panels, they will be prompted by an error message stating that they need to grant access first.\nThey can grant access by navigating to the ‚ÄòApplications‚Äô section under ‚ÄòMy Account‚Äô.\nUsers will have to grant 2 permissions. The first button called ‚ÄòOnshape access‚Äô will enable the application to make calls to the Onshape API. This will require the user‚Äôs Onshape credentials.\nThe second button calls ‚ÄòExternal access‚Äô and enables Onshape to make calls to the application API. This will require the user‚Äôs credentials in the application. Both modes of access use OAuth, so credentials are not stored in the other system.\nIf the access is revoked at any time, the actions and panels will ask the user to re-authenticate from the ‚ÄòApplications‚Äô page. Access may be revoked manually from Onshape or the application, or because a new version is installed that requires a different scope.\nWho can get access to my app, and how? Applications with extensions are only available to people who have been explicitly granted this permission in Onshape. Users who have been given this permission will be able to go to the App Store and purchase the application. There is no change to this process from earlier. They will then be able to grant access to the application as described in the previous question.\nDo not publish your application if it contains extensions in the App Store for all users. Other users (who have not been granted permission) will not be able to see the extensions and will have a bad experience.\nHow is my application informed about selection changes in the Onshape UI? Let‚Äôs take the case where your application has an extension that is showing some information in the document info panel that is based on document selection. As the selection changes, the action URL passed to the extension will change (based on parameterization). The new action URL will be loaded into the IFrame for the extension, and the application page will reload. We are adding support for post messages to reduce loading overhead in the future.\nWhat is the timeout for the action_url of extensions? Is it configurable? Timeout set for each GET or POST request set as action_url of an extension is 180 seconds. Timeout is not configurable.\nWhat changed when my legacy application migrated to extensions? If you had created a desktop or connected ckoud app, nothing has changed.\nIf you had created an integrated cloud app, the following changes have been made to the app.\nThe IFrame URL has been changed to the OAuth URL. This is now invoked from the user‚Äôs application setting page to grant OAuth access. A redirect URL is passed along with the call as a query parameter named ‚ÄòredirectOnshapeUri‚Äô. You will need to modify your code to redirect to this URL if it is present. A new tab extension is automatically created for your applications. The target URL for this extension is the earlier IFrame URL. This should continue to work as earlier. The tab icon will also be populated into the extension from the earlier application icon and should work as earlier. ","categories":"","description":"","excerpt":"Onshape Help See the Onshape Help Docs at ‚Ä¶","ref":"/docs/help/","tags":"","title":"Get Help"},{"body":"rel-1.184 - released 2024-07-19 Updated API version to V8, (https://cad.onshape.com/api/versions), A new microversion will not be created when a document restore operation results in a no-op. Remove inconsistencies in assembly definition endpoint (/assemblies/d/[did]/[wvm]/[wvmid]/e/[eid]) related to configuration parameters Update all translation endpoints (POST : ../translations) to include new request property useFileNameToSetSinglePartName Update all revision endpoints (GET : /revisions/..) to include response property canChangeType (supporting new admin option to change type part, assembly, file, etc) Update GET : /users/[:uid]/settings endpoint to include responses for highlightLaminarEdges and perspectiveModeOn for default status rel-1.183 - released 2024-06-28 Added new V7 version to the api (https://cad.onshape.com/api/versions) Updated GET : V7/partstudios/d/[did]/[wvm]/[wvmid]/e/[eid]/sketches to return fully defined status (UNDERDEFINED, WELL_DEFINED, OVERDEFINED, UNKNOWN) Updated GET : V7/partstudios/d/[did]/[wvm]/[wvmid]/e/[eid]/sketches vectors are now maps instead of arrays, and may be BTVector2d or BTVector3d depending on the output3D parameter Updated GET : V7/partstudios/d/[did]/[wvm]/[wvmid]/e/[eid]/sketches to use more consistent naming: Fields sketch -\u003e name sketchId -\u003e featureId transformMatrix -\u003e sketchMatrix featuresUsed -\u003e featuresUsingSketch geomEntities -\u003e entities Updated GET : /variables endpoint to return variable description when variable is set through custom feature Updated POST : /webhooks endpoint to default to isTransient = true if not specified (auto cleanup) Updated descriptions for Assembly, Documents, Metadata, Parts, Part Studios, Revisions, Variables and Versions enddpoints rel-1.182 - released 2024-06-07 Updated descriptions for webhooks endpoints rel-1.181 - released 2024-05-17 Update Document, Assembly, Blob, Drawing and Part Studio translation POST endpoints to have a new request body property occurancesToExport Update to /elements endpoint summary and descriptions in Glassworks Updated documentation for webhooks (https://onshape-public.github.io/docs/app-dev/webhook/) rel-1.180 - released 2024-04-26 New Drawings sample application (public repo: https://github.com/onshape-public/onshapedrawingjson) New API Guide section for response codes (https://onshape-public.github.io/docs/api-adv/errors/) Support export of tables in JSON of Drawings GET : /appelements/[:did]/[:wvm]/[:wvmid]/e/[:eid]/views/[:viewid]/jsongeometry Update Assembly, Blob, Drawing and Part Studio translation POST endpoints to have a new request body property resolution rel-1.179 - released 2024-04-05 New drawing views list endpoint GET : /appelements/[:did]/[:wvm]/[:wvmid]/e/[:eid]/views New drawing view endpoint GET : /appelements/[:did]/[:wvm]/[:wvmid]/e/[:eid]/views/[:viewid]/jsongeometry New updated features endpoint documentation Updated glassworks for all metadata endpoints to reference developer documentation Added description of output to schema for Metadata APIs Updated translation endpoints with new request property specifyMaterialData rel-1.178 - released 2024-03-15 Update Part Studio translation POST endpoint to have a new request body property importMaterialDensity Update active workflow endpost GET: /workflow/active to have a new response property hasInactiveCustomWorkflows Updated authorization (OAuth2 and BasicAuth) for publication endpoints Various updates to descriptions of data types and query parameters Fixed delete publication endpoint (HTTP::200 now removes publication) rel-1.177 - released 2024-02-23 Updated translation endpoints with new request property useIGESImportPostProcessing Updated translation endpoints with modified request property stepParasolidPreprocessingOption Updated descriptions for metadata | releasepackages for property propertyOverrideStatus rel-1.176 - released 2024-02-02 New create publication endpoint POST : /publications New update publication endpoint POST: /publications/[:pid] New delete publication endpoint DELETE: /publications/[:pid] New create publication item endpoint POST : /publications/item New update publication item endpoint POST: /publications/item/[:iid] New delete publication item endpoint DELETE: /publications/item/[:iid] rel-1.175 - released 2024-01-12 Exclude suppressed sub assemblies from rootAssembly occurrences for GET: /assemblies/d/[did]/[wvm]/[wvmid]/e/[eid] rel-1.174 - released 2023-12-15 Add microversion id the extension url [$microversionId] Updated translation endpoints with new request property pdfVersion Fixed issue with bodydetails endpoints always returning isInner and isOuter the same Update all endpoints for bodydetails | tessellatededges | tessellatedfaces | featurescript to include new response body errorEnum: errorEnum BODY_DRAFT_STRAY_NONMITER_EDGES MASS_PROPERTY_FACES_NOT_COPLANAR PARAMETER_VALUE_INVALID SHEET_METAL_CHAMFER_NO_TANGENT_BASED CHAMFER_DIRECTION_OVERRIDE_NO_EFFECT FILLET_CHAMFER_UNSUPPORTED CHAMFER_HELD_BACK SWEEP_BAD_LOCK_DIRECTION SHEET_METAL_COUNTER_HOLE_UNSUPPORTED SWEEP_SELECT_DIRECTION Update all endpoints for bodydetails | tessellatededges | tessellatedfaces | featurescript to include new property imageForeignId Support sending a list of emails to POST : /classrooms/[cid]/members rel-1.173 - released 2023-11-28 Update all classroom endpoints (/classrooms/) to support OAuth Add description of output to schema for getAssemblyShadedViews API rel-1.172 - released 2023-11-06 Update all endpoints for bodydetails | tessellatededges | tessellatedfaces | featurescript to include new response body errorEnum: errorEnum FIT_TOLERANCE_LIMITS_NOT_FOUND FIT_TOLERANCE_SIZE_TOO_LARGE_ISO FIT_TOLERANCE_SIZE_TOO_LARGE_ANSI OFFSET_WIRE_SHEET_CREATION_FAILED REPLACE_FACE_SHEET_SMALL REPLACE_FACES_NOT_ADJACENT SHEET_METAL_HOLE_REBUILD_FAILED CPLANE_TANGENT_INPUT CPLANE_TANGENT_SELECT_REFERENCE CNE_TANGENT_PLANE_INVALID CPLANE_TANGENT_POINT_INVALID REPLACE_FACES_NOT_SAME_BODY MUST_USE_DEFAULT_RADIUS_WITH_FACE_BEND CANNOT_RIP_A_FACE_BEND CANNOT_MAKE_A_FACE_BEND_TANGENT References to API Guide for endpoint descriptions in Glassworks rel-1.171 - released 2023-10-13 Update all translation POST endpoints to have a new request body properties hideInspectionItems and textOption Replaced GET : /releasepackages/companyreleaseworkflow | /workflow/active property canCurrentUserSyncVersionsToArena with canCurrentUserSyncStandardContentToArena Updated GET and POST : /tabletemplates endpoint with new response property valueType Comprehensive update to remaining endpoint summary and descriptions in Glassworks rel-1.170 - released 2023-09-22 New appelements delete subelement endpoint DELETE : /appelements/d/[did]/[wvm]/[wvmid]/e/[eid]/content/subelements New company add new user endoint POST : /companies/[cid]/users New company update user endoint POST : /companies/[cid]/users/[uid] New company delete user endoint DELETE : /companies/[cid]/users/[uid] Comprehensive update to remaining endpoint summary and descriptions in Glassworks rel-1.169 - released 2023-09-01 Comprehensive update to most endpoint summary and descriptions in Glassworks Update all translation endpoints to include new property importAppearances Update POST : /partstudios/d/[did]/[wvm]/[wvmid]/e/[eid]/featurescript has a new property expressionErrorInfo Update GET and POST : /releasepackages/[rpid] property workflow/actions has a new enum value REASSIGN_TASK rel-1.168 - released 2023-08-11 Deprecated POST : /api/drawings/create -\u003e Replaced with POST : /api/drawings/d/[did]/w/w/[wid]/create Update GET : /api/documents endpoint has a new property publishedVersion Update GET and POST : /api/releasepackages/[rpid] has a new property syncedWithPLM rel-1.167 - released 2023-07-21 Update glTF translation endpoints to use new field useGltfCompression (bool) Update STEP translation endpoints to use new field stepParasolidPreprocessingOption (0-None, 1-Advanced, 2-Automatic, 3-Basic) Update GET : /api/documents | /api/documents/[did] | /api/companies/[cid]/documentsbyname to include new field forceExportRules rel-1.165 - released 2023-06-12 Support partId array string for GET : /api/partstudios/bodydetails endpoint for the option of getting a subset of parts from a partstudio (empty = all parts) rel-1.163 - released 2023-04-28 Update documentation for the Documents endpoint (/api/documents) Update Releasepackage endpoint GET : /api/releasepackage to include type to understand action (ie. Approve vs Reject) Update API to V6 - Fix a bug in how updating the JSON tree of an app element in a transaction returns the diff rel-1.162 - released 2023-04-12 New Assembly modify endpoint POST : /api/assemblies/d/{did}/w/{wid}/e/{eid}/modify for bulk deletion and suppression of instances and features rel-1.161 - released 2023-03-20 New BOM templates endpoint (/api/tabletemplates) Support POST /api/webhooks parameter isTransient = true to specify auto cleanup after a set number of days rel-1.160 - released 2023-02-24 Support configuratons for GET : /api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features Remove deprecated GET : /api/elements/:emid Remove deprecated GET and POST : /api/elements/d/:did/[wvm]/:wvmid/e/:eid/metadata Deprecated GET and POST : /api/parts/standardcontent/d/:did/v/:vid/e/:eid/[cu]/:cuid/partid/:pid/metadata Deprecated GET and POST : /api/parts/d/:did/[wvm]/:wmvid/e/:eid/partid/:pid/metadata rel-1.158 - released 2023-01-11 New example values in Glassworks API documentation rel-1.155 - released 2022-11-01 Support Parasolid binary (x_b) exports rel-1.154 - released 2022-10-10 Add face color, hidden state and type of composite to body details endpoint rel-1.152 - released 2022-08-30 Support more parameters to filter the partstudio endpoint rel-1.147 - released 2022-05-16 Support global tree node endpoint for impacting recently opened filter rel-1.146 - released 2022-04-25 Support API versioning Return ‚ÄònodeId‚Äô when adding or updating an AppElement rel-1.145 - released 2022-04-05 Fixed issue where assembly feature errors were missing rel-1.140 - released 2021-12-15 Add mass properties for assemblies rel-1.139 - released 2021-11-15 Relax casing search in Glassworks (Swagger client) BOM and Metadata API endpoint responses now matched rel-1.138 - released 2021-10-25 Updated webhook documentation rel-1.135 - released 2021-8-20 Webhook events for Enterprise SSO configuration changes rel-1.134 - released 2021-07-30 Support comment events (add, update, delete) for the web-hook endpoint rel-1.131 - released 2021-06-01 Add synchronous glTF/gLB endpoint for assemblies rel-1.128 - released 2021-03-29 Support face color for export of glTF/gLB Add document API endpoint for comments rel-1.127 - released 2021-03-08 Add translation option dtkPeriodicFacesPolicy=3 for CATIA parts rel-1.126 - released 2021-02-12 Add GLTF and GLB accepts option to the tessellation APIs rel-1.125 - released 2021-01-25 Add ‚Äògood/better/best‚Äô quality query parameters to tessellation endpoint rel-1.122 - released 2020-11-18 Enforce OAuth endpoint rate limiting Add release package action/transition based webhooks rel-1.119 - released 2020-09-15 Add rollback bar to EvalFeatureScript endpoint rel-1.118 - released 2020-08-25 PartStudio GET support for sketch constraints in features endpoint rel-1.116 - released 2020-07-15 Specify starting elements to create document endpoint rel-1.114 - released 2020-06-03 Project endpoints rel-1.113 - released 2020-05-11 Output GLTF files for an element (tab) rel-1.111 - released 2020-03-31 Support ownership transfer for teams rel-1.110 - released 2020-03-09 Add support for exploded views rel-1.108 - released 2020-01-29 Drawings endpoints for create 4 view, get view geometry and view definition rel-1.102 - released 2019-09-11 Added webhook events for release management Added webhook event for document version creation rel-1.99 - released 2019-07-08 Assembly BOM API support for items rel-1.96 - released 2019-05-03 Part Studio compare endpoint rel-1.93 - released 2019-03-01 Webhook subscriptions for a company rel-1.86 - released 2018-09-28 Export Drawings to DXF, DWG and PDF ","categories":"","description":"","excerpt":"rel-1.184 - released 2024-07-19 Updated API version to V8, ‚Ä¶","ref":"/docs/changelog/","tags":"","title":"Changelog"},{"body":" Welcome to the Onshape Developer Documentation. You can find resources here for developing applications that integrate with Onshape. The Onshape Developer Documentation consists of four parts:\nAPI Guide API Explorer Developer Portal Sample Code If you are new to Onshape development, start with the API Guide.\nGuides API Intro Intro to Onshape APIs API Explorer Architecture Quick Start Why Onshape? Authentication API Keys OAuth API Guides Configurations Drawings Features Import \u0026 Export Metadata Response Codes App Development Intro to App Development Client Messaging Extensions Structured Storage Webhooks Sample Apps Extensions glTF Viewer App Store Intro to the App Store Launch Checklist Testing Guidelines Quality Considerations ","categories":"","description":"","excerpt":" Welcome to the Onshape Developer Documentation. You can find ‚Ä¶","ref":"/","tags":"","title":"Onshape Developer Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Onshape Developer Documentation â€“ Welcome to the Developer Portal</title><link>https://onshape-public.github.io/docs/</link><description>Recent content in Welcome to the Developer Portal on Onshape Developer Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 Jun 2022 08:24:05 -0400</lastBuildDate><atom:link href="https://onshape-public.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: API Keys</title><link>https://onshape-public.github.io/docs/apikeys/</link><pubDate>Mon, 18 May 2020 20:20:41 -0400</pubDate><guid>https://onshape-public.github.io/docs/apikeys/</guid><description>
&lt;h1 id="using-api-keys-with-onshape">Using API Keys with Onshape&lt;/h1>
&lt;h3 id="why-api-keys">Why API Keys?&lt;/h3>
&lt;p>API keys are useful for small applications meant for personal use, allowing developers to avoid the overhead of the OAuth workflow. Creating an app is very easy with API keys: create an API key with the Developer Portal, set up a function to build your API key header as in the samples, and make your API calls! There&amp;rsquo;s no need to deal with OAuth redirects or things like that.&lt;/p>
&lt;p>We&amp;rsquo;ve moved over to using API keys for authenticating requests instead of using cookies for several reasons.&lt;/p>
&lt;ol>
&lt;li>Security: Each request is signed with unique headers so that we can be sure it&amp;rsquo;s coming from the right place.&lt;/li>
&lt;li>OAuth: The API key system we&amp;rsquo;re now using for HTTP requests is the same process developers follow when building full-blown OAuth applications; there&amp;rsquo;s no longer a disconnect between the two.&lt;/li>
&lt;/ol>
&lt;p>Once you create an API key, it will only be valid in the stack on which it was created. An API key created on the partner stack, for example, will not function on the production stack.&lt;/p>
&lt;h3 id="questions-and-concerns">Questions and Concerns&lt;/h3>
&lt;p>If you need information or have a question unanswered in this documentation, feel free to chat with us by sending an email to &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a> or by checking out the &lt;a href="https://forum.onshape.com" target="_blank">forums&lt;/a>. If you are a member of the DevPartners group (see the Development help page for information) more detailed instructions and code examples are in the apikey sample repo.&lt;/p>
&lt;h3 id="working-with-api-keys">Working with API Keys&lt;/h3>
&lt;p>Read the following and you&amp;rsquo;ll be up and running with using API keys in your application:&lt;/p>
&lt;h5 id="instructions">Instructions&lt;/h5>
&lt;ol>
&lt;li>
&lt;p>Get the Developer role for your Onshape account by contacting us at &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a>. You should already have this since you&amp;rsquo;re in the Developer Portal already.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create and manage your API key pairs from the Developer Portal; note that the secret will only be displayed once! Keep it somewhere safe.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Now that you have a key pair, see &lt;a href="#generating-a-request-signature">below&lt;/a> for information on signing your requests to use our API.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Once you have your access key and secret, you will want to avoid giving others access to them since they&amp;rsquo;re tied directly to your personal Onshape account. Think of your API key as a username and password pair. Therefore, you should avoid placing them directly in the code for your application, especially if others might see it. The samples use a separate configuration file that you yourself will need to create that will contain this information, but there are other ways to keep the access key and secret safe, like setting them as environment variables.&lt;/p>
&lt;h5 id="scopes">Scopes&lt;/h5>
&lt;p>There are several scopes available for API keys (equivalent to OAuth scopes):&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;OAuth2Read&amp;rdquo; - Read non-personal information (documents, parts, etc.)&lt;/li>
&lt;li>&amp;ldquo;OAuth2ReadPII&amp;rdquo; - Read personal information (name, email, etc.)&lt;/li>
&lt;li>&amp;ldquo;OAuth2Write&amp;rdquo; - Create and edit documents / etc.&lt;/li>
&lt;li>&amp;ldquo;OAuth2Delete&amp;rdquo; - Delete documents / etc.&lt;/li>
&lt;li>&amp;ldquo;OAuth2Purchase&amp;rdquo; - Authorize purchases from account&lt;/li>
&lt;/ul>
&lt;h5 id="generating-a-request-signature">Generating A Request Signature&lt;/h5>
&lt;p>To ensure that a request is coming from you, we have a process for signing requests that you must follow for API calls to work. Everything is done via HTTP headers that you&amp;rsquo;ll need to set:&lt;/p>
&lt;ol>
&lt;li>&lt;em>Date&lt;/em>: A standard date header giving the time of the request; must be accurate within &lt;strong>5 minutes&lt;/strong> of request. Example: &lt;code>Mon, 11 Apr 2016 20:08:56 GMT&lt;/code>&lt;/li>
&lt;li>&lt;em>On-Nonce&lt;/em>: A string that satisfies the following requirements (see the code for one possible way to generate it):
&lt;ul>
&lt;li>At least 16 characters&lt;/li>
&lt;li>Alphanumeric&lt;/li>
&lt;li>Unique for each request&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>Authorization&lt;/em>: This is where the API keys come into play. You&amp;rsquo;ll sign the request by implementing this algorithm:
&lt;ul>
&lt;li>&lt;strong>Input&lt;/strong>: Method, URL, On-Nonce, Date, Content-Type, AccessKey, SecretKey&lt;/li>
&lt;li>&lt;strong>Output&lt;/strong>: String of the form: &lt;code>On &amp;lt;AccessKey&amp;gt;:HmacSHA256:&amp;lt;Signature&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;strong>Steps to generate the signature portion&lt;/strong>:
&lt;ol>
&lt;li>Parse the URL and get the following:
&lt;ol>
&lt;li>The path, e.g. &lt;code>/api/documents&lt;/code> (no query params!)&lt;/li>
&lt;li>The query string, e.g. &lt;code>a=1&amp;amp;b=2&lt;/code>
&lt;ul>
&lt;li>NOTE: If no query paramaters are present, use an empty string&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Create a string by appending the following information in order. Each field should be separated by a newline (&lt;code>\n&lt;/code>) character, and the string must be converted to lowercase:
&lt;ol>
&lt;li>HTTP method&lt;/li>
&lt;li>On-Nonce header value&lt;/li>
&lt;li>Date header value&lt;/li>
&lt;li>Content-Type header value&lt;/li>
&lt;li>URL pathname&lt;/li>
&lt;li>URL query string&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Using SHA-256, generate an &lt;a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" target="_blank">HMAC digest&lt;/a>, using the API secret key first and then the above string, then encode it in Base64.&lt;/li>
&lt;li>Create the &lt;code>On &amp;lt;AccessKey&amp;gt;:HmacSHA256:&amp;lt;Signature&amp;gt;&lt;/code> string and use that in the Authorization header in your request.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>Below is an example function to generate the authorization header, using Node.js&amp;rsquo;s standard &lt;code>crypto&lt;/code> and &lt;code>url&lt;/code> libraries:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">// ...at top of file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>&lt;span style="color:#00a">var&lt;/span> u = require(&lt;span style="color:#a50">&amp;#39;url&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">var&lt;/span> crypto = require(&lt;span style="color:#a50">&amp;#39;crypto&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* Generates the &amp;#34;Authorization&amp;#34; HTTP header for using the Onshape API
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} method - Request method; GET, POST, etc.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} url - The full request URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} nonce - 25-character nonce (generated by you)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} authDate - UTC-formatted date string (generated by you)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} contentType - Value of the &amp;#34;Content-Type&amp;#34; header; generally &amp;#34;application/json&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} accessKey - API access key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} secretKey - API secret key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @return {string} Value for the &amp;#34;Authorization&amp;#34; header
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">function&lt;/span> createSignature(method, url, nonce, authDate, contentType, accessKey, secretKey) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlObj = u.parse(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlPath = urlObj.pathname;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlQuery = urlObj.query ? urlObj.query : &lt;span style="color:#a50">&amp;#39;&amp;#39;&lt;/span>; &lt;span style="color:#aaa;font-style:italic">// if no query, use empty string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> str = (method + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + nonce + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + authDate + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + contentType + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urlPath + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + urlQuery + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span>).toLowerCase();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> hmac = crypto.createHmac(&lt;span style="color:#a50">&amp;#39;sha256&amp;#39;&lt;/span>, secretKey)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .update(str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .digest(&lt;span style="color:#a50">&amp;#39;base64&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> signature = &lt;span style="color:#a50">&amp;#39;On &amp;#39;&lt;/span> + accessKey + &lt;span style="color:#a50">&amp;#39;:HmacSHA256:&amp;#39;&lt;/span> + hmac;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">return&lt;/span> signature;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Some API endpoints return 307 redirects. You must generate an Authorization header for the redirect as well, but please note that the server portion of the URL might be different, the redirect URL may contain query parameters that must be encoded in the Authorization header, etc. Please see the samples for examples.&lt;/p>
&lt;h3 id="api-keys-and-oauth">API keys and OAuth&lt;/h3>
&lt;p>Our API key workflow differs from our OAuth workflow in one important characteristic: an API key allows a &lt;em>user&lt;/em> (specifically, a developer) to make requests, while OAuth allows an &lt;em>application&lt;/em> to make requests on behalf of the user. We require the OAuth workflow for apps in the Onshape App Store, so if you develop an app using API keys and want to distribute it through the App Store, you will need to change to OAuth. Please see our OAuth sample apps for examples of how to make OAuth work (onshape/app-bom is a great place to start). The good news is that we&amp;rsquo;ve structured API keys to work very similarly to OAuth in the operation of your app. While you will need to build your Authorization header differently (and set up redirects and signins as in the onshape/app-bom sample), the API calls themselves will work the same in both versions, provided that the API key and the OAuth app have the same scopes. An API key with the OAuth2Read and OAuth2Write scopes will have the same access to the same API endpoints as an OAuth application with the OAuth2Read and OAuth2Write scopes, for example. (The only differences are when calling API endpoints relating to the OAuth application itself, since an API key request obviously does not come from an OAuth application.)&lt;/p></description></item><item><title>Docs: API Overview</title><link>https://onshape-public.github.io/docs/apioverview/</link><pubDate>Mon, 18 May 2020 20:25:28 -0400</pubDate><guid>https://onshape-public.github.io/docs/apioverview/</guid><description>
&lt;h2 id="getting-started-with-the-onshape-rest-api">Getting Started with the Onshape REST API&lt;/h2>
&lt;p>This document describes APIs that will allow partners to interact with the Onshape system.&lt;/p>
&lt;p>Please address questions to &amp;quot; &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a>&amp;quot; for the fastest response.&lt;/p>
&lt;blockquote>
&lt;p>NOTE The API is still under development. Many of the previous interfaces have been deprecated in favor of a more consistent API. All previously described interfaces should continue to work, but we reserve the right to remove support for them. Please update to use the new forms as described in the Glassworks API Explorer.&lt;/p>
&lt;/blockquote>
&lt;h2 id="quick-start">Quick Start&lt;/h2>
&lt;ol>
&lt;li>Use the Glassworks API Explorer to see detailed documentation of the Onshape API. To use the API Explorer, subscribe in the Appstore at &lt;a href="https://appstore.onshape.com" target="_blank">&lt;a href="https://appstore.onshape.com">https://appstore.onshape.com&lt;/a>&lt;/a>, then add the Explorer to a document using the plus menu.&lt;/li>
&lt;li>Sample applications are available at &lt;a href="https://github.com/onshape-public" target="_blank">&lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>&lt;a>.&lt;/li>
&lt;li>Request access to the private forum for API and App Store development. Send an email to Lou Gallo (&lt;a href="mailto:lgallo@onshape.com">lgallo@onshape.com&lt;/a>) requesting access to the partner forum. Include the email address you use for signing in to the Onshape production server (cad.onshape.com).&lt;/li>
&lt;/ol>
&lt;p>Create your own application and let us know how it goes. We look forward to your questions, comments, and a demo of what you build!&lt;/p>
&lt;h2 id="onshape-appstore">Onshape Appstore&lt;/h2>
&lt;p>Onshape will make applications available through the Onshape Appstore. The Appstore will be actively promoted to users, making it easy for users to find, purchase and use third party applications. Click &lt;a href="https://appstore.onshape.com" target="_blank">&lt;a href="https://appstore.onshape.com">https://appstore.onshape.com&lt;/a>&lt;/a> to view the Onshape Appstore.&lt;/p>
&lt;h2 id="the-lifecycle-of-an-application">The Lifecycle of an Application&lt;/h2>
&lt;p>Onshape expects that typical applications will follow this timeline:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Phase&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Description&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Initial development&lt;/td>
&lt;td>Development will take place on Onshape&amp;rsquo;s Production stack - &lt;a href="https://cad.onshape.com">https://cad.onshape.com&lt;/a> your application is initially only visible to yourself and members of teams that you create an specify in the developer portal.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Alpha testing&lt;/td>
&lt;td>When an application is ready for early named-user testing, Onshape may be able to provide user accounts for named test users, or you can add your own users to the Visibility team for your application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Beta testing&lt;/td>
&lt;td>Once an application is ready for broader testing increase the number of users in the visiblity team. Additionally Onshape will work with you to complete the ready for release checklist.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Release&lt;/td>
&lt;td>Released applications will be promoted to public visibility on the Appstore (if appropriate) and become available for general use.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="how-your-program-interacts-with-onshape">How Your Program Interacts with Onshape&lt;/h2>
&lt;p>The primary APIs provided by Onshape are REST interfaces that are accessed over HTTPS. The client can be a web server or a desktop application (including command line tools such as curl). Onshape does not support use of the APIs directly from a browser client due to cross-domain scripting concerns.&lt;/p>
&lt;p>We anticipate that partner applications will interact with Onshape in three ways:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>File Exchange.&lt;/strong>
Onshape provides extensive import and export translation capabilities to interact with applications that can read or write a variety of file formats.&lt;/li>
&lt;li>&lt;strong>Live Link Integration.&lt;/strong>
Desktop or server applications can use REST calls to read information from the Onshape servers, and store information back. These applications can gain &amp;ldquo;cloud value&amp;rdquo; by using Onshape data management capabilities for sharing, versioning and durability.&lt;/li>
&lt;li>&lt;strong>In-Tab Integration.&lt;/strong>
Web server applications can create a tightly integrated experience within Onshape by using a combination of REST and client-side APIs to build a seamless interaction by interacting with users inside an Onshape tab.&lt;/li>
&lt;/ol>
&lt;p>The following diagram illustrates basic desktop integration and cloud integration architecture. The REST, WebHook and Client POST messages are documented in this and additional API documents.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/apioverviewimage00.png" alt="image">&lt;/p>
&lt;p>The Onshape Server Stack consists of a number of cooperating servers that provide the underlying support for the Onshape CAD experience. The Onshape servers are built with a variety of technologies, including Java and C++, database and message services, geometry and constraint management systems, and much more.&lt;/p>
&lt;p>Partner cloud applications can be written in any web framework. Onshape provides a set of samples in Github. Onshape is also planning to provide a library that simplifies desktop application development.&lt;/p>
&lt;p>The user interface code that runs in the Onshape browser client is written in Javascript.&lt;/p>
&lt;p>You may notice that this diagram does not illustrate the Onshape mobile clients for iOS and Android devices; the development of 3rd-party mobile applications for Onshape is beyond the scope of this document.&lt;/p>
&lt;h2 id="tools-and-samples">Tools and Samples&lt;/h2>
&lt;p>Onshape provides a set of sample applications and tools to assist third party development. These samples demonstrate how to use the API from a variety of environments, including desktop Windows applications, node.js servers, Windows Azure servers and more.&lt;/p>
&lt;p>The components of the sample applications written by Onshape are provided under the MIT License; applications may include other open source components as well.&lt;/p>
&lt;p>For access to samples and tools, please visit &lt;a href="https://github.com/onshape-public" target="_blank">&lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>&lt;/a>.&lt;/p>
&lt;h2 id="tools">Tools&lt;/h2>
&lt;p>Onshape provides Glassworks API Explorer - an application written using the Onshape API that offers REST documentation and a &amp;ldquo;try me&amp;rdquo; mode for experimenting with the REST interfaces. To use API Explorer, visit the Appstore, select the API Explorer app and click &amp;ldquo;Try for Free.&amp;rdquo; Then, add a new Application tab using the plus button:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/apioverviewimage01.png" alt="image">&lt;/p>
&lt;p>Select &amp;ldquo;Add Application&amp;rdquo; to create a tab with the Glassworks API Explorer.&lt;/p>
&lt;h2 id="sample-applications">Sample Applications&lt;/h2>
&lt;p>The easiest way to get started with the Onshape API is to look at the sample applications. Each sample application is provided as a Github repository. For access, go to &lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>. More samples will be made available over time. The current samples are:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Name&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Description&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>STL Viewer&lt;/td>
&lt;td>View the mesh of a model in a new tab within an Onshape document. This application is written in node.js, and the Readme file describes how to deploy the viewer to Heroku for hosting. The viewer demonstrates OAuth authentication, navigating parts in an Onshape model, and retrieving a tessellated mesh of an Onshape part.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://github.com/onshape-public/app-gltf-viewer">GLTF Viewer&lt;/a>&lt;/td>
&lt;td>Visualize GLTF data translated from an Onshape model. This is a Node.JS application, and the README provides instructions for deploying to Heroku. The GLTF viewer demonstrates OAuth authentication, navigating Elements and Parts in an Onshape model, triggering a translation and obtaining the resulting data, and registering, listening for, and un-registering webhooks.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BOM&lt;/td>
&lt;td>Create a Bill of Materials for an Onshape assembly. This application is written in node.js and includes documentation on Heroku deployment. The bom application demonstrates OAuth authentication, assembly navigation, metadata retrieval and shaded view generation.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>API Key&lt;/td>
&lt;td>A set of examples demonstrating the use of API Keys for Onshape authentication. This includes sample code for both Python and Node applications.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://github.com/onshape-public/app-windows-sample">Windows&lt;/a>&lt;/td>
&lt;td>A Visual C# application demonstrating the use of a wide variety of API calls using OAuth for authentication.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="architecture-overview">Architecture Overview&lt;/h2>
&lt;p>This document primarily describes partner applications that run as server applications and provide a UI that is displayed within an Onshape tab. The API described can also be called from applications that do not display inside an Onshape document. All access to the document must be made using a secure (HTTPS) connection.&lt;/p>
&lt;p>It is important to understand how Onshape documents are structured in order to use the API.&lt;/p>
&lt;h2 id="elements">Elements&lt;/h2>
&lt;p>All data in an Onshape document is stored in Elements (represented as tabs in the user interface). Onshape documents currently contain 5 kinds of elements.&lt;/p>
&lt;ol>
&lt;li>Part Studio (zero or more parts)&lt;/li>
&lt;li>Assembly (zero or more parts or assemblies)&lt;/li>
&lt;li>Blob (&amp;ldquo;Binary Large OBject&amp;rdquo;) This can be data provided by a partner, or by the end user. For example, the user can upload a PDF file, an image or a text file. Partner applications can store arbitrary data, but we recommend using the structured storage available in an Application element for better integration.&lt;/li>
&lt;li>Application. This is an element that presents an IFrame to the user. The user interface in the IFrame is managed by a server that can be provided by a third-party. Note that Onshape Drawings are a special case of an application element.&lt;/li>
&lt;li>FeatureStudio. This element contains the definition of Onshape Features which are defined in FeatureScript.&lt;/li>
&lt;/ol>
&lt;h2 id="workspaces-versions-and-microversions">Workspaces, Versions and Microversions&lt;/h2>
&lt;p>A document is stored in Onshape as a collection of changes. Each individual change to the document creates a new &amp;ldquo;Document Microversion&amp;rdquo;. You can think of a &amp;ldquo;Workspace&amp;rdquo; as a branch of the document, similar to a branch in a source control system. As the document is edited, changes are applied to the active workspace, creating new Microversions. Periodically, the user may designate &amp;ldquo;Versions&amp;rdquo; of the document. A Version is a named snapshot of the entire document at some point in time (that is, at some Microversion).&lt;/p>
&lt;p>You cannot change a Version of the document - all changes are applied to a Workspace (and create a new Microversion). Thus, while in general the GET methods of the API can read from a Version, Microversion or Workspace, the POST methods generally require a Workspace, and create a new Microversion when data is written to the document. (An exception is that it is possible to set metadata within a Version - this does not create a new microversion).&lt;/p>
&lt;p>The following IDs are used by many of the APIs. Each ID (except for Geometry IDs such as Part, Face and Edge) is currently a 24-character string that is used internally by Onshape to uniquely identify the resource. The Geometry IDs are variable-length strings used to resolve to a specific geometric entity within a model.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>User ID&lt;/strong>&lt;/th>
&lt;th>Identifies a single user.&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Document ID&lt;/strong>&lt;/td>
&lt;td>The Document ID identifies a document. The logged-in user must be able to access the requested document for the API to succeed.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Workspace ID&lt;/strong>&lt;/td>
&lt;td>The Workspace ID identifies a workspace within the document. Workspaces are used to distinguish between different branches of the document.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Version ID&lt;/strong>&lt;/td>
&lt;td>The Version ID identifies a specific named version.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Microversion ID&lt;/strong>&lt;/td>
&lt;td>The Microversion ID identifies an internal revision of the document.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Element ID&lt;/strong>&lt;/td>
&lt;td>The Element ID identifies an element within the document.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Part ID&lt;/strong> &lt;br> &lt;strong>Face ID&lt;/strong> &lt;br> &lt;strong>Edge ID&lt;/strong>&lt;/td>
&lt;td>The Part ID identifies a part within a part studio. The Part ID should generally not be stored for long-term use, as it is only expected to be valid during the course of a session. Note that a Part ID may reference a part that no longer exists if the model is changed, so it is best to specify a Version or Microversion to pick the context for the Part ID. Note that even with the Version or Microversion, internal changes to the Onshape system may result in the Part ID changing. Therefore, Onshape provides mechanisms for maintaining persistent references. See the &lt;a href="associativity.html">associativity APIs&lt;/a> for more information. Face and Edge IDs are used in similar ways, and will be documented in further detail.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="linked-documents">Linked Documents&lt;/h2>
&lt;p>Although a document can contain a complex model tree involving many Part Studio and Assembly elements, it is often more efficient to split the content into multiple documents. Connections between the documents are always made from a document referring to a specific version of the target document. Once a version of a document is used as the target of a linked document, that document version will be preserved as long as any document references it, event in the containing document is deleted. In addition, any user that has access to the referring document will have limited read access to the target document, regardless of what permission grants are currently on the target document.&lt;/p>
&lt;h2 id="configurations">Configurations&lt;/h2>
&lt;p>Onshape Part Studios may be contructed to be configurable using Onshape Configurations. API calls that
reference Part Studios (primarily within the Parts and Part Studios APIs) often accept a &amp;ldquo;configuration&amp;rdquo;
parameter that identifies what specific configuraton of the Part Studios is being referenced. When not
specified, the API implementation will typically use the configuration that is currently selected within
the Part Studio, which means that an interactive ad-hoc API call will often behave as you expect, but might
not behave consistently in an application, so be sure to specify the configuration parameter where
applicable.&lt;/p>
&lt;h2 id="authentication">Authentication&lt;/h2>
&lt;p>Onshape uses the OAuth for authentication. The Onshape sample applications demonstrate how to use OAuth; additional documentation about the OAuth protocol is available on the web and in the OAuth item in the documentation list.&lt;/p>
&lt;p>Using OAuth will be required for all application in the Onshape Appstore, and is strongly encouraged for general security and privacy in general. By using OAuth, customers can maintain control of their own passwords, and enable and disable applications according to the their preferences. For security and privacy, vendors should not capture and store customer passwords.&lt;/p>
&lt;h3 id="oauth">OAuth&lt;/h3>
&lt;p>Onshape uses standard OAuth2. See the RFC at &lt;a href="https://tools.ietf.org/html/rfc6749" target="_blank">&lt;a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749&lt;/a>&lt;/a> for a detailed description of OAuth. More details on Onshape&amp;rsquo;s OAuth implementation is available in the &lt;a href="oauth.html">OAuth document&lt;/a>.&lt;/p>
&lt;p>Onshape provides the following OAuth endpoints:&lt;/p>
&lt;p>&lt;code>https://oauth.onshape.com/oauth/token&lt;/code>&lt;/p>
&lt;p>&lt;code>https://oauth.onshape.com/oauth/authorize&lt;/code>&lt;/p>
&lt;p>The Oauth Header should be in the form:&lt;/p>
&lt;p>&amp;lsquo;Authorization: Bearer &amp;lt;&lt;em>token&lt;/em>&amp;gt;&amp;rsquo;&lt;/p>
&lt;p>The Onshape samples provide a working template demonstrating OAuth use. To build your own applications based on these samples, you will need an OAuth Client ID and OAuth Client Secret from Onshape.&lt;/p>
&lt;p>You can generate an ID and Secret by using the Onshape Developer Portal at &lt;a href="https://dev-portal.onshape.com" target="_blank">&lt;a href="https://dev-portal.onshape.com">https://dev-portal.onshape.com&lt;/a>&lt;/a>.&lt;/p>
&lt;p>You can also add your application to the Appstore using the Developer Portal. Note that by default, only Onshape, the Application Owner and members of the &amp;lsquo;visiblity team&amp;rsquo; will be able to see the App in the Appstore.&lt;/p>
&lt;h3 id="username-and-password">Username and password&lt;/h3>
&lt;p>Authentication using username and password is now deprecated. This interface is not supported for applications in the Appstore.&lt;/p>
&lt;h2 id="ui-integration-for-applications">UI Integration for Applications&lt;/h2>
&lt;h3 id="development-and-testing">Development and testing&lt;/h3>
&lt;p>Developers can create applications using the Developer Portal at &lt;a href="https://dev-portal.onshape.com" target="_blank">&lt;a href="https://dev-portal.onshape.com">https://dev-portal.onshape.com&lt;/a>&lt;/a>.&lt;/p>
&lt;p>When your application is instantiated in a document, it will be called with a URL similar to the following:&lt;/p>
&lt;p>&lt;code>https://_your-server.your-domain.com_?documentId=1bf13f86674e42e88da3ba72&amp;amp;workspaceId=b0526d577bb844bea463aea7&amp;amp;elementId=36c2f534a07941e1a26b4928&amp;amp;server=https%3A%2F%2Fcad.onshape.com&amp;amp;userId=53da35fbe4b0412c60b5e3b7&amp;amp;access=edit&amp;amp;debug=true&lt;/code>&lt;/p>
&lt;p>The query parameters passed from Onshape to your application are:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Parameter&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Description&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>documentId&lt;/td>
&lt;td>Current document ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>workspaceId&lt;/td>
&lt;td>Current workspace ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>elementId&lt;/td>
&lt;td>Current (application) element ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server&lt;/td>
&lt;td>The address of the current Onshape server&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>userId&lt;/td>
&lt;td>Current user ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>access&lt;/td>
&lt;td>To be documented&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>debug&lt;/td>
&lt;td>To be documented&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>These query parameters provide the context you need to interact with the current document; you will need to authenticate to the Onshape server in order to use the REST APIs. The server parameter is informational, REST requests should always be sent to &lt;a href="https://cad.onshape.com">https://cad.onshape.com&lt;/a> for API requests and &lt;a href="https://oauth.onshape.com">https://oauth.onshape.com&lt;/a> for OAuth related operations.&lt;/p>
&lt;h3 id="end-user-integration">End user integration&lt;/h3>
&lt;p>When a user registers an application, there are several possible integration points to expose the application within the Onshape user experience. At this time, applications that provide a UI in an Onshape tab will be added to the menu attached to the plus button on the Onshape tab bar.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/apioverviewimage02.png" alt="image">&lt;/p>
&lt;p>Use the Developer Portal to create an application and an Appstore entry. We are still considering how to best offer additional integration options, possibly including context menus for appropriate entities, application-specific toolbar buttons and more.&lt;/p>
&lt;h3 id="applications-for-mobile-clients">Applications for Mobile Clients&lt;/h3>
&lt;p>Onshape expects to enable applications tabs in iOS and Android environments, but details, including touch event handling in mobile environments, have not been finalized.&lt;/p>
&lt;h2 id="rest-api-documentation">REST API Documentation&lt;/h2>
&lt;p>The available REST API endpoints are documented in the Glassworks API Explorer. Documentation of deprecated forms of the API are provided for reference below.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>IMPORTANT NOTE&lt;/strong> The documentation in the Glassworks API Explorer reflects the supported interface. Some API calls may, for historical reasons, return additional undocumented fields. Unless the return fields are documented in the API Explorer, you should NOT use them, as they may be removed without warning. Your application should always ignore unexpected or undocumented return data. Onshape reserves the right to add, remove or change any undocumented fields.&lt;/p>
&lt;/blockquote>
&lt;h2 id="api-conventions">API conventions&lt;/h2>
&lt;p>The Onshape API generally follows the following conventions:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Onshape generally supports only 3 methods: GET for read-only operations, POST for write operations, and DELETE for deletions. Onshape does not currently support other methods such as PUT.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Strings should be UTF-8 encoded.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Query parameters are used for optional parameters. All required parameters are included in the path.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For brevity, we use the following upper case letters in path definitions in this document:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>D Document ID (24-characters)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>W Workspace ID (24-characters)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>V Version ID (24-characters)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>M Microversion ID (24-characters)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>E Element ID (24-characters)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The general form of a path is /resource/context/subresource. When present, the context identifies the document (D), the workspace, version or microversion (WVM), and the element (E). For example, to request the definition of an assembly within a workspace of the document:
&lt;code>GET /api/assemblies/d/eb48129ebf9a499ea67d49fd/w/71534f2162b04565897e9769/e/4dd5d4d11fee45229d6e6ef8&lt;/code>
or, more succinctly:
&lt;code>GET /api/assemblies/d/D/w/W/e/E&lt;/code>
Note that the path elements &amp;ldquo;d&amp;rdquo;, &amp;ldquo;w&amp;rdquo;, &amp;ldquo;v&amp;rdquo;, &amp;ldquo;m&amp;rdquo; and &amp;ldquo;e&amp;rdquo; are abbreviated when used in the &amp;ldquo;context&amp;rdquo; section of the path.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Our intention is to provide Workspace, Version and Microversion forms for all appropriate GET operations. POST will always be to a Workspace, as Versions and Microversions are immutable. Not all forms of all interfaces are implemented at this time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>As of this writing, some API calls return information that is of use only for Onshape clients. You should generally only use the fields that are documented for external use. The internal data may be changed or removed without notice.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="current-rest-api-list">Current REST API list&lt;/h2>
&lt;p>API endpoints start with /api/, for example, /api/documents where the
path segment following /api/ identifies the logical major resource with which they are associated.
Our APIs are continuously evolving. Our policy with regard to maintaining API compatibility is that
we may extend APIs to accept additional parameters and return additional fields in outputs without
providing any advance notification. If we decide to modify an API in a way that would alter output in
a meaningful way, we will either introduce a new API or define a new version of the existing API. API
callers should take note of the documented Accept header for an API call and specify that in their
application. When no version header is specified the behavior will behave according to the oldest
supported version.&lt;/p>
&lt;p>Please refer to the Glassworks API Explorer for detailed information. The API Explorer describes the officially supported interfaces and documents all supported options and return values. You should only use documented fields. Internal data may be changed or removed without notice.&lt;/p>
&lt;p>To obtain a complete list of API endpoints, open the Glassworks API Explorer and click on the &amp;ldquo;Toggle All Endpoints&amp;quot;button to expand all available REST APIs. You can search this list using your browser&amp;rsquo;s search capability to locate specific interfaces.&lt;/p>
&lt;h2 id="units-parameters">Units parameters&lt;/h2>
&lt;p>The following strings are valid unit designators:&lt;/p>
&lt;p>For length measures:&lt;/p>
&lt;ul>
&lt;li>meter, meters, m&lt;/li>
&lt;li>millimeter, millimeters, mm&lt;/li>
&lt;li>centimeter, centimeters, cm&lt;/li>
&lt;li>inch, inches, in&lt;/li>
&lt;li>foot, feet, ft&lt;/li>
&lt;li>yard, yards, yd&lt;/li>
&lt;/ul>
&lt;p>For angular measures:&lt;/p>
&lt;ul>
&lt;li>degree, degrees, deg&lt;/li>
&lt;li>radian, radians, rad&lt;/li>
&lt;/ul></description></item><item><title>Docs: Associativity</title><link>https://onshape-public.github.io/docs/associativity/</link><pubDate>Mon, 18 May 2020 20:28:26 -0400</pubDate><guid>https://onshape-public.github.io/docs/associativity/</guid><description>
&lt;p>Onshape Associativity for external applications&lt;/p>
&lt;p>This document describes data structures and APIs that external applications can use to implement associativity.&lt;/p>
&lt;p>Please address questions, comments and suggestions to &amp;ldquo;&lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a>&amp;rdquo; for the fastest response.&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Onshape data is stored in replicated databases in the cloud. The data model for accessing Parts and Assemblies through the REST API is described here. The model is influenced by the data model used by Git and similar source code repositories.&lt;/p>
&lt;h2 id="onshape-data-model">Onshape Data Model&lt;/h2>
&lt;p>&lt;em>Documents&lt;/em> contain &lt;em>Elements&lt;/em>.&lt;/p>
&lt;p>&lt;em>Elements&lt;/em> are presented as tabs in the user interface. An element can be one of the following types:&lt;/p>
&lt;ul>
&lt;li>Part Studio&lt;/li>
&lt;li>Assembly&lt;/li>
&lt;li>Blob&lt;/li>
&lt;li>Application&lt;/li>
&lt;/ul>
&lt;p>With some exceptions, all data in a document is stored within an element.&lt;/p>
&lt;p>&lt;em>Documents&lt;/em> can be branched, creating new &lt;em>Workspaces&lt;/em>.&lt;/p>
&lt;p>Note that &lt;em>Workspaces&lt;/em> are branches of the entire document. Every change to a document is recorded in the database. The *Document Microversion ID *is an ID that represents the entire state of the document at a point in the history.&lt;/p>
&lt;p>&lt;em>Workspaces&lt;/em> can be named at a point in time, creating a &lt;em>Version&lt;/em>.&lt;/p>
&lt;p>&lt;em>Versions&lt;/em> are permanent names that identify the state of a workspace at a point in time. Thus, versions are immutable - changes can be made to a workspace, not to a version.&lt;/p>
&lt;p>The following table describes what data stored in each &lt;em>Element&lt;/em> type:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>Part Studio&lt;/td>
&lt;td>Each Part Studio contains exactly one Feature List. The feature list contains Features such as Sketches, Planes, Extrudes, and so on. Each feature contains one or parameters. Onshape is in the process of publishing APIs to provide read and write access to features.
&lt;p>Whenever the feature list changes, the parametric history is evaluated, causing the model to be regenerated. This results in zero or more parts and surfaces to be created.&lt;/td>&lt;/p>
&lt;/tr>
&lt;tr>
&lt;td>Assembly&lt;/td>
&lt;td>Each Assembly contains an Assembly Tree, which contains parts and/or other assemblies (sub-assemblies), along with mate information. Onshape provides an API call to retrieve the assembly tree definition.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Blob&lt;/td>
&lt;td>Each Blob element contains an uninterpreted binary object that has been uploaded to Onshape, typically from a file. Onshape depends on the browser client to display some blob data (PDF and image data), but does not interpret the data. A blob element can be updated with new data.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Application&lt;/td>
&lt;td>Each Application element contains zero or more sub-elements, providing a structured set of transactional data that is defined and managed by an application. A detailed description of the application storage data model is described elsewhere.
&lt;p>Application data can be displayed in the Onshape tab in an iframe; the application is responsible for rendering the data in the iframe from their server.&lt;/td>&lt;/p>
&lt;/tr>
&lt;/table>
&lt;p>Note that Onshape &lt;em>Drawing&lt;/em> elements are Application elements tagged as managed by Onshape.&lt;/p>
&lt;p>Documents, Elements, Workspaces, Versions, Microversions, Users and various other data objects are identified by a unique ID. These IDs form the basic building blocks for the Onshape REST API.&lt;/p>
&lt;p>Tessellated data is not stored persistently in Onshape; it is generated on demand for display by the Onshape clients, or in response to application REST API requests. This data may be cached for performance.&lt;/p>
&lt;h2 id="git-analogy">Git analogy&lt;/h2>
&lt;p>The following table identifies Onshape concepts and the corresponding Git concepts. Note that this is not a direct mapping, and the implementation of the concepts is very different.&lt;/p>
&lt;table>
&lt;tr>
&lt;td>Onshape concept&lt;/td>
&lt;td>Git concept&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Document&lt;/td>
&lt;td>Repository&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Element&lt;/td>
&lt;td>File&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Workspace&lt;/td>
&lt;td>Branch&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Version&lt;/td>
&lt;td>Tag&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Microversion&lt;/td>
&lt;td>Commit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Document Microversion ID&lt;/td>
&lt;td>SHA&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h2 id="document-data">Document Data&lt;/h2>
&lt;p>All elements, be them Assemblies, Part Studios, Drawings, or even apps, are history based. Each change to an element or set of elements represents a unique record in the document&amp;rsquo;s history. The document can be restored to that particular state any time in the future. Each record of the document&amp;rsquo;s history has a unique persistent identifier which is called a &lt;strong>Microversion&lt;/strong> id in Onshape.&lt;/p>
&lt;p>Document data (excluding document metadata) can be changed in the context of only a &lt;strong>Workspace&lt;/strong>. Each workspace represents an independent line of history of the document, i.e. a sorted list of document microversions. A reference to a state of the Workspace can be stored as an immutable &lt;strong>Version&lt;/strong>. New Workspaces can be branched from a Version, to continue document history from the moment the Version was created. One Workspace can be merged into another to combine document changes made in both workspaces. If an app expects the data in the app element to have certain properties, a merge may fail to preserve these properties, leading to an invalid state of that app element.&lt;/p>
&lt;h3 id="part-studio-data">Part Studio Data&lt;/h3>
&lt;p>The Part Studio element is defined by a list of features, some of which (e.g. sketch), may have complex internal structure composed of entities. Part Studio features and entities are referenced by unique persistent identifiers. Part Studio features and entities can appear, disappear, and reappear depending on the current microversion of the model.&lt;/p>
&lt;h3 id="assembly-data">Assembly Data&lt;/h3>
&lt;p>The Assembly element is defined as a list of assembly features and a tree of subassemblies / part instances. Occurrence id is a unique persistent identifier of an occurrence of a part in the assembly structure.&lt;/p>
&lt;h3 id="external-application-data">External Application Data&lt;/h3>
&lt;p>An external application has complete control over how it manages/stores documents, however, to take advantage of the Onshape data model, there is a set of endpoints they should use to store state. These are collectively known as the &amp;lsquo;Application Element API&amp;rsquo;. To learn how to use these elements, read the Application Element API section.&lt;/p>
&lt;h2 id="model-presentation-data">Model Presentation Data&lt;/h2>
&lt;p>A valid model definition usually corresponds to a real world manufacturable topology. The topology is represented internally as a set of 3-d, 2-d, 1-d, 0-d entities and a set of relations between them. It can be tessellated into a set of geometric primitives which approximate the shape of the model. Tessellated data can be used for visual representation of the model or other processing related to the shape of the model.&lt;/p>
&lt;p>Model topology is represented as a set of Parts, Faces, Edges, and Vertices in the API. Each of these has a unique identifier in every state of the model. The identifier represents an encoded index in the model&amp;rsquo;s history journal and its value depends on the structure of the model&amp;rsquo;s history. The value is not guaranteed to be preserved across model changes, and will almost always change if the model changes in significant ways.&lt;/p>
&lt;p>The following changes in the topological representation can occur between two microversions of the model:&lt;/p>
&lt;ul>
&lt;li>New topological entities can appear;&lt;/li>
&lt;li>Id of existing topology can change;&lt;/li>
&lt;li>Topological entities can disappear;&lt;/li>
&lt;li>Existing topological entities can be merged into a single entity;&lt;/li>
&lt;li>Existing topological entity can be split into multiple entities.&lt;/li>
&lt;/ul>
&lt;p>A pair of model microversion and Topology ID can be used to identify topological entities across the model changes. Topology ID defined in a specific microversion can be translated into a set of topology ids in the current microversion of the model. (The Topology ID is sometimes referred to as a Deterministic ID within Onshape, and is exposed in specific API calls as Part ID, Face ID, and so on).&lt;/p>
&lt;p>The following table contains a summary of Topology IDs exposed through Onshape REST APIs. The details of the API calls are documented in the Glassworks API Explorer.&lt;/p>
&lt;table>
&lt;tr>
&lt;td>Topology ID&lt;/td>
&lt;td>REST API&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Part ID&lt;/td>
&lt;td>/partstudio/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/partstudio/d/:did/[wvm]/:wvm/e/:eid/tessellatededges
/partstudio/d/:did/[wvm]/:wvm/e/:eid/tessellatedfaces
/partstudio/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/shadedviews
/partstudio/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/boundingboxes
/partstudios/d/:did/w/:w/e/:eid/metadata
/parts/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/parts/d/:did/[wvm]/:wvm/e/:eid/tessellatededges
/parts/d/:did/[wvm]/:wvm/e/:eid/tessellatedfaces
/parts/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/shadedviews
/parts/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/boundingboxes
/parts/d/:did/w/:w/e/:eid/metadata
/parts/d/:did/w/:w/e/:eid
/assemblies/d/:did/w/:wvm/e/:eid
/parts/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/parasolid
/parts/d/:did/[wvm]/:wvm/e/:eid/partid/:partid/stl&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Face ID&lt;/td>
&lt;td>/partstudios/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/partstudios/d/:did/[wvm]/:wvm/e/:eid/tessellatedfaces
/partstudios/d/:did/[wvm]/:wvm/e/:eid/tessellatededges
/part/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/part/d/:did/[wvm]/:wvm/e/:eid/tessellatedfaces
/part/d/:did/[wvm]/:wvm/e/:eid/tessellatededges&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Edge ID&lt;/td>
&lt;td>/partstudios/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/partstudios/d/:did/[wvm]/:wvm/e/:eid/tessellatededges
/parts/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/parts/d/:did/[wvm]/:wvm/e/:eid/tessellatededges&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Vertex ID&lt;/td>
&lt;td>/partstudios/d/:did/[wvm]/:wvm/e/:eid/bodydetails
/parts/d/:did/[wvm]/:wvm/e/:eid/bodydetails&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h2 id="associativity">Associativity&lt;/h2>
&lt;p>The key to understanding associativity in Onshape is to recognize that Onshape does not expose a persistent ID for any of these entities. When the model changes, the ID may change. Therefore, Onshape provides an API that allows you map IDs from a previous microversion to the current microversion. Assuming a simple case of maintaining associativity for a face, an abstract workflow might be:&lt;/p>
&lt;ol>
&lt;li>Read the tessellated model data.&lt;/li>
&lt;li>Select the face of interest.&lt;/li>
&lt;li>Store the Face ID and Document Microversion ID for the face.&lt;/li>
&lt;li>[ user changes model ]&lt;/li>
&lt;li>Call the REST API to translate from the known Face ID to an ID in the new model.&lt;/li>
&lt;li>Re-apply application-specific data to the face(s) in the new model. Note that a face may become zero, one or multiple faces in the new model, depending on what changes the user made.&lt;/li>
&lt;/ol>
&lt;p>The following example shows the sequence of API calls.&lt;/p>
&lt;h3 id="associativity-example">Associativity Example&lt;/h3>
&lt;ol>
&lt;li>Create a unit length [cube]:
&lt;img src="https://onshape-public.github.io/images/associativityimage03.png" alt="image alt text">&lt;/li>
&lt;li>Get document microversion (&lt;code>https://cad.onshape.com/api/documents/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/microversion&lt;/code>).
Use the appropriate REST API to get the tessellated faces &lt;code>https://cad.onshape.com/api/partstudios/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/e/&amp;lt;eid&amp;gt;/tessellatedfaces&lt;/code>
and edges &lt;code>https://cad.onshape.com/api/partstudios/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/e/&amp;lt;eid&amp;gt;/tessellatededges&lt;/code>. Note the ids:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Part Id : &amp;ldquo;JHD&amp;rdquo;;&lt;/li>
&lt;li>Front face Id : &amp;ldquo;JHO&amp;rdquo;;&lt;/li>
&lt;li>Top edge of the front face Id : &amp;ldquo;JHd&amp;rdquo;;&lt;/li>
&lt;li>Right edge of the top face Id : &amp;ldquo;JHt&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Split cube with the [&amp;ldquo;Front&amp;rdquo; plane], translate ids:&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/associativityimage00.png" alt="image alt text">&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong> &lt;code>https://cad.onshape.com/api/partstudios/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/e/&amp;lt;eid&amp;gt;/idtranslations&lt;/code>&lt;/p>
&lt;p>&lt;strong>Body&lt;/strong>:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;sourceDocumentMicroversion&amp;#34; : &amp;#34;47e75ab2ee8b4356a76ebd47&amp;#34;,
&amp;#34;ids&amp;#34; : [&amp;#34;JHD&amp;#34;, &amp;#34;JHO&amp;#34;, &amp;#34;JHd&amp;#34;, &amp;#34;JHt&amp;#34; ]
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Response&lt;/strong>:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;documentId&amp;#34;: &amp;#34;748d6e850c9248328189922b&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;042a6fa54e79451e8076463d&amp;#34;,
&amp;#34;sourceDocumentMicroversion&amp;#34;: &amp;#34;47e75ab2ee8b4356a76ebd47&amp;#34;,
&amp;#34;ids&amp;#34;: [
{ &amp;#34;source&amp;#34;: &amp;#34;JHD&amp;#34;, &amp;#34;status&amp;#34;: &amp;#34;SPLIT&amp;#34;, &amp;#34;target&amp;#34;: [&amp;#34;JID&amp;#34;, &amp;#34;JIH&amp;#34;] },
{ &amp;#34;source&amp;#34;: &amp;#34;JHO&amp;#34;, &amp;#34;status&amp;#34;: &amp;#34;OK&amp;#34;, &amp;#34;target&amp;#34;: [&amp;#34;JHO&amp;#34;] },
{ &amp;#34;source&amp;#34;: &amp;#34;JHd&amp;#34;, &amp;#34;status&amp;#34;: &amp;#34;OK&amp;#34;, &amp;#34;target&amp;#34;: [&amp;#34;JHd&amp;#34;] },
{ &amp;#34;source&amp;#34;: &amp;#34;JHt&amp;#34;, &amp;#34;status&amp;#34;: &amp;#34;SPLIT&amp;#34;, &amp;#34;target&amp;#34;: [&amp;#34;JI5&amp;#34;, &amp;#34;JI9&amp;#34;] }
],
&amp;#34;targetDocumentMicroversion&amp;#34;: &amp;#34;78bc7f3fcf82475085c2f3ab&amp;#34;
4. Delete one of the [parts], translate ids:
![image alt text](/images/associativityimage01.png)
**POST** `https://cad.onshape.com/api/partstudios/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/e/&amp;lt;eid&amp;gt;/idtranslations`
**Body**:
&lt;/code>&lt;/pre>&lt;p>{
&amp;ldquo;sourceDocumentMicroversion&amp;rdquo; : &amp;ldquo;47e75ab2ee8b4356a76ebd47&amp;rdquo;,
&amp;ldquo;ids&amp;rdquo; : [&amp;ldquo;JHD&amp;rdquo;, &amp;ldquo;JHO&amp;rdquo;, &amp;ldquo;JHd&amp;rdquo;, &amp;ldquo;JHt&amp;rdquo;]
}&lt;/p>
&lt;pre tabindex="0">&lt;code>
**Response**:
&lt;/code>&lt;/pre>&lt;p>{
&amp;ldquo;documentId&amp;rdquo;: &amp;ldquo;748d6e850c9248328189922b&amp;rdquo;,
&amp;ldquo;elementId&amp;rdquo;: &amp;ldquo;042a6fa54e79451e8076463d&amp;rdquo;,
&amp;ldquo;sourceDocumentMicroversion&amp;rdquo;: &amp;ldquo;47e75ab2ee8b4356a76ebd47&amp;rdquo;,
&amp;ldquo;ids&amp;rdquo;: [
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHD&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JID&amp;rdquo;] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHO&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;FAILED_TO_RESOLVE&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHd&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;FAILED_TO_RESOLVE&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHt&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JI5&amp;rdquo;] }
],
&amp;ldquo;targetDocumentMicroversion&amp;rdquo;: &amp;ldquo;52aa74d34b624f3aaef33204&amp;rdquo;
}&lt;/p>
&lt;pre tabindex="0">&lt;code>
5. Rollback delete and [split], translate ids:
![image alt text](/images/associativityimage02.png)
**POST** `https://cad.onshape.com/api/partstudios/d/&amp;lt;docid&amp;gt;/w/&amp;lt;wid&amp;gt;/e/&amp;lt;eid&amp;gt;/idtranslations`
**Body**:
&lt;/code>&lt;/pre>&lt;p>{
&amp;ldquo;sourceDocumentMicroversion&amp;rdquo; : &amp;ldquo;47e75ab2ee8b4356a76ebd47&amp;rdquo;,
&amp;ldquo;ids&amp;rdquo; : [&amp;ldquo;JHD&amp;rdquo;, &amp;ldquo;JHO&amp;rdquo;, &amp;ldquo;JHd&amp;rdquo;, &amp;ldquo;JHt&amp;rdquo;]
}&lt;/p>
&lt;pre tabindex="0">&lt;code>
**Response**:
&lt;/code>&lt;/pre>&lt;p>{
&amp;ldquo;documentId&amp;rdquo;: &amp;ldquo;748d6e850c9248328189922b&amp;rdquo;,
&amp;ldquo;elementId&amp;rdquo;: &amp;ldquo;042a6fa54e79451e8076463d&amp;rdquo;,
&amp;ldquo;sourceDocumentMicroversion&amp;rdquo;: &amp;ldquo;47e75ab2ee8b4356a76ebd47&amp;rdquo;,
&amp;ldquo;ids&amp;rdquo;: [
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHD&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JID&amp;rdquo;] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHO&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JHO&amp;rdquo;] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHd&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JHd&amp;rdquo;] },
{ &amp;ldquo;source&amp;rdquo;: &amp;ldquo;JHt&amp;rdquo;, &amp;ldquo;status&amp;rdquo;: &amp;ldquo;OK&amp;rdquo;, &amp;ldquo;target&amp;rdquo;: [&amp;ldquo;JHt&amp;rdquo;] }
],
&amp;ldquo;targetDocumentMicroversion&amp;rdquo;: &amp;ldquo;52aa74d34b624f3aaef33204&amp;rdquo;
}&lt;/p>
&lt;pre tabindex="0">&lt;code>&lt;/code>&lt;/pre></description></item><item><title>Docs: Billing</title><link>https://onshape-public.github.io/docs/billing/</link><pubDate>Mon, 18 May 2020 20:29:36 -0400</pubDate><guid>https://onshape-public.github.io/docs/billing/</guid><description>
&lt;p>This document describes APIs that will allow partners to interact with the Onshape billing system.&lt;/p>
&lt;p>Please address questions to &amp;ldquo;&lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a>&amp;rdquo; for the fastest response.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>All billing is done through &amp;ldquo;plans&amp;rdquo; that are created in the Developer Portal. A â€œplanâ€ has the following attributes:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>Name (also called SKU)&lt;/td>
&lt;td>A unique (within your company) plan name&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Description&lt;/td>
&lt;td>A user-visible description of the plan&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Amount&lt;/td>
&lt;td>The cost of the plan (may be one-time or recurring, depending on the type)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Type&lt;/td>
&lt;td>Monthly, One-time or Consumable&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>Onshape defines three kinds of plans:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>Plan type&lt;/td>
&lt;td>Description&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Recurring
(Monthly Subscription)&lt;/td>
&lt;td>A plan that is renewed monthly at a fixed cost. All Apps in the app store must have a Free monthly plan (which is created by default), and may have additional paid plans.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>One-time&lt;/td>
&lt;td>A plan that is purchased once (not renewed monthly). A user may purchase these multiple times.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Consumable&lt;/td>
&lt;td>A plan that represents a consumable unit, such as "hours of rendering" or â€œsimulation runsâ€. Consumable plans are not fully implemented at this time, but the consumable functionality can be implemented using One-time Purchase plans as described below.&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>Users may purchase plans through the App Store interface. In addition, if your application has the OAuth Purchase Scope, your application can initiate &amp;ldquo;in-app&amp;rdquo; purchases by calling Onshape to request a purchase.&lt;/p>
&lt;p>The basic steps for interacting with Onshape Billing:&lt;/p>
&lt;ol>
&lt;li>Define one or more plans using the Developer Portal interface&lt;/li>
&lt;li>Use the Onshape API to determine the current userâ€™s plan&lt;/li>
&lt;li>Provide features and/or limits based on the current plan&lt;/li>
&lt;/ol>
&lt;h2 id="using-the-onshape-billing-api">Using the Onshape Billing API&lt;/h2>
&lt;p>&lt;code>GET /api/accounts/purchases&lt;/code>&lt;/p>
&lt;p>Returns a list of purchase made by the current user for plans owned by the current application. Use this information to determine what capabilities or features the user is entitled to use.&lt;/p>
&lt;p>&lt;code>DELETE /api/accounts/purchases/&amp;lt;purchase id&amp;gt;&lt;/code>&lt;/p>
&lt;p>Cancel a recurring purchase.&lt;/p>
&lt;p>&lt;code>POST /api/accounts/purchases/&amp;lt;purchase id&amp;gt;/consume&lt;/code>&lt;/p>
&lt;p>Indicate the use of a consumable. (Not fully implemented at this time)&lt;/p>
&lt;p>&lt;code>GET /api/billing/plans/client/&amp;lt;client id&amp;gt;&lt;/code>&lt;/p>
&lt;p>Get a list of the billing plans defined for this client.&lt;/p>
&lt;h2 id="initiating-a-purchase-from-an-application-in-app-purchases">Initiating a purchase from an application (in-app purchases)&lt;/h2>
&lt;p>To initiate a purchase of a subscription or one time item you must set the browserâ€™s location to particular URL within the Onshape stack:&lt;/p>
&lt;p>&lt;code>https://cad.onshape.com/billing/purchase?redirectUri=RRRR&amp;amp;clientId=CCCC&amp;amp;sku=SSSS&amp;amp;userId=UUUU&lt;/code>&lt;/p>
&lt;p>Each of the query parameters should be URL encoded. The clientId is your applicationâ€™s OAuth Client ID, the sku is the name/sku field for an item (you can find this in the developer portal or itâ€™s retrievable through the /api/billing/plans REST endpoints). The user Id should be the Onshape user Id for the current user and is available through the /api/users/session REST endpoint. The redirectUri is the URI the user will be returned to within your website when the purchase is finished.&lt;/p>
&lt;p>When the browserâ€™s location is changed to this pattern the Onshape stack will serve content to confirm the users identity, confirm the details of what is being purchased (or obtained if the item is free) and then after the user agrees to the purchase will confirm the transaction (with our payment processor if the item is not free) and then redirect the user back to the supplied redirectUri (the browser location will be changed to the redirectUri). Additionally Onshape will add a &lt;code>success=true&lt;/code> or &lt;code>success=false&lt;/code> query parameter to the redirectURI indicating whether the user completed successfully (payment was taken if required etc.) or failed, either due to cancelling the purchase or an issue with payment.&lt;/p>
&lt;p>When the browser fetches the redirectUri your application must call back through the &lt;code>/api/account/purchases&lt;/code> API to get confirmation of the purchase - do NOT assume that a fetch of the redirectUri with a &lt;code>success=true&lt;/code> query parameter actually indicates a purchase has occurred. Query the Onshape stack with the &lt;code>/api/account/purchases&lt;/code> API to ensure that the required item has actually been bought.&lt;/p>
&lt;h2 id="consumable-items">Consumable Items&lt;/h2>
&lt;p>A detailed description of the interface for managing consumable purchases will be provided shortly. You can use one-time plans to achieve similar results:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Define a one-time purchase plan with a description indicating the nature of the purchase, for example:&lt;/p>
&lt;p>RENDER-10 Ten rendering hours $100&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Keep track of the number of hours that the user has consumed. You can store and retrieve this information in Onshape using the following APIs. These APIs allow you to store and retrieve arbitrary information on a per-user basis.&lt;/p>
&lt;p>POST /applications/clients/:cid/settings/users/:uid
GET /applications/clients/:cid/settings/users/:uid&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Check the number of available &amp;ldquo;units&amp;rdquo; by getting the purchases and the record of consumables. Be sure to include UI in your application that the user can use to see their remaining quantity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Alternately, you can store the consumption data in your own system; you do not need to use the Onshape API to manage that data.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Onshape intends to provide a richer set of APIs that help track the purchase and consumption of consumables in the near future.&lt;/p>
&lt;h2 id="other-billing-models">Other billing models&lt;/h2>
&lt;p>You can use these mechanisms to implement other models. For example, a time-limited trial could be implemented by scanning purchases for the first &amp;ldquo;purchase&amp;rdquo; and denying service if it is more than a defined number of days in the past. A â€œfixed number of uses per monthâ€ could be implemented as a monthly subscription, string usage data with the settings API, and denying service after a fixed number of uses.&lt;/p>
&lt;h2 id="samples">Samples&lt;/h2>
&lt;p>Onshape will provide sample code for both desktop and integrated applications demonstrating the use of the billing APIs and workflow. If you are subscribed to the Onshape Github Partner group, you will have access to those samples as soon as they are posted.&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>Please contact &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a> to discuss details of testing billing &amp;amp; subscriptions.&lt;/p></description></item><item><title>Docs: Client Messaging</title><link>https://onshape-public.github.io/docs/clientmessaging/</link><pubDate>Mon, 18 May 2020 20:30:40 -0400</pubDate><guid>https://onshape-public.github.io/docs/clientmessaging/</guid><description>
&lt;h1 id="javascript-post-message-api">JavaScript Post Message API&lt;/h1>
&lt;hr>
&lt;p>Application extensions and the Onshape JavaScript web client need to communicate directly, calling across the iframe containing the application extension using post message.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/javascriptpostmessageimage00.png" alt="image alt text">&lt;/p>
&lt;h2 id="typical-use-cases">Typical Use Cases&lt;/h2>
&lt;p>Some example use cases that might include using Onshape Client Messaging can be split into those that are initiated from the Application Extension, and those that are initiated from the Onshape Client. While many examples are provided, not all of them can be implemented given the currently supported messages.&lt;/p>
&lt;h3 id="from-the-application-extension-to-the-onshape-client">From the Application Extension to the Onshape Client:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Click/Close Flyouts Events&lt;/strong> - Notify the Onshape client that the user has clicked in the application extension, which should cause Onshape flyouts (versions, history, uploads, etc.) and dropdown menus (profile dropdown menu, document menu) to close. Without this, there may be cases the flyouts and menus remain open, over the application extension.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Shortcut Keyboard Events&lt;/strong> - Shortcut keys such as &amp;ldquo;?&amp;rdquo; that should open the Onshape help dialog could be handled by the application extension posting a message to the Onshape client to open the help dialog.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Keep Alive&lt;/strong> - Notify the Onshape client that the user is actively working in the application extension, which will cause the Onshape client to send a message to the server to keep the browser session alive. Without this, the Onshape browser session will timeout after some amount of time, asking the user to login again.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Standard Onshape Dialogs&lt;/strong> - Request from the application extension to the Onshape client to open one of the Onshape standard dialogs and send the userâ€™s choices back to the application extension. For example, if the application extension needs the user to choose a part or assembly to be operated on, the application extension can post a message to the Onshape client requesting that dialog be opened and the selected part or assembly information sent back to the application extension.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>UI Customization&lt;/strong> - Request from the application extension to the Onshape client to customize the Onshape UI - to add commands to menus, add buttons to the toolbars, etc. When such commands or toolbar buttons are clicked, the Onshape client would post a message to the application extension with the available context. **Note - **this is limited to cases where the application extension is made active by the user, as application extensions are not automatically loaded when a document is opened. Most UI customizations should be done when you register the application with Onshape, as those would change the Onshape client automatically without needing to load the application extension first.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Content/Material Insertion&lt;/strong> - Request from the application extension to insert content into the Onshape document. Possible examples: to insert a part into a new or existing partstudio, to apply a material to a part, or to add a material to a material library.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="from-the-onshape-client-to-the-application-extension">From the Onshape Client to the Application Extension:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>User Action Notification&lt;/strong> - The Onshape client could notify an application extension when various user actions happen. For example, the Onshape client might notify when the user has made the application extension active or inactive (when the user clicks on document tabs), as there is no way to know this currently otherwise except when initially loading an application extension. When an application extension is made inactive, it is moved off the edges of the browser, so it cannot be seen but is still active, preserving its state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Printing&lt;/strong> - The Onshape client could notify an application extension when the user has chosen the Print command from the main Onshape document menu, enabling the application extension to do a print operation.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="posting-a-message-from-the-application-extension-to-the-onshape-client">Posting a message from the Application Extension to the Onshape Client&lt;/h2>
&lt;p>To ensure security, an application extension must:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>document, workspace and element ids&lt;/strong> - Parse for the document id, workspace id and element id that were passed as query parameters within the application extensionâ€™s iframe src URL. You will need to post these back in each post message.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>server&lt;/strong> - Parse for the server that was passed as a query parameter within the application extensionâ€™s iframe src URL. You will need to use this to validate messages received, as shown later in this document.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>do not redirect to another base URL&lt;/strong> - The browser will tell the Onshape client the origin base URL from which a post message is received. The Onshape client will ignore messages posted from an origin URL that doesnâ€™t match the original iframe src URL. Hence application extensions should not redirect to another base URL after the iframe has been opened, as that will result in the Onshape ignoring its messages.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>post a message on startup&lt;/strong> - After an application extension has started up and finished loading, it should post a message to the Onshape client. This tells the Onshape client that the application extension is able to handle post messages. The Onshape client will not post a message to an application extension until it has first received a message from the application extension. This ensures the Onshape client wonâ€™t send messages to an application extension that isnâ€™t listening for them and wonâ€™t send messages until the application extension is fully loaded. Any type of valid message sent to the Onshape client will trigger postings from the Onshape client (e.g. keepAlive).&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>This JavaScript code parses the iframe src query parameters uses them to post a message:&lt;/p>
&lt;pre tabindex="0">&lt;code> var documentId;
var workspaceId;
var elementId;
var server;
// Parse query parameters
var queryParameters = decodeURIComponent(window.location.search.substr(1));
var queryParametersArray = queryParameters.split(&amp;#39;&amp;amp;&amp;#39;);
for (var i = 0; i &amp;lt; queryParametersArray.length; i++) {
var parameterArray = queryParametersArray[i].split(&amp;#39;=&amp;#39;);
if (parameterArray.length === 2) {
switch (parameterArray[0]) {
case &amp;#39;documentId&amp;#39;:
documentId = parameterArray[1];
break;
case &amp;#39;workspaceId&amp;#39;:
workspaceId = parameterArray[1];
break;
case &amp;#39;elementId&amp;#39;:
elementId = parameterArray[1];
break;
case &amp;#39;server&amp;#39;:
server = parameterArray[1];
break;
}
}
}
// Listen for clicks and post a message to the Onshape client
document.getElementById(&amp;#39;&amp;lt;id of your topmost element&amp;gt;&amp;#39;).
addEventListener(&amp;#39;click&amp;#39;, function() {
var message = {documentId: documentId,
workspaceId: workspaceId,
elementId: elementId,
messageName: &amp;#39;closeFlyoutsAndMenus&amp;#39;};
window.parent.postMessage(message, &amp;#39;*&amp;#39;);
}, true);
&lt;/code>&lt;/pre>&lt;p>The message object posted to the Onshape client is of the form:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
documentId: documentId,
workspaceId: workspaceId,
elementId: elementId,
messageName: &amp;#39;&amp;lt;message name&amp;gt;&amp;#39;,
â€¦ other properties as needed for other message types â€¦};
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;em>&lt;strong>Notes:&lt;/strong>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The server query parameter is used when receiving post messages from Onshape. See later in this document.&lt;/li>
&lt;li>If the application extension uses a JavaScript library or framework such as BackboneJS or AngularJS, it can parse the query parameters and maintain state in other ways.&lt;/li>
&lt;li>Post messages submitted by application extensions to Onshape will be ignored if any of the following is true:
&lt;ul>
&lt;li>the document id, workspace id or element id are missing or not valid.&lt;/li>
&lt;li>the message name is missing or not recognized.&lt;/li>
&lt;li>the origin of the post message does not match the original iframe src URL.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="handling-messages-posted-from-the-onshape-client-to-the-application-extension">Handling Messages Posted from the Onshape Client to the Application Extension&lt;/h2>
&lt;p>The message data object posted to the application extension is of the form:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
messageName: &amp;#39;&amp;lt;message name&amp;gt;&amp;#39;,
â€¦ other properties as needed for other message types â€¦
}
&lt;/code>&lt;/pre>&lt;p>The message will always have a &lt;code>messageName&lt;/code> property.&lt;/p>
&lt;p>Hereâ€™s some JavaScript code showing how to listen for messages from the Onshape client:&lt;/p>
&lt;pre tabindex="0">&lt;code> // server is one of the iframe src query parameters - see above
var handlePostMessage = function(e) {
console.log(&amp;#34;Post message received in application extension.&amp;#34;);
console.log(&amp;#34;e.origin = &amp;#34; + e.origin);
// Verify the origin matches the server iframe src query parameter
if (server === e.origin) {
console.log(&amp;#34;Message safe and can be handled as it is from origin &amp;#39;&amp;#34;
+ e.origin +
&amp;#34;&amp;#39;, which matches server query parameter &amp;#39;&amp;#34;
+ server + &amp;#34;&amp;#39;.&amp;#34;);
if (e.data &amp;amp;&amp;amp; e.data.messageName) {
console.log(&amp;#34;Message name = &amp;#39;&amp;#34; + e.data.messageName + &amp;#34;&amp;#39;&amp;#34;);
} else {
console.log(&amp;#34;Message name not found. Ignoring message.&amp;#34;);
}
} else {
console.log(&amp;#34;Message NOT safe and should be ignored.&amp;#34;);
}
};
window.addEventListener(&amp;#39;message&amp;#39;, handlePostMessage, false);
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>It is &lt;em>extremely important&lt;/em> to the security of your application that you verify that the origin of all messages you receive is the same as the original server query parameter in the iframe src, as shown above:&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code> if (server === e.origin) {
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>In production operation especially, the message IS NOT SAFE if the message origin does not match the iframe src server query parameter.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Application Extensions Must Post First Message&lt;/strong>&lt;/p>
&lt;p>Onshape will not post messages until a newly started application extension has first posted a valid message to Onshape. This constraint is in effect anytime an application extension is (re)started and exists to avoid posting messages to application extensions that are not ready to handle them, are not fully loaded, etc.&lt;/p>
&lt;p>So after your application extension is fully loaded and ready to receive messages, post a message to Onshape. A keepAlive message is a great first message to send to Onshape. Once Onshape receives a valid message, Onshape will start posting messages to the application extension.&lt;/p>
&lt;p>If the application extension later sends an invalid message Onshape will stop sending messages until a valid message is posted to Onshape.&lt;/p>
&lt;h2 id="element-tab-application-extension-messages">&lt;strong>Element Tab&lt;/strong> Application Extension Messages:&lt;/h2>
&lt;p>Messages may be sent and recieved by element tab application extensions. The following table describes messages that may be sent; find those that may be recieved &lt;a href="#messages-that-may-be-received-by-element-tab-application-extensions">here&lt;/a>:&lt;/p>
&lt;h3 id="mesages-that-may-be-_sent_-by-element-tab-application-extensions">Mesages that may be &lt;em>Sent&lt;/em> by Element Tab Application Extensions&lt;/h3>
&lt;table>
&lt;tr>
&lt;td>messageName
(case sensitive)&lt;/td>
&lt;td>other message properties?&lt;/td>
&lt;td>comment&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>applicationInit&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>notifyWhenSaveRequired: whether Onshape should send a notification to save pending changes during certain operations
(default is false)
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Send once on application startup.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>closeFlyoutsAndMenus&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send when a mouse click or other event happens in the application extension. Closes Onshape flyouts and dropdown menus.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>closeSelectItemDialog&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Closes the select item dialog.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connectionLost&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Displays the standard Onshape connection lost message in a message bubble, forcing the user to either reload the document or return to the documents page.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>errorReload&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>message: your message
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Similar to the connectionLost message, but enables an application to specify the first part of the message, which will be used instead of "Onshape is not connected." The user must reload the document or return to the documents page.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>finishedSaving&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>messageId: the id sent in the corresponding 'saveChanges' message
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Response to a 'saveChanges' message sent from Onshape. Should be sent after application has cleaned up any pending edits.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>keepAlive&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send periodically while while the user is actively working to avoid the session from timing out.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>saveAVersion&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send when the user types â€œShift-Sâ€ in the application extension, the keyboard shortcut for save a version.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>showKeyboardShortcutsHelp&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send when the user types â€œ?â€ (Shift-? on most keyboards) in the application extension, the keyboard shortcut for the keyboard shortcuts help dialog.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>showMessageBubble&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>message: your message
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Send when you want to show a string in the blue message bubble at the top of the Onshape app.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>startLoadingSpinner&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>message: your message
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Send to start a large spinner in the middle of the browser window with your message underneath it.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stopLoadingSpinner&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send to stop the large spinner.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>startWorkingSpinner&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send to start a small spinner in the middle bottom of the browser window.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stopWorkingSpinner&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Send to stop the small spinner.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>openSelectItemDialog&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>dialogTitle: your dialog title
(default is no title),
selectBlobs: true or false
(default is false),
selectParts: true or false
(default is false),
selectPartStudios: true or false
(default is false),
selectAssemblies: true or false
(default is false),
selectMultiple: true or false
(default is false),
selectBlobMimeTypes: â€˜comma-delimited string of blob mime types to show in dialog (e.g. â€œapplication/dwt,application/dwgâ€)â€™
(default is an empty string)
showBrowseDocuments: true or false - controls whether â€˜Other documentsâ€™ choice should be available
(default is true)
showStandardContent: true or false - controls whether â€˜Standard contentâ€™ choice should be available
(default is false)
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Send when your application wants to open a dialog in which the user will select one or multiple items - blobs, parts, part studios or assemblies.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>requestCameraProperties&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>graphicsElementId: string , Element ID of the part studio or assembly
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>
Send to request camera properties of a specific part studio or assembly element. Note: The element should have been opened at least once in the current session. The messageName of the response is cameraProperties
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h3 id="messages-that-may-be-_received_-by-element-tab-application-extensions">Messages that may be &lt;em>Received&lt;/em> by Element Tab Application Extensions&lt;/h3>
&lt;table>
&lt;tr>
&lt;td>messageName
(case sensitive)&lt;/td>
&lt;td>other message properties?&lt;/td>
&lt;td>comment&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>show&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Sent when an element tab application extension is shown (made active) within the Onshape client. This message is NOT sent when the element tab application extension is created.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hide&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Sent when an element tab application extension is made inactive within the Onshape client. This message is NOT sent when an element tab application extension is deleted.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>itemSelectedInSelectItemDialog&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>documentId: id of selected itemâ€™s document,
workspaceId: id of selected itemâ€™s workspace, empty if versionId not empty,
versionId: id of selected itemâ€™s version, empty if workspaceId not empty,
elementId: id of element selected or containing the selected part,
elementName: name of element selected or containing the selected part,
elementType: type of element selected or containing the selected part - â€˜partstudioâ€™, â€˜assemblyâ€™ or â€˜blobâ€™,
elementMicroversionId: microversion id of the element,
itemType: type of item selected: â€˜partâ€™,â€˜partStudioâ€™ or â€˜assemblyâ€™,
partName: name of part selected, empty if itemType is not â€˜partâ€™,
idTag: id of part, empty if no part selected
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Sent when the user selects an item (blob, part, part studio or assembly) in the select item dialog that was opened due to an openSelectItemDialog message sent earlier.
When a part is not selected, the partXxx message properties will be empty strings.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>print&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Sent when the user chooses the Print command while the application is the active element. The application can choose to handle this as either a print or an export to a PDF or other format.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>selectItemDialogClosed&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Sent when the select item dialog closes, either because the user selected an item and selectMultiple is false, or the user changed the active element or the user closed the dialog with the "X" button.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>startFirstViewCommand&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>documentId: id of selected itemâ€™s document,
workspaceId: id of selected itemâ€™s workspace, empty if versionId not empty,
versionId: id of selected itemâ€™s version, empty if workspaceId not empty,
elementId: id of element selected or containing the selected part,
elementName: name of element selected or containing the selected part,
elementType: type of element selected or containing the selected part - â€˜partstudioâ€™, â€˜assemblyâ€™ or â€˜blobâ€™,
elementMicroversionId: microversion id of the element,
itemType: type of item selected: â€˜partâ€™,â€˜partstudioâ€™ or â€˜assemblyâ€™,
partName: name of part selected, empty if itemType is not â€˜partâ€™,
idTag: id of part
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Sent to a drawings application extension when the drawing is created with zero views.
&lt;p>If other types of applications need a message posted to them with creation context, contact Onshape and we can discuss using this sort of message for your application also.&lt;/td>&lt;/p>
&lt;/tr>
&lt;tr>
&lt;td>export&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>fileExtension: the file extension of the export type the user chose - â€œ.dwgâ€, â€œ.dxfâ€ are the types currently supported.
baseFileName: the base portion of the expected output file. This is currently set to â€œ&amp;lt;document name&amp;gt; - &amp;lt;element name&amp;gt;â€
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Sent when the user chooses a command to export the contents of the application to a file.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cameraProperties&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>graphicsElementId: string , Element ID of the part studio or assembly
isValid: boolean, Indicates if the properties are valid or not. false if element ID is invalid or element has not been open in the current session
projectionType: string, Denotes the projection method. Values are â€˜orthographicâ€™, â€˜perspectiveâ€™ . Empty string â€˜â€™ if isValid is false
viewMatrix: 16 element numeric matrix with elements at index 13, 14, 15 corresponding to position of the camera
projectionMatrix: 16 element numeric matrix
verticalFieldOfView: number, 0 in case of orthographic projection
viewportHeight: number, eight of the viewport
viewportWidth: number, width of the viewport
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Sent when application posts a requestCameraProperties message&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>takeFocus&lt;/td>
&lt;td>no&lt;/td>
&lt;td>Sent when the Onshape client sets focus on the content window of the element tab application extension.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>saveChanges&lt;/td>
&lt;td>yes
&lt;pre>&lt;code>messageId: a unique identifier for this message. Should be passed back in the 'finishedSaving' message.
&lt;/code>&lt;/pre>
&lt;/td>
&lt;td>Sent if the application specified 'notifyWhenSaveRequired' in the 'applicationInit' message. Indicates that the application should cleanup any pending edits before an Onshape process continues (i.e. version save).&lt;/td>
&lt;/tr>
&lt;/table>
&lt;h2 id="element-right-panel-application-extension-messages">&lt;strong>Element Right Panel&lt;/strong> Application Extension Messages&lt;/h2>
&lt;p>Most client messaging functionality had been limited to that occurring between the Onshape client and application elements (the &lt;strong>element tab&lt;/strong> location). Included now is &lt;em>some&lt;/em> functionality for client messaging to work with application extensions in the &lt;strong>element right panel&lt;/strong> location as well.&lt;/p>
&lt;h3 id="all-onshape-selections-to-element-right-panel-application-extensions">All Onshape Selections to Element Right Panel Application Extensions&lt;/h3>
&lt;p>Enabled messaging to element right panel extensions includes the communication of selections that the user makes for the following application extension contexts:&lt;/p>
&lt;ul>
&lt;li>Part Studio&lt;/li>
&lt;li>Assembly&lt;/li>
&lt;li>Document&lt;/li>
&lt;/ul>
&lt;h4 id="capturing-selection-messages-from-the-onshape-client">Capturing &lt;code>SELECTION&lt;/code> Messages from the Onshape Client:&lt;/h4>
&lt;p>First, all &lt;a href="#posting-a-message-from-the-application-extension-to-the-onshape-client">security related requirements&lt;/a> that apply to posting a message from an element tab location to the Onshape client apply for the element right panel location as well. In staying consistent with the functionality described in that section, an initial message from the application extension to the Onshape client, in the form of an &lt;code>applicationInit&lt;/code> message (or one of any other messages supported by the element right panel extensions), is required to ensure the Onshape client does not send messages to the extension until it is ready.&lt;/p>
&lt;p>Once a valid &lt;code>applicationInit&lt;/code> message is received by the Onshape client, it will start sending messages with the &lt;code>messageName&lt;/code> value of &lt;code>SELECTION&lt;/code> upon user selection interactions.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>NOTE:&lt;/strong> Prior to accepting &lt;em>any&lt;/em> message from the Onshape client as secure, the &lt;code>origin&lt;/code> attribute value included in incoming messages must be validated as equal to the original &lt;code>server&lt;/code> query parameter value used to load the application extension.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>Sequence diagram illustrating interaction between element right panel application extension and Onshape client:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">%%{
init: {
&amp;#34;theme&amp;#34;: &amp;#34;default&amp;#34;,
&amp;#34;sequence&amp;#34;: {
&amp;#34;mirrorActors&amp;#34;: false,
&amp;#34;showSequenceNumbers&amp;#34;: false,
&amp;#34;width&amp;#34;: 75,
&amp;#34;height&amp;#34;: 60,
&amp;#34;actorMargin&amp;#34;: 25,
&amp;#34;messageFontSize&amp;#34;: 13,
&amp;#34;messageFontFamily&amp;#34;: &amp;#34;monospace&amp;#34;,
&amp;#34;messageFontWeight&amp;#34;: 2
}
}
}%%
sequenceDiagram
actor user
participant OSC AS Onshape Client
participant AE AS Application Extension
user-&amp;gt;&amp;gt;+OSC: start element right panel extension
Note right of user: via configured button
OSC-&amp;gt;&amp;gt;+AE: invoke action url (with query params)
AE-&amp;gt;&amp;gt;OSC: postMessage(messageName: &amp;#39;applicationInit&amp;#39;)
loop selection interactions
user-&amp;gt;&amp;gt;OSC: select
OSC-&amp;gt;&amp;gt;AE: postMessage(messageName: &amp;#39;SELECTION&amp;#39;)
end
user-&amp;gt;&amp;gt;OSC: stop element right panel extension
Note right of user: via configured button
deactivate AE
OSC-XAE: destroy
deactivate OSC
&lt;/code>&lt;/pre>&lt;p>The following messages are exchanged for application extensions located in the element right panel and configured for Part Studio, Assembly, or Document contexts:&lt;/p>
&lt;p>The first message with &lt;code>messageName&lt;/code> attribute set to &lt;code>applicationInit&lt;/code> is sent to the Onshape client by an application extension once it is loaded and ready to receive and process incoming messages:&lt;/p>
&lt;pre tabindex="0">&lt;code> {
documentId: &amp;#39;&amp;lt;document id&amp;gt;&amp;#39;,
workspaceId: &amp;#39;&amp;lt;workspace id&amp;gt;&amp;#39;,
elementId: &amp;#39;&amp;lt;element id&amp;gt;&amp;#39;,
messageName: &amp;#39;applicationInit&amp;#39;
}
&lt;/code>&lt;/pre>&lt;p>where the values &amp;lt;document id&amp;gt;, &amp;lt;workspace id&amp;gt;, &amp;lt;element id&amp;gt;, and &amp;lt;server id&amp;gt;:&lt;/p>
&lt;ul>
&lt;li>are originally included as query parameters in the action URL used to request the content of the application extension&lt;/li>
&lt;li>must be included in messages sent to the Onshape client&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>Note:&lt;/strong>&lt;/em> while initialization is the specific intent of the &lt;code>applicationInit&lt;/code> message, other supported &lt;code>messageName&lt;/code> attributes have the same initialization effect upon their first receipt by the Onshape client.&lt;/p>
&lt;/blockquote>
&lt;p>Next, as the user interacts with Onshape by selecting various parts of the model, messages with the &lt;code>messageName&lt;/code> attribute set to &lt;code>SELECTION&lt;/code> are sent to the application extension. The following is an example of one such message:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageName: &lt;span style="color:#a50">&amp;#39;SELECTION&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selections: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectionType: &lt;span style="color:#a50">&amp;#39;ENTITY&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectionId: &lt;span style="color:#a50">&amp;#39;KRiB&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entityType: &lt;span style="color:#a50">&amp;#39;FACE&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> occurrencePath: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a50">&amp;#39;MfOieM8xKIDGHe37c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workspaceMicroversionId: &lt;span style="color:#a50">&amp;#39;a781c53fbd1095e3462d2b70&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectionType: &lt;span style="color:#a50">&amp;#39;ENTITY&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectionId: &lt;span style="color:#a50">&amp;#39;KRdC&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entityType: &lt;span style="color:#a50">&amp;#39;EDGE&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> occurrencePath: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a50">&amp;#39;MfOieM8xKIDGHe37c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workspaceMicroversionId: &lt;span style="color:#a50">&amp;#39;a781c53fbd1095e3462d2b70&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="example-code-snippet">Example Code Snippet&lt;/h4>
&lt;p>The following is an example of how one might send an initialization message to, and handle post messages from the Onshape client.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>Note:&lt;/strong>&lt;/em> Proper clean-up of event listeners is not included in the snippet&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">function&lt;/span> handlePostMessage(event) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aaa;font-style:italic">// ensure that the event data is from a legit source:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> &lt;span style="color:#00a">if&lt;/span>(theServerStringFromActionUrl !== event.origin) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.error(&lt;span style="color:#a50">&amp;#39;origin of message is not legitimate&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#aaa;font-style:italic">// branch based on messageName attribute
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> &lt;span style="color:#00a">switch&lt;/span>(event.data.messageName) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">case&lt;/span> &lt;span style="color:#a50">&amp;#39;SELECTION&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.debug(&lt;span style="color:#a50">&amp;#39;SELECTION event data: %o&amp;#39;&lt;/span>, event.data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.debug(&lt;span style="color:#a50">`&lt;/span>&lt;span style="color:#a50">${&lt;/span>event.data.messageName&lt;span style="color:#a50">}&lt;/span>&lt;span style="color:#a50"> not handled`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0aa">window&lt;/span>.addEventListener(&lt;span style="color:#a50">&amp;#39;message&amp;#39;&lt;/span>, handlePostMessage);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> initMessage = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> documentId: theDocumentId, &lt;span style="color:#aaa;font-style:italic">// required - parsed from action url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> workspaceId: theWorkspaceId, &lt;span style="color:#aaa;font-style:italic">// required - parsed from action url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> elementId: theElementId, &lt;span style="color:#aaa;font-style:italic">// required - parsed from action url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> messageName: &lt;span style="color:#a50">&amp;#39;applicationInit&amp;#39;&lt;/span> &lt;span style="color:#aaa;font-style:italic">// required
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0aa">window&lt;/span>.parent.postMessage(initMessage, &lt;span style="color:#a50">&amp;#39;*&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="general">General&lt;/h2>
&lt;p>&lt;strong>Keyboard Focus / Shortcut Keys&lt;/strong>&lt;/p>
&lt;p>Keyboard focus will not be transferred to an application until the user clicks in the application or the application programmatically takes focus. The simplest thing is an application should programmatically take focus when it is first loaded and then also take focus when it receives a &amp;ldquo;show&amp;rdquo; message from Onshape. If an application does this, then shortcut keys will work immediately when the application is shown.&lt;/p>
&lt;p>&lt;strong>Future Notes&lt;/strong>&lt;/p>
&lt;p>New message types will be added as needed. If your application extension needs a message not listed in this document, please notify Onshape and weâ€™ll work with you on it.&lt;/p>
&lt;p>Mobile client support is unclear at this time.&lt;/p>
&lt;p>Onshape is considering using promises to wrap post messages. This would make the application extension&amp;rsquo;s JavaScript simpler and enables chaining posts with other operations. But promises would make some sorts of interactions where there are multiple responses difficult, such as when you open a dialog like the select item dialog and want to receive multiple post messages back due to the user clicking on multiple items in the dialog.&lt;/p></description></item><item><title>Docs: Feature List API</title><link>https://onshape-public.github.io/docs/featureaccess/</link><pubDate>Mon, 18 May 2020 20:37:28 -0400</pubDate><guid>https://onshape-public.github.io/docs/featureaccess/</guid><description>
&lt;p>Onshape Part Studio Feature Access API&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>The Onshape Part Studio tab tracks edits in terms of a feature list. Creation and modification of geometry is
performed by manipulating that list. This document describes capabilities that are intended to allow partners
and customers to manipulate the feature list from software.&lt;/p>
&lt;p>The feature API comprises the following API methods:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>GET /api/partstudios/DWMVE/features - get feature list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GET /api/partstudios/DWMVE/featurespecs - get feature specs&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWE/features - add feature to feature list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWE/features/featureid/:fid - update an existing feature in feature list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELETE /api/partstudios/DWE/features/featureid/:fid - delete an existing feature from feature list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWE/features/features/updates - selectively update features in feature list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWE/features/rollback - move the rollback bar&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWMVE/featurescript - evaluate featurescript&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>As well as related configuration API methods:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>GET /api/partstudios/DWMVE/configuration - get part studio configuration&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST /api/partstudios/DWE/configuration - update part studio configuration&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Note that the use of &amp;ldquo;DWE&amp;rdquo; occurrences within this document are a shorthand notation for â€œd/:did/w/:wid/e/:eidâ€
and DWMVE occurrences within this document are a shorthand notation for any of â€œd/:did/w/:wid/e/:eidâ€,
â€œd/:did/v/:vid/e/:eidâ€, â€œd/:did/m/:mid/e/:eidâ€. It is assumed that the reader is familiar with these URL path patterns
from the Glassworks API Explorer documentation.&lt;/p>
&lt;h2 id="api-methods">API Methods&lt;/h2>
&lt;p>The methods described here are also documented at an overview level in the Glassworks API Explorer within the Part Studios group.&lt;/p>
&lt;h3 id="get-feature-list">Get Feature List&lt;/h3>
&lt;pre>&lt;code>GET /api/partstudios/DWMVE/features - get feature list
&lt;/code>&lt;/pre>
&lt;p>If you have a part studio ekement, you can call the get feature list api to find the features that are instantiated within the part studio.
The return structure contains the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>features - A list of user-define features in the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>defaultFeatures - A list of the default feature (pre-defined) in the part studio&lt;/p>
&lt;/li>
&lt;li>
&lt;p>imports - A list of capabilities that may be referenced by the features. We currently only support a specific
predefined set of geometry capabilities.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>featureStates - A list of feature states, one per feature, which describe whether the feature is valid. If a feature
has been added to the feature list with an incorrect definition it remains in the feature list.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>isComplete - A boolean indicating whether the features represents the entire part studio (true) or is only a subset
(false). The result is a subset if the call to the api specifies a filter on the feature ids&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rollbackIndex - The ordinal position of the rollback bar w.r.t. the list of features. Onshape only executes features
that are prior to the rollback bar.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion - A string identifying the version of the structure serialization rules used to encode the
output. This is included so that if the output is fed back in and the software has changed incompatibilities can be
detected&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - The microversion identifier for the document that describes the state from which the result was
extracted. This is critical when attempting to use geometry ids that are included in the output, since the
interpretation of a geometry id is dependent on the document microversion.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libraryVersion - An integer indicating the version number for FeatureScript in the Part Studio&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="get-feature-specs">Get Feature Specs&lt;/h3>
&lt;pre>&lt;code>GET /api/partstudios/DWMVE/featurespecs - get feature specs
&lt;/code>&lt;/pre>
&lt;p>Returns a list of feature specs that are available within the part studio. A feature spec provides a data description
of the interface to a feature. This can, in theory, allow an application to use introspection to allow dynamically
generated features. In practice, we expect that the application developer understands the features ahead of time and
might utilize the feature spec to understand the options available and the required format for feature
addition/modification.&lt;/p>
&lt;h3 id="add-feature">Add Feature&lt;/h3>
&lt;pre>&lt;code>POST /api/partstudios/DWE/features
&lt;/code>&lt;/pre>
&lt;p>A feature can be added to the feature list by calling the add feature API. The API accepts as input a JSON structure
containing the fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>feature - A single feature definition, in the same format that is output by the get feature list API, except that
there is no need to provide feature ids, node ids, or typeNames.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - The microversion of the document that is assumed. Any geometry ids included in the feature are
interpreted in the context of this microversion.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rejectMicroversionSkew (optional) - If set to true, the call will refuse to make the addition if the current
microversion for the document does not match the source Microversion. Otherwise, a best-effort attempt is made to
re-interpret the feature addition in the context of a newer document microversion.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The call returns a structure with the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>feature - The input feature, echoed back with id value assignments in place&lt;/p>
&lt;/li>
&lt;li>
&lt;p>featureState - The state of the feature&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - The microversion of the document in which the returned feature is defined&lt;/p>
&lt;/li>
&lt;li>
&lt;p>microversionSkew - If rejectMicroversionSkew was not set to true on input and the document microversion had changed
since the input sourceMicroversion, this is set to true to indicate that a re-interpretation was made.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libraryVersion - An integer indicating the version number for FeatureScript in the Part Studio&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The feature is added immediately before the rollback bar. Any geometry ids specified in the feature must be valid at
that point in the feature tree. For example, if applying a fillet to an edge, that edge must exist in the feature tree.
Filleting the edge will normally make it invalid at future states of the feature tree, since the fillet feature
removes the edge.&lt;/p>
&lt;h3 id="update-feature">Update Feature&lt;/h3>
&lt;pre>&lt;code>POST /api/partstudios/DWE/features/featureid/:fid
&lt;/code>&lt;/pre>
&lt;p>An existing feature can be modified by calling the update feature API. This API accepts the same input body format and
returns the same output format as the Add Feature API. However, instead of adding a new feature prior to the rollback
bar location, it replaces an existing feature in the location of the existing feature.&lt;/p>
&lt;h3 id="update-features">Update Features&lt;/h3>
&lt;pre>&lt;code>POST /api/partstudios/DWE/features/updates
&lt;/code>&lt;/pre>
&lt;p>Multiple existing features can be modified by calling the update features API. This API accepts a list of features and to update, which must already exist in the part studio. This call does not fully re-define the features but instead, updates only the parameters supplied in the top-level feature structure, and optionally will update feature suppression attributes.&lt;/p>
&lt;p>Applications that need to update parameters for multiple features can typically achieve faster model rebuild time by updating multiple features in a single call. It also has the benefit that it allows features to be suppressed or unsuppressed without specifying parameters. This is particularly useful in the unsuppress case because parameters containing query values are not populated when reading from the feature list.&lt;/p>
&lt;h3 id="delete-feature">Delete Feature&lt;/h3>
&lt;pre>&lt;code>DELETE /api/partstudios/DWE/features/featureid/:fid
&lt;/code>&lt;/pre>
&lt;p>An existing feature can be removed from the feature list by calling the delete feature API. The API accepts only URL
path parameters and return only the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>serializationVersion - As described earlier&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - As described earlier&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="move-rollback-bar">Move Rollback Bar&lt;/h3>
&lt;pre>&lt;code>POST /api/partstudios/DWE/features/rollback
&lt;/code>&lt;/pre>
&lt;p>The rollback bar can be moved using this API. This is useful if a feature needs to be added at a location other than
the current rollback bar location. As input, it accepts the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>rollbackIndex - The index at which the rollback index should be placed. Features with entry index (0-based) higher
than or equal to this value are rolled back. The value must be in the range 0 to the number of entries in the feature
list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion&lt;/p>
&lt;p>The result returned by the API includes the fields&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rollbackIndex - The rollback index in the updated state&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>microversionSkew - As described previously&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="evaluate-featurescript">Evaluate FeatureScript&lt;/h3>
&lt;pre>&lt;code>POST api/partstudios/DWMVE/featurescript
&lt;/code>&lt;/pre>
&lt;p>This API allows the caller to execute a FeatureScript function to query information about the existing feature tree
that is not exposed through the other methods described here. As input, it accepts the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>script - The definition of a FeatureScript function that takes a Context argument and a map argument&lt;/p>
&lt;/li>
&lt;li>
&lt;p>queries - A list of key, value pairs, where the key is a FeatureScript identifier that will appear as a key in the
map supplied to the script function and the valid is a list of geometry Id strings, where the list is converted to
&amp;ldquo;query&amp;rdquo; form form use within the script function.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>See the example below to better understand this usage.&lt;/p>
&lt;h2 id="configuration-api-methods">Configuration API Methods&lt;/h2>
&lt;p>Part Studios may be unconfigured or configured. A configured part studio has a list of configuration parameters that
define the knobs that allow adjustment of the part studio part content. Configuration parameters are referred to as
&amp;ldquo;inputs&amp;rdquo; in the UI and may be one of Enum (or List), Boolean, Quantity or String. Each parameter includes a default
value setting that is used if the parameter is not otherwise set.&lt;/p>
&lt;p>Configured part studios also have a &amp;ldquo;current&amp;rdquo; configuration. This is a list of configuration parameter settings for
the current representation of the part studio. Alternate configurations of the part studio may be used concurrently,
but the current configuration defines the parts seen by the user within in the part studio.&lt;/p>
&lt;h3 id="get-configuration">Get Configuration&lt;/h3>
&lt;pre>&lt;code>GET /api/partstudios/DWMVE/configuration - get part studio configuration
&lt;/code>&lt;/pre>
&lt;p>This method reads the current configuration information for a Part Studio.
The return structure contains the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>configurationParameters - A list of the parameters that allow configuration of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>currentConfiguration - A list of configuration parameter settings for the current representation of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>microversionSkew - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libraryVersion - As described previously&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="update-configuration">Update Configuration&lt;/h3>
&lt;pre>&lt;code>POST /api/partstudios/DWE/configuration - update part studio configuration
&lt;/code>&lt;/pre>
&lt;p>This method modifies the current configuration information for a Part Studio. When changing configuration parameters
it is important that parameterId values be maintained consistently across changes so that features that reference the
parameter do not get broken.
The API accepts as input a JSON structure containing the fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>configurationParameters - A list of the parameters that allow configuration of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>currentConfiguration - A list of configuration parameter settings for the current representation of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion (optional) - The microversion of the document that is assumed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rejectMicroversionSkew (optional) - If set to true, the call will refuse to make the addition if the current
microversion for the document does not match the source Microversion.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The call returns a structure with the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>configurationParameters - A list of the parameters that allow configuration of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>currentConfiguration - A list of configuration parameter settings for the current representation of the part studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>serializationVersion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sourceMicroversion - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>microversionSkew - As described previously&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libraryVersion - As described previously&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="api-usage-details">API Usage Details&lt;/h2>
&lt;p>The feature access and modification API in Onshape presents the internal form of feature definitions rather than
providing a translation layer between external form and internal form. We suggest that you familiarize yourself with
the formats involved by calling the Get Feature List API on existing part studios in order to understand the encoding
of features.&lt;/p>
&lt;p>Some important things to know about the JSON encoding are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Default values are omitted in the encoded output. For string fields the default value is &amp;ldquo;&amp;rdquo;, for boolean fields it
is false, and for numeric fields it is 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It uses a special tagging system in order to manage polymorphic data structures. Specifically, objects generally
are encoded by enclosing them within another object that declares the type information for the enclosed object.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>As an example of the type tagging mechanism, the GET features api might return a structure that looks like this:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;features&amp;quot;: [
{
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;featureId&amp;quot;: &amp;quot;FLqo5rpNof3IXgh_0&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1.0*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;,
&amp;quot;nodeId&amp;quot;: &amp;quot;TyUNOSxJ/f9z5t1T&amp;quot;
}
}
],
&amp;quot;nodeId&amp;quot;: &amp;quot;Mr60Xw6RGWdr0MfYV&amp;quot;
}
}
],
&amp;quot;imports&amp;quot;: [
{
&amp;quot;type&amp;quot;: 136,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMImport&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;path&amp;quot;: &amp;quot;onshape/std/geometry.fs&amp;quot;,
&amp;quot;version&amp;quot;: &amp;quot;268.0&amp;quot;,
&amp;quot;nodeId&amp;quot;: &amp;quot;M2/0RrOwK0Q+hWr9z&amp;quot;
}
}
],
&amp;quot;featureStates&amp;quot;: [
{
&amp;quot;key&amp;quot;: &amp;quot;FLqo5rpNof3IXgh_0&amp;quot;,
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 1688,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFeatureState&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureStatus&amp;quot;: &amp;quot;OK&amp;quot;
}
}
}
],
&amp;quot;isComplete&amp;quot;: true,
&amp;quot;rollbackIndex&amp;quot;: 1,
&amp;quot;serializationVersion&amp;quot;: &amp;quot;1.1.6&amp;quot;,
&amp;quot;sourceMicroversion&amp;quot;: &amp;quot;b5b4834bd0674b4489b2b2b7&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>We see that in this case, the features array contains a single feature. The &amp;ldquo;type&amp;rdquo; and &amp;ldquo;typeName&amp;rdquo; fields describe the
type that is encoded within the &amp;ldquo;message&amp;rdquo; field. The &amp;ldquo;type&amp;rdquo; field provides definitive type information and is the type
number assigned to the structure. This type number is a permanent assignment. The &amp;ldquo;typeName&amp;rdquo; field is a convenience
field that is generated on output and ignored on input. It is intended to allow developers to associate meaningful
names with the type numbers.&lt;/p>
&lt;h3 id="general-features">General Features&lt;/h3>
&lt;p>In the example above, we see that the single feature is of type 134, which is the general feature type. A general
feature is an instantiation of the feature template that is describe by its corresponding feature spec. The BTMFeature
structure includes the following fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>featureType - Specifies the name of the feature spec that this instantiates&lt;/p>
&lt;/li>
&lt;li>
&lt;p>featureId - The internal identifier of the feature instance within this part studio. It is internally generated when
a feature is added.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nodeId - An internal identifier for the feature node. This is also internally generated when the feature is added.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>name - The user visible name of the feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>namespace - An indicator of where the feature definition can be found. Features in the FeatureScript standard library
have a namespace value of &amp;quot;&amp;quot; whereas custom features identify the featurestudio that contains the definition. See
the Custom Features section below for more information.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>parameters - A list of parameter values for instantiation of the feature spec. Parameters are present for all
defined parameters, even if not used in a specific instantiation.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>All parameters have the following fields in common:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>parameterId - The name of the parameter spec that this applies to&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nodeId - An internal identifier for the parameter node&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Parameters are typically one of the following types:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BTMParameterQuantity (type 147) - specifies the value for a parameter defined in the feature spec as a
BTParameterSpecQuantity. It has the field:&lt;/p>
&lt;ul>
&lt;li>expression - An expression defining the value for the parameter.&lt;/li>
&lt;/ul>
&lt;p>An example of its usage is in the depth parameter in the extrude feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTMParameterQueryList (type 148) - specifies the value for a parameter defined in the feature spec as a
BTParameterSpecQuery. It has the field:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>queries - a list of query objects. The query objects could be either&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SBTMIndividualQuery objects (type 138) with the field:&lt;/p>
&lt;ul>
&lt;li>geometryIds - A list of geometry id values indentifying geometry that the feature applies to.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SBTMIndividualSketchRegionQuery objects (type 140) with the field:&lt;/p>
&lt;ul>
&lt;li>featureId - The featureId of a sketch, with the query identifying all regions of the sketch&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>An example of its usage is in the entities parameter in the extrude feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTMParameterBoolean (type 144) - specifies the value for a parameter defined in the feature spec as a
BTParameterSpecBoolean. It has the field:&lt;/p>
&lt;ul>
&lt;li>value - The boolean value&lt;/li>
&lt;/ul>
&lt;p>An example of its usage is in the oppositeDirection parameter in the extrude feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTMParameterEnum (type 145) - specifies the value for a parameter defined in the feature spec as a
BTParameterSpecEnum. It has the fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>enumName - The name of the enum type that value is a member of&lt;/p>
&lt;/li>
&lt;li>
&lt;p>value - The name of the enum member&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>An example of its usage is in the bodyType parameter in the extrude feature.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Other parameter types exist for special cases and are not described here.&lt;/p>
&lt;h3 id="sketches">Sketches&lt;/h3>
&lt;p>Although most features are of type BTMFeature, there is also a BTMSketch type, which defines a sketch. The structure
of a sketch feature extends the BTMFeature and is relatively complex. It is suggested that the developer use a manually
edited sketch as a template for any sketches that they want to create programmatically. However, we will give a
high-level overview of the content for the sketch.&lt;/p>
&lt;p>Sketches have top-level fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>entities - the sketch geometry&lt;/p>
&lt;/li>
&lt;li>
&lt;p>constraints - the geometric relationship constraints and dimensions for the sketch&lt;/p>
&lt;/li>
&lt;li>
&lt;p>parameters - the sketch parameters. The only parameter is the parameter that identifies the sketch plane&lt;/p>
&lt;/li>
&lt;li>
&lt;p>featureType - set to &amp;ldquo;newSketch&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>featureId - the feature id&lt;/p>
&lt;/li>
&lt;li>
&lt;p>name - the sketch name&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The entities describe curves in terms of unbounded curves plus parameterized ranges. The geometry is always specified
in meters, regardless of the userâ€™s choice of units. This geometry provides an initial guess for the sketch. The actual
solve state may differ, depending on whether the input constraints are satisfied.&lt;/p>
&lt;p>The constraints describe the requirements for sketch solution. These typically include constraints such as COINCIDENT,
HORIZONTAL, VERTICAL, PARALLEL, PERPENDICULAR, TANGENT that control geometric positioning and constraints such as
DISTANCE, RADIUS, DIAMETER, ANGLE that provide dimensional constraints. The constraints typically have one or two
objects that are constrained. These are referenced as localFirst for the first constrained entity, which is within
the sketch, and either localSecond or externalSection, depending on whether the second constrained entity is local
to the sketch. When entities are local to the sketch they are identitified by entity ids (long unique names) and when
external they are identified by a BTMIndiviualQuery.&lt;/p>
&lt;h2 id="feature-specs">Feature Specs&lt;/h2>
&lt;p>The feature spec for a feature provides a description of the inputs that it accepts. As an example, the feature spec
for a cube is shown below. It defines a single parameter named &amp;ldquo;sideLength&amp;rdquo;. The parameter spec includes a list of
ranges that specify valid ranges for the parameter value. Each range is specific to a particular unit and has a
defaultValue for that unit. Some parameters described by the feature spec may be optional. These normally have a
visibilityCondition that describes a logical test as to whether the parameter should be exposed for editing, based on
other parameter values. This provides a fairly reliable way to determine whether the parameter is required for a
particular feature instance, but it is safe to include default values for a feature even if it has a
visibilityCondition that indicates it is not visible.&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;type&amp;quot;: 129,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFeatureSpec&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;featureTypeName&amp;quot;: &amp;quot;Cube&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 173,
&amp;quot;typeName&amp;quot;: &amp;quot;BTParameterSpecQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;quantityType&amp;quot;: &amp;quot;LENGTH&amp;quot;,
&amp;quot;ranges&amp;quot;: [
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;meter&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.00001,
&amp;quot;maxValue&amp;quot;: 500,
&amp;quot;defaultValue&amp;quot;: 0.025,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;PX2DsNKne8oO7ilPS&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;t8iQqgzAr/bCB2AZ&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;centimeter&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.001,
&amp;quot;maxValue&amp;quot;: 50000,
&amp;quot;defaultValue&amp;quot;: 2.5,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;PKXPCya7aeoNITDFW&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;69sE3wOlv3FLiJxn&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;millimeter&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.01,
&amp;quot;maxValue&amp;quot;: 500000,
&amp;quot;defaultValue&amp;quot;: 25,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;P8uyYds3YIBBpzlVN&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;8huKnMQb9mH9B+ef&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;inch&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.0003937007874015748,
&amp;quot;maxValue&amp;quot;: 19685.03937007874,
&amp;quot;defaultValue&amp;quot;: 1,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;P4MfX8crrr+qc9vFS&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;BMU3SmZpR83uoKkd&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;foot&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.00003280839895013123,
&amp;quot;maxValue&amp;quot;: 1640.4199475065616,
&amp;quot;defaultValue&amp;quot;: 0.1,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;P60BmwPj7LnRT0CTh&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;ywVSbQADr8dRv9+s&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 181,
&amp;quot;typeName&amp;quot;: &amp;quot;BTQuantityRange&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;yard&amp;quot;,
&amp;quot;minValue&amp;quot;: 0.000010936132983377077,
&amp;quot;maxValue&amp;quot;: 546.8066491688538,
&amp;quot;defaultValue&amp;quot;: 0.025,
&amp;quot;location&amp;quot;: {
&amp;quot;type&amp;quot;: 226,
&amp;quot;typeName&amp;quot;: &amp;quot;BTLocationInfo&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;document&amp;quot;: &amp;quot;onshape/std/primitives.fs&amp;quot;,
&amp;quot;parseNodeId&amp;quot;: &amp;quot;PsE6sGD66MJVH2xQh&amp;quot;,
&amp;quot;languageVersion&amp;quot;: 268,
&amp;quot;nodeId&amp;quot;: &amp;quot;zAy0tYs5aC0clPLL&amp;quot;
}
}
}
}
],
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;,
&amp;quot;parameterName&amp;quot;: &amp;quot;Side length&amp;quot;,
&amp;quot;defaultValue&amp;quot;: {
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;units&amp;quot;: &amp;quot;meter&amp;quot;,
&amp;quot;value&amp;quot;: 0.025,
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;,
&amp;quot;nodeId&amp;quot;: &amp;quot;MC6QUqafapZdxtrDy&amp;quot;
}
}
}
}
]
}
}
&lt;/code>&lt;/pre>
&lt;p>Visibility conditions come in 3 variants:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BTParameterVisibilityAlwaysHidden - Special-case parameters that are not directly shown to the user&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterVisibilityLogical - Allows a logical condition to express when a parameter is visible. Allows nested
AND/OR/NOT expressions. The leaves of the expression tree are BTParameterVisibilityOnEqual&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterVisibilityOnEqual - A simple test that a parameter has been assigned a specific value.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>A ParameterSpec can be one of numerous types. The most commonly used types are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BTParameterSpecQuery - indicates that a query parameter should be supplied. The parameter spec has an allowable
number of selections and query filter that describes the allowable types that can be selected. See below for
additional information about query filters. An example usage is identifying the entities to chamfer in a &amp;ldquo;Chamfer&amp;rdquo;
feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecString - indicates that a string value should be supplied. For example, this is used for the name of
a variable in a &amp;ldquo;Variable&amp;rdquo; feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecQuantity - indicates that a number value should be supplied. In allows a quantityType, which describes
the type of number (length, angle, mass, count, etc.) and range limits on the value. An example usage is the depth
parameter in an &amp;ldquo;Extrude&amp;rdquo; feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecEnum - indicates that an enumerated value should should be provided. An example usage is the
operationType parameter in an &amp;ldquo;Extrude&amp;rdquo; feature.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecBoolean - indicates that a boolean true/false value should be specified. An example usage is the
offset parameter in the &amp;ldquo;Boolean&amp;rdquo; feature&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Some less commonly used parameter spec types are:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BTParameterSpecDerived - indicates that an import of a part from another Part Studio should be specified.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecLookupTablePath - provides a list of string values that can be chosen.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTParameterSpecForeignId - indicates that a &amp;ldquo;foreign id&amp;rdquo; value should be supplied. Foreign ids are currently not
generally accessible through the API, but identify a file that is made available throughout the system.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Parameter Spec query filters:&lt;/p>
&lt;p>Query Filters are even more numerous than parameter spec types.&lt;/p>
&lt;p>Basic selections:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BTBodyTypeFilter - a specific body type (solid, sheet, wire, acorn, mate_connector)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTClosedCurveFilter - a curve that is either closed or not closed, depending on the isClosed value. (NO)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTConstructionObjectFilter - an object that either is or is not identified as &amp;ldquo;construction&amp;rdquo;, depending on the
isConstruction value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTEdgeTopologyFilter - an edge that either is or is not an internal edge, depending on the isInternalEdge value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTEntityTypeFilter - selects a specific type of entity based on the entityType value (vertex, edge, face, body,
degenerate_edge).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTFeatureTypeFilter - selects a specific type of feature base on the featureType value. (NO)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTGeometryFilter - select specific geometry types based on the geometryType value (line, circle, arg, plane,
cylinder,cone sphere torus, spline, ellipse).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTImageFilter - an entity that either is or is not an image, based on the isImage value. (no)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTMateConnectorFilter - a mate connector (NO)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTMateFilter - a mate object&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTPlaneOrientationFilter - excludes planes that are aligned with another plane, based on the normal value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTSketchObjectFilter - an object that either is or is not a sketch object, or is a sketch object created by the
user, depending on the objectType value (not_sketch_object, any_sketch_object, user_entity).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTTextObjectFilter - an object that either is or is not a text object, depending on the isText value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BTTextStrokeFilter - an object that either is or is not a text stroke, depending on the isStroke value.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Logical operations:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SBTAndFilter - combines query filters with &amp;ldquo;AND&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SBTOrFilter - combines query filters with &amp;ldquo;OR&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SBTNotFilter - negates query filters&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="feature-script-evaluation">Feature Script Evaluation&lt;/h2>
&lt;p>For certain tasks when creating and updating features, there may be information needed that is embedded within the
existing model. You can often access it by running a Feature Script function. Feature Script is a language that is
used to define the behavior of features.&lt;/p>
&lt;p>As an example of its usage, consider the case of using a face of an existing part to define new geometry. A plane is
defined in FeatureScript as an origin, x-direction vector and normal vector. These can be queried from FeatureScript
by using the evPlane function, but it wants a &amp;ldquo;query&amp;rdquo; that identifies the face. Here is an example of how you might do
this with a call to the Evaluate FeatureScript API call. Suppose you know that â€œJCCâ€ is the geometry Id of a particular
face. The following body can be passed to the evaluate function.&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;script&amp;quot; : &amp;quot;function (context is Context, queries is map) {
return evPlane(context, {face:queries.id});
}&amp;quot;,
&amp;quot;queries&amp;quot; : [ { &amp;quot;key&amp;quot; : &amp;quot;id&amp;quot;, &amp;quot;value&amp;quot; : [ &amp;quot;JCC&amp;quot; ] } ]
}
&lt;/code>&lt;/pre>
&lt;p>Assuming that we have done everything right, the output of this might look something like this:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;result&amp;quot;: {
&amp;quot;type&amp;quot;: 2062,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueMap&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: [
{
&amp;quot;type&amp;quot;: 2077,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueMapEntry&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;key&amp;quot;: {
&amp;quot;type&amp;quot;: 1422,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;normal&amp;quot;
}
},
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 1499,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueArray&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: [
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: -1
}
},
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {}
},
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {}
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;Vector&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 2077,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueMapEntry&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;key&amp;quot;: {
&amp;quot;type&amp;quot;: 1422,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;origin&amp;quot;
}
},
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 1499,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueArray&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: [
{
&amp;quot;type&amp;quot;: 1817,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueWithUnits&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;unitToPower&amp;quot;: [
{
&amp;quot;key&amp;quot;: &amp;quot;METER&amp;quot;,
&amp;quot;value&amp;quot;: 1
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;ValueWithUnits&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 1817,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueWithUnits&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: 0.012700000000000001,
&amp;quot;unitToPower&amp;quot;: [
{
&amp;quot;key&amp;quot;: &amp;quot;METER&amp;quot;,
&amp;quot;value&amp;quot;: 1
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;ValueWithUnits&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 1817,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueWithUnits&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: 0.012700000000000001,
&amp;quot;unitToPower&amp;quot;: [
{
&amp;quot;key&amp;quot;: &amp;quot;METER&amp;quot;,
&amp;quot;value&amp;quot;: 1
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;ValueWithUnits&amp;quot;
}
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;Vector&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 2077,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueMapEntry&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;key&amp;quot;: {
&amp;quot;type&amp;quot;: 1422,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;x&amp;quot;
}
},
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 1499,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueArray&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: [
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {}
},
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: -1
}
},
{
&amp;quot;type&amp;quot;: 772,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueNumber&amp;quot;,
&amp;quot;message&amp;quot;: {}
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;Vector&amp;quot;
}
}
}
}
],
&amp;quot;typeTag&amp;quot;: &amp;quot;Plane&amp;quot;
}
},
&amp;quot;serializationVersion&amp;quot;: &amp;quot;1.1.6&amp;quot;,
&amp;quot;sourceMicroversion&amp;quot;: &amp;quot;27db48fb62bf6ac3b3ddaeaa&amp;quot;,
&amp;quot;libraryVersion&amp;quot;: 296
}
&lt;/code>&lt;/pre>
&lt;p>You can see from the output that the FeatureScript object representation uses the same typing rules that is used for
other output. In addition, FeatureScript objects may have a typeTag field associated with them, which indicates that
type-specific behavior should be applied. For instance, we see cases where a BTFSValueArray has a typeTag of &amp;ldquo;Vector&amp;rdquo;,
which allows the array to be accepted where a Vector is declared to be required.&lt;/p>
&lt;p>In order to help describe the interpretation of the structure above, here is a possible JSON representation of the
result from the output shown above, but with weaker typing:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;normal&amp;quot; : [ -1, 0, 0 ],
&amp;quot;origin&amp;quot; : { &amp;quot;value&amp;quot; : [ 0,
0.012700000000000001,
0.012700000000000001 ],
&amp;quot;units&amp;quot; : &amp;quot;meter&amp;quot; },
&amp;quot;x&amp;quot; : [ 0, -1, 0 ]
}
&lt;/code>&lt;/pre>
&lt;h2 id="custom-features">Custom Features&lt;/h2>
&lt;p>Custom features can be used in the feature apis with a little additional work. The key to using custom features is
that you must set a namespace field in the feature to tell Onshape where to look for the feature defintion.
The namespace field identifies a specific version of a feature studio. There are two standard forms for the namespace
field to consider:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Intra-workspace - In this case, the namespace field has the form
&amp;ldquo;e&lt;elementId>::m&lt;microversionId>&amp;rdquo;
where elementId is the elementId of the FeatureStudio that defines the feature and microversionId is the element
microversionId of the FeatureStudio. It is important to note that the element microversionId is different from the
document microversionId that is more typically encountered in API usage.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>External - When the definition to be used lives in a different document or in a specific version of the current
document it is referenced using the form
&amp;ldquo;d&lt;documentId>::v&lt;versionId>::e&lt;elementId>::m&lt;microversionId>&amp;rdquo;
This is the same form as for the intra-workspace case but with a documentId and versionId additionally specified.
The documentId is the id of the document containing the FeatureStudio and the versionId is the version of the
document to be used.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>In both of the forms listed, it is necessary to determine the FeatureStudio element microversionId. One way to do this
is to call the GET /api/documents/DWMV/elements API, which reports the element microversion for each of the elements.
There is also a GET /api/featurestudios/DWMV/featurespecs API that provides a featurespec for each of the features
defined in the FeatureStudio. These featurespecs also have a namespace field that reports the namespace of the
FeatureStudio in the intra-workspace form.&lt;/p>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>Below are several examples of how the API can be used in order to help you get started. The examples are quite trivial,
but should provide a basic demonstration of how to use these API methods. You should be able to execute the calls
against a part studio of yours and see results immediately. The calls could be executed using your preferred software
environment but interactive use in a REST-aware tool is likely the easiest way to try the examples.&lt;/p>
&lt;h3 id="example-1">Example 1&lt;/h3>
&lt;p>In our first example we will create a cube using the cube feature. The feature accepts only a single parameter, which
is the length of a side, and creates a cube with a corner at the origin and aligned with the three default planes. In
running the example, be sure to replace DWE with the the d/:did/w/:wid/e/:eid that is appropriate for the part studio
that you are operating against.&lt;/p>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;p>This returns output similar to the following:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot;: {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;featureId&amp;quot;: &amp;quot;FuJu9c8PvO5oyTgaV&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;,
&amp;quot;nodeId&amp;quot;: &amp;quot;M+iZRdlIZjnuz8DSS&amp;quot;
}
}
],
&amp;quot;nodeId&amp;quot;: &amp;quot;MUdiYYWlCa3arVy8q&amp;quot;
}
},
&amp;quot;featureState&amp;quot;: {
&amp;quot;type&amp;quot;: 1688,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFeatureState&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureStatus&amp;quot;: &amp;quot;OK&amp;quot;
}
},
&amp;quot;serializationVersion&amp;quot;: &amp;quot;1.1.6&amp;quot;,
&amp;quot;sourceMicroversion&amp;quot;: &amp;quot;2d31ccc170551a83995b89c8&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>The output returns us the feature definition that we provided as input with nodeIds and a featureId, plus information
telling us that that the feature executed correctly and information about the serialization version and microversion of
the document that resulted from our feature addition.&lt;/p>
&lt;h3 id="example-2">Example 2&lt;/h3>
&lt;p>In our second example we will create a cube where the sideLength parameter is defined by a variable and will then
update the variable to have a new value.&lt;/p>
&lt;p>Step 1) Create a variable - we create a feature of type assignVariable, which defines a variable and assigns it a
value. Here, the variables name is &amp;ldquo;size&amp;rdquo; and is displayed in the feature list as &amp;ldquo;Cube size&amp;rdquo;, and it is assigned to
have the value &amp;ldquo;1*in&amp;rdquo; with a variableType of ANY. Once again, be sure to replace DWE with the the d/:did/w/:wid/e/:eid
that is appropriate for the part studio that you are operating against.&lt;/p>
&lt;p>A variable can be created with variableType set to &amp;ldquo;ANY&amp;rdquo;, &amp;ldquo;LENGTH&amp;rdquo;, &amp;ldquo;ANGLE&amp;rdquo;, or &amp;ldquo;NUMBER&amp;rdquo;. This supplies a constraint
on the supplied value and each type requires setting the appropriate corresponding parameter, which would be anyValue,
lengthValue, angleValue or numberValue, respectively in addition to setting the value parameter. For the intended
purpose of using it as a length value it might be more appropriate to use &amp;ldquo;LENGTH&amp;rdquo; as the type, which would require
setting the lengthValue and value parameters to a length value. We have chosen to demonstrate the use of the &amp;ldquo;ANY&amp;rdquo;
type here because it can be used in a wider range of applications than a &amp;ldquo;LENGTH&amp;rdquo; variable, but does not provide the
value type checking that is provided by &amp;ldquo;LENGTH&amp;rdquo;, &amp;ldquo;ANGLE&amp;rdquo; or &amp;ldquo;NUMBER&amp;rdquo; types.&lt;/p>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;assignVariable&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube size&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;VariableType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;ANY&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;variableType&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 149,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;size&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;name&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;anyValue&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;p>The returned structure will include a featureId value for the variable. Make note of this value and we will use it
in step 3 below.&lt;/p>
&lt;ol start="2">
&lt;li>Create the cube feature, referencing the variable created&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;#size&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>Update the variable to have a new value. We assume here that the featureId value returned in step 1 is
&amp;ldquo;FuJu9c8PvO5oyTgaV&amp;rdquo; and we will change the cube size from 1 inch to 10 centimeters.&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/features/featureid/FuJu9c8PvO5oyTgaV&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;assignVariable&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube size&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;VariableType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;ANY&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;variableType&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 149,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;size&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;name&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;10*cm&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;anyValue&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;p>Take a look at the part studio and you will see the cube at its new size. You can edit the Cube size variable and
change the value again.&lt;/p>
&lt;h3 id="example-3">Example 3&lt;/h3>
&lt;p>In this example, we create a Sketch and extrude it. This demonstrates relationships betweeen features. First, the
sketch must be created on a plane, and for convenience, we will use the pre-defined front plane. Then, the extrude
needs to describe what is to be extruded, and for convenience, we use the BTMIndividualSketchRegionQuery.&lt;/p>
&lt;ol>
&lt;li>Determine the geometryId for the front plane.&lt;/li>
&lt;/ol>
&lt;p>POST /api/features/DWE/featurescript&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;script&amp;quot; :
&amp;quot;function(context is Context, queries)
{
return transientQueriesToStrings(evaluateQuery(context, qCreatedBy(makeId(\&amp;quot;Front\&amp;quot;), EntityType.FACE)));
}&amp;quot;,
&amp;quot;queries&amp;quot; : []
}
&lt;/code>&lt;/pre>
&lt;p>This will likely return something like this:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;result&amp;quot;: {
&amp;quot;type&amp;quot;: 1499,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueArray&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: [
{
&amp;quot;type&amp;quot;: 1422,
&amp;quot;typeName&amp;quot;: &amp;quot;BTFSValueString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;JCC&amp;quot;
}
}
]
}
},
&amp;quot;serializationVersion&amp;quot;: &amp;quot;1.1.6&amp;quot;,
&amp;quot;sourceMicroversion&amp;quot;: &amp;quot;a53cabe7d36e30ee100b1d2a&amp;quot;,
&amp;quot;libraryVersion&amp;quot;: 298
}
&lt;/code>&lt;/pre>
&lt;p>This tells us that the geometryId for the face created by the &amp;ldquo;Front&amp;rdquo; feature is &amp;ldquo;JCC&amp;rdquo;.&lt;/p>
&lt;ol start="2">
&lt;li>Determine the geometryId for the Origin&lt;/li>
&lt;/ol>
&lt;p>POST /api/features/DWE/featurescript&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;script&amp;quot; :
&amp;quot;function(context is Context, queries)
{
return transientQueriesToStrings(evaluateQuery(context, qCreatedBy(makeId(\&amp;quot;Origin\&amp;quot;), EntityType.VERTEX)));
}&amp;quot;,
&amp;quot;queries&amp;quot; : []
}
&lt;/code>&lt;/pre>
&lt;p>This will report the geometryId for the origin (probably with the value &amp;ldquo;IB&amp;rdquo;) which we will use in the sketch.&lt;/p>
&lt;ol start="3">
&lt;li>Create the sketch. This will be just a circle on the front plane with its center at the origin and diameter of
1 inch.&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 151,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMSketch&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;entities&amp;quot;: [
{
&amp;quot;type&amp;quot;: 4,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMSketchCurve&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;geometry&amp;quot;: {
&amp;quot;type&amp;quot;: 115,
&amp;quot;typeName&amp;quot;: &amp;quot;BTCurveGeometryCircle&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;radius&amp;quot;: 0.025400000000000002,
&amp;quot;xDir&amp;quot;: 1,
&amp;quot;yDir&amp;quot;: 0
}
},
&amp;quot;centerId&amp;quot;: &amp;quot;clAhDfZz-Dgmb-d0AJ-01Cv-JINJdWZLbVj1.center&amp;quot;,
&amp;quot;entityId&amp;quot;: &amp;quot;clAhDfZz-Dgmb-d0AJ-01Cv-JINJdWZLbVj1&amp;quot;
}
}
],
&amp;quot;constraints&amp;quot;: [
{
&amp;quot;type&amp;quot;: 2,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMSketchConstraint&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;constraintType&amp;quot;: &amp;quot;COINCIDENT&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 149,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;clAhDfZz-Dgmb-d0AJ-01Cv-JINJdWZLbVj1.center&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;localFirst&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;queries&amp;quot;: [
{
&amp;quot;type&amp;quot;: 138,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMIndividualQuery&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;geometryIds&amp;quot;: [
&amp;quot;IB&amp;quot;
]
}
}
],
&amp;quot;parameterId&amp;quot;: &amp;quot;externalSecond&amp;quot;
}
}
],
&amp;quot;entityId&amp;quot;: &amp;quot;clAhDfZz-Dgmb-d0AJ-01Cv-JINJdWZLbVj1.centerSnap0&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 2,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMSketchConstraint&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;constraintType&amp;quot;: &amp;quot;DIAMETER&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 149,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterString&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: &amp;quot;clAhDfZz-Dgmb-d0AJ-01Cv-JINJdWZLbVj1&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;localFirst&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;length&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;0.637419526959446*rad&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;labelAngle&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1.76201395706607&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;labelRatio&amp;quot;
}
}
],
&amp;quot;entityId&amp;quot;: &amp;quot;22b5a2c0-d3ea-4376-969d-8b81944035b2&amp;quot;
}
}
],
&amp;quot;featureType&amp;quot;: &amp;quot;newSketch&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Sketch 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;queries&amp;quot;: [
{
&amp;quot;type&amp;quot;: 138,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMIndividualQuery&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;geometryIds&amp;quot;: [
&amp;quot;JCC&amp;quot;
]
}
}
],
&amp;quot;parameterId&amp;quot;: &amp;quot;sketchPlane&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>Create the extrude. Here we assume that the previous call returned the sketch with a feature id of
&amp;ldquo;Fj1THqyY7u36ktGSr&amp;rdquo;. The extrude uses the BTMIndividualSketchRegionQuery, identifying the sketch feature in order to
indicate what is to be extruded. The depth of extrude is 1 inch.&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot; : {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;extrude&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Extrude 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;ToolBodyType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;SOLID&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;bodyType&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;NewBodyOperationType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;NEW&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;operationType&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;queries&amp;quot;: [
{
&amp;quot;type&amp;quot;: 140,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMIndividualSketchRegionQuery&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureId&amp;quot;: &amp;quot;Fj1THqyY7u36ktGSr&amp;quot;
}
}
],
&amp;quot;parameterId&amp;quot;: &amp;quot;entities&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;BoundingType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;BLIND&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;endBound&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;depth&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;surfaceEntities&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;oppositeDirection&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;endBoundEntityFace&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;endBoundEntityBody&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;hasDraft&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;3.0*deg&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;draftAngle&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;draftPullDirection&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;hasSecondDirection&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;SecondDirectionBoundingType&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;BLIND&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionBound&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;value&amp;quot;: true,
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionOppositeDirection&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionBoundEntityFace&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionBoundEntityBody&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1.0*in&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionDepth&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;hasSecondDirectionDraft&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;3.0*deg&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionDraftAngle&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;secondDirectionDraftPullDirection&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 144,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterBoolean&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;defaultScope&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 148,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQueryList&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;parameterId&amp;quot;: &amp;quot;booleanScope&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre>
&lt;p>We see here that there are a lot of parameters that have no values set in them. This is the way features are created
by the Onshape web client, buty the unneeded ones could be left out. All of the parameters after &amp;ldquo;depth&amp;rdquo; could be
omitted without changing the result. However, leaving out a required parameter will normally result in the result
reporting a featureStatus of &amp;ldquo;ERROR&amp;rdquo;.&lt;/p>
&lt;h3 id="example-4">Example 4&lt;/h3>
&lt;p>This example shows an example of configuring a Part Studio with a single Enum (List) input, and a cube feature
is created that has its size vary based on the configuration of the Part studio.&lt;/p>
&lt;ol>
&lt;li>Create a configuration for the part studio. This example assumes that you are starting with an unconfigured Part
Studio. The Enum input is named &amp;ldquo;Size&amp;rdquo;, which 2 options available, &amp;ldquo;Small&amp;rdquo; and &amp;ldquo;Large&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/configuration&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;configurationParameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 105,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMConfigurationParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;Size_conf&amp;quot;,
&amp;quot;options&amp;quot;: [
{
&amp;quot;type&amp;quot;: 592,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMEnumOption&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;option&amp;quot;: &amp;quot;Small&amp;quot;,
&amp;quot;optionName&amp;quot;: &amp;quot;Small&amp;quot;
}
},
{
&amp;quot;type&amp;quot;: 592,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMEnumOption&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;option&amp;quot;: &amp;quot;Large&amp;quot;,
&amp;quot;optionName&amp;quot;: &amp;quot;Large&amp;quot;
}
}
],
&amp;quot;namespace&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;defaultValue&amp;quot;: &amp;quot;Small&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;Size&amp;quot;,
&amp;quot;parameterName&amp;quot;: &amp;quot;Size&amp;quot;,
&amp;quot;hasUserCode&amp;quot;: false,
&amp;quot;nodeId&amp;quot;: &amp;quot;MgfIjLtd/DvuaT/P/&amp;quot;
}
}
],
&amp;quot;currentConfiguration&amp;quot;: [
{
&amp;quot;type&amp;quot;: 145,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;enumName&amp;quot;: &amp;quot;Size_conf&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;Large&amp;quot;,
&amp;quot;namespace&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;parameterId&amp;quot;: &amp;quot;Size&amp;quot;
}
}
]
}
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>Create a cube feature in the Part Studio. When the Size configuration input is set to &amp;ldquo;Small&amp;rdquo;, the cube will
have a sideLength value of &amp;ldquo;1 in&amp;rdquo; and when the Size input is set to &amp;ldquo;Large&amp;rdquo; it will have a sideLength value of &amp;ldquo;2 in&amp;rdquo;.&lt;/li>
&lt;/ol>
&lt;p>POST /api/partstudios/DWE/features&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;feature&amp;quot;: {
&amp;quot;type&amp;quot;: 134,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMFeature&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;featureType&amp;quot;: &amp;quot;cube&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Cube 1&amp;quot;,
&amp;quot;parameters&amp;quot;: [
{
&amp;quot;type&amp;quot;: 2222,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterConfigured&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;configurationParameterId&amp;quot;: &amp;quot;Size&amp;quot;,
&amp;quot;values&amp;quot;: [
{
&amp;quot;type&amp;quot;: 1923,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMConfiguredValueByEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;namespace&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;enumName&amp;quot;: &amp;quot;Size_conf&amp;quot;,
&amp;quot;enumValue&amp;quot;: &amp;quot;Default&amp;quot;,
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;1 in&amp;quot;
}
}
}
},
{
&amp;quot;type&amp;quot;: 1923,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMConfiguredValueByEnum&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;namespace&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;enumName&amp;quot;: &amp;quot;Size_conf&amp;quot;,
&amp;quot;enumValue&amp;quot;: &amp;quot;Large&amp;quot;,
&amp;quot;value&amp;quot;: {
&amp;quot;type&amp;quot;: 147,
&amp;quot;typeName&amp;quot;: &amp;quot;BTMParameterQuantity&amp;quot;,
&amp;quot;message&amp;quot;: {
&amp;quot;expression&amp;quot;: &amp;quot;2 in&amp;quot;
}
}
}
}
],
&amp;quot;parameterId&amp;quot;: &amp;quot;sideLength&amp;quot;
}
}
]
}
}
}
&lt;/code>&lt;/pre></description></item><item><title>Docs: OAuth</title><link>https://onshape-public.github.io/docs/oauth/</link><pubDate>Mon, 18 May 2020 20:39:14 -0400</pubDate><guid>https://onshape-public.github.io/docs/oauth/</guid><description>
&lt;h1 id="using-oauth-20-with-onshape">Using OAuth 2.0 with Onshape&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>OAuth 2.0 (&amp;ldquo;OAuth&amp;rdquo;) is an authorization framework allowing a user (also referred to as the resource owner) to approve client application access to the user&amp;rsquo;s resources at an OAuth-enabled server.&lt;/p>
&lt;p>When integrating with Onshape, OAuth tokens authorize third-party applications (such as a desktop application or a web service) for limited access to users&amp;rsquo; Onshape documents. Using OAuth terminology, Onshape acts as both the authorization and resource server, while the desktop or web-based application is the client. Resource owners have the option of granting or denying access to applications.&lt;/p>
&lt;p>RFC 6749 (&lt;a href="http://tools.ietf.org/html/rfc6749" target="_blank">&lt;a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749&lt;/a>&lt;/a>) is the reference for the OAuth framework as a whole. Most of this document describes how to implement the OAuth exchanges described by the reference within the context of Onshape and client applications. RFC 6750 (&lt;a href="http://tools.ietf.org/html/rfc6750" target="_blank">&lt;a href="http://tools.ietf.org/html/rfc6750">http://tools.ietf.org/html/rfc6750&lt;/a>&lt;/a>) describes the exchange of OAuth access tokens between clients and OAuth servers.&lt;/p>
&lt;p>Once obtained an OAuth token will work for third-party APIs under &lt;code>/api&lt;/code>. It&amp;rsquo;s not appropriate to attempt to use an OAuth token to fetch the URLs typically displayed in a web browsers location bar.&lt;/p>
&lt;h2 id="application-registration">Application Registration&lt;/h2>
&lt;p>OAuth relies on an orchestrated set of interactions between the web browser, Onshape&amp;rsquo;s web services and third-party client applications (which may be desktop or web server-based). The orchestration takes the form of a sequence of requests and subsequent browser redirections between pre-configured URL endpoints. In order to take part in the OAuth process an application must first be registered with Onshape.&lt;/p>
&lt;p>Currently partners register applications by contacting &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a> to register OAuth application. The following items are necessary:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Application name - acceptable names must include some identification of the partner. &amp;lsquo;Megacorp STL Previewer and Editor&amp;rsquo; is appropriate, but &amp;lsquo;STL Preview and Editor&amp;rsquo; is not. This value cannot be changed after the application is registered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Application description - a short string displayed to the user when they&amp;rsquo;re asked to grant your application permission to access their data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Primary format - this string uniquely identifies your application and is a marker for the data it might store on Onshape servers. It should take the form of a Java style reverse domain name: &lt;code>com.megacorp.stl-preview&lt;/code>. This value cannot be changed after the application is registered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redirect URIs - Your application must specify at least one (but multiple values are acceptable) URI used in OAuth protocol exchanges. This URL must also use SSL (a URL that begins with &lt;code>https&lt;/code>), with two exceptions applicable for installed desktop applications. These two are exceptions allow redirect URIs of the form &lt;code>http://localhost:&amp;lt;port&amp;gt;&lt;/code>, or the URN string &lt;code>urn:ietf:wg:oauth:2.0:oob&lt;/code>. The &amp;rsquo;localhost&amp;rsquo; and URN string are meant for installed desktop applications since they do not require a publicly reachable server to be part of the OAuth process.
Possible reasons for specifying more than one redirect URI is if you deploy &amp;ldquo;test&amp;rdquo; and &amp;ldquo;production&amp;rdquo; versions of your application, and want to use a specific version of your application for different sets of users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Application Scope (Permissions) - the application should also indicate the type of access it requires to the user&amp;rsquo;s data. The current list of scopes are:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Read - Application has read access to your documents&lt;/li>
&lt;li>Comment - Application has read and comment access to your documents&lt;/li>
&lt;li>Write - Application has modify and comment access to your documents&lt;/li>
&lt;li>Reshare - Application has modify and share access to your documents&lt;/li>
&lt;li>Full - Application has full access to your documents&lt;/li>
&lt;/ul>
&lt;p>The list of scopes may be increased or adjusted in the future, in particular access to personal information such as a users email address will be placed under a new scope that will need to be explicitly requested.&lt;/p>
&lt;ol start="6">
&lt;li>OAuth URL - this URL is the &amp;lsquo;authentication page&amp;rsquo; for your application. This is the first URL called from an Onshape application&amp;rsquo;s page. The page hosted at this URL should handle OAuth authentication (see &amp;ldquo;Obtaining a code&amp;rdquo;, below). Once your application&amp;rsquo;s server is authenticated on behalf of the user, the user should be redirected to your application&amp;rsquo;s content. If Onshape passes the &lt;code>redirectOnshapeUri&lt;/code> attribute in the first redirect (as a query parameter) in the OAuth flow, the app should redirect to the URI passed in this attribute after a successful grant.
Legacy support: As we migrate to extension based apps, the old Iframe URL is moved to a tab based extension. Change as needed to provide a better user experience.&lt;/li>
&lt;/ol>
&lt;p>After the application has been registered Onshape will send you corresponding OAuth Client ID and OAuth Client Secret strings. While the Client ID is considered public - it is how your specific application is uniquely identified in OAuth protocol exchanges - the Client Secret &lt;strong>must&lt;/strong> be stored securely. For example, it should &lt;strong>not&lt;/strong> be checked in to source code control systems. Protect the Client Secret as you would any password data.&lt;/p>
&lt;h2 id="obtaining-an-oauth-access-token">Obtaining an OAuth Access Token&lt;/h2>
&lt;p>An OAuth access token is the credential a client application uses to access user resources at Onshape. Obtaining an OAuth access token is a two-part process: first obtaining a one-time use authorization code, and then exchanging the authorization code for them access token. The access token is used for all subsequent Onshape requests, though it too has a limited lifetime (which may be refreshed, as described below).&lt;/p>
&lt;p>In the example URLs used below to describe the OAuth exchanges, values enclosed in angle brackets (&amp;rsquo;&amp;lt;&amp;gt;&amp;rsquo;) are descriptive names used to indicate that application-specific values should be substituted in actual exchanges. All other URLs and URL fragments are literal strings.&lt;/p>
&lt;h3 id="obtaining-a-code">Obtaining a code&lt;/h3>
&lt;p>Your application must first must direct the user to &lt;code>https://oauth.onshape.com/oauth/authorize?response_type=code&amp;amp;client_id=&amp;lt;your client id&amp;gt;&lt;/code>. You may optionally add the &lt;code>redirect_uri&lt;/code>, &lt;code>scope&lt;/code>, &lt;code>state&lt;/code> and &lt;code>company_id&lt;/code> query parameters.&lt;/p>
&lt;p>If your application was registered with more than one redirect URI, then the specific URI to use is indicated by the &lt;code>redirect_uri&lt;/code> query string. You can only use a &lt;code>redirect_uri&lt;/code> value that has been previously registered for this application. URIs must be a exactly match registered values, including the port number (if not using the default HTTPS port). Typically this action is performed by using a HTTP 302 response code with a &lt;code>Location&lt;/code> HTTP response header when the user arrives at the starting page of your application, for example in response to a GET of the Base HREF specified in the application registration. The Location HTTP response header should contain the URL with the correct query parameters as outlined above.&lt;/p>
&lt;p>If the &lt;code>scope&lt;/code> parameter is omitted the token retrieved at the end of this process will be valid for all scopes your application has registered. You can restrict the token to a subset of the registered scopes by using the &lt;code>scope&lt;/code> parameter. Refer to section of RFC 6749 for the exact syntax to specify scopes within a query string. Again, this is optional; by default the OAuth exchange will use the scopes registered for your application.&lt;/p>
&lt;p>The &lt;code>state&lt;/code> parameter is a string value supplied by the partner server and returned back to the partner server later when the browser is redirected to the supplied redirect URI. It can be useful to encode such information as the document and workspace ID from the URL that initiates the OAuth process into the state parameter.&lt;/p>
&lt;p>The &lt;code>company_id&lt;/code> parameter identifies the specific Onshape company of the user requesting the token. OAuth tokens are unique to the combination of user and company. If the user is a member of more than one company and the &lt;code>company_id&lt;/code> parameter is not supplied the user will automatically be prompted to select from a list of eligible companies. Integrated applications are supplied with a company identifier alongside other initial startup parameters for the document the app is installed against when they&amp;rsquo;re first loaded.&lt;/p>
&lt;p>&lt;em>Note&lt;/em> this should be a GET operation and should supply all the values as URL encoded query parameters. In particular the OAuth client id typically has at least one trailing &lt;code>=&lt;/code> which must be URL encoded (replaced with &lt;code>%3D&lt;/code> in the query parameter) in order to be handled correctly.&lt;/p>
&lt;p>When the browser fetches the redirected &lt;code>https://oauth.onshape.com/oauth/authorize&lt;/code> URL the user may be prompted to login (if the used is not currently logged in to Onshape) and is presented with a page describing your application and the scopes that it is requesting. The user can choose to Grant or Deny the request - after this choice is made the browser is redirected to the location specified by the &lt;code>redirect_uri&lt;/code> if present in the request, or the default location entered during application registration.&lt;/p>
&lt;p>The redirection will cause the browser to GET &lt;code>https://&amp;lt;redirect_uri&amp;gt;?code=&amp;lt;code&amp;gt;&amp;amp;state=&amp;lt;state&amp;gt;&lt;/code> (if no state value was supplied initially it will be omitted in this GET). If an error occurs the browser is redirected to &lt;code>https://&amp;lt;redirect_uri&amp;gt;?error=&amp;lt;error_code&amp;gt;&amp;amp;state=&amp;lt;state&amp;gt;&lt;/code> A list of possible error codes is given at section 4.1.2.1 of RFC 6749. If the user denies your application access then the &lt;code>error_code&lt;/code> will be &lt;code>access_denied&lt;/code> though other values may also be encountered.&lt;/p>
&lt;p>At this point your web server application should extract the &lt;code>code&lt;/code> query string parameter value and use it in the subsequent phase to obtain an access token. This authorization code is a one-time use token, and is valid for only a short duration. If the code is not exchanged for an access token within 60 seconds after it is issued, it expires.&lt;/p>
&lt;h3 id="exchanging-the-code-for-a-token">Exchanging the code for a token&lt;/h3>
&lt;p>Using the authorization code from the above exchange, your application can now obtain the OAuth access token. The application makes a POST HTTP request to &lt;code>https://oauth.onshape.com/oauth/token&lt;/code>, with the following data provided as a URL-encoded form body with Content-Type &lt;code>application/x-www-form-urlencoded&lt;/code>:&lt;/p>
&lt;p>&lt;code>grant_type=authorization_code&amp;amp;code=&amp;lt;code&amp;gt;&amp;amp;client_id=&amp;lt;client id&amp;gt;&amp;amp;client_secret=&amp;lt;client_secret&amp;gt;&lt;/code>&lt;/p>
&lt;p>Additionally if a redirect URI was supplied as an additional parameter in the initial GET of &lt;code>/oauth/authorize&lt;/code> it must also be supplied here.&lt;/p>
&lt;p>&lt;em>Note&lt;/em> Each parameter must be URL encoded - as before the client ID and client secret both have trailing &lt;code>=&lt;/code> which must be replaced with &lt;code>%3D&lt;/code>. Do &lt;em>not&lt;/em> encode the entire body of the POST request - the &lt;code>=&lt;/code> separating parameter name and value must be left intact. This is a POST operation with the body of the POST message containing the data to complete the OAuth request for an access token. It is &lt;em>not&lt;/em> a GET operation with the additional data supplied as query parameters.&lt;/p>
&lt;p>In response to a valid POST request the server returns a JSON encoded structure:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;access_token&amp;#34;:&amp;#34;&amp;lt;access token&amp;gt;&amp;#34;,
&amp;#34;token_type&amp;#34;:&amp;#34;Bearer&amp;#34;,
&amp;#34;expires_in&amp;#34;:3600,
&amp;#34;refresh_token&amp;#34;:&amp;#34;&amp;lt;refresh token&amp;gt;&amp;#34;,
}
&lt;/code>&lt;/pre>&lt;p>This token structure can be stored by your server as data unique to the user who initiated the request or you can make it part of the server side session storage for this users session with your server.&lt;/p>
&lt;h3 id="using-the-access-token">Using the access token&lt;/h3>
&lt;p>The &amp;lsquo;access_token&amp;rsquo; must be supplied on all subsequent Onshape API requests as a header value: &lt;code>Authorization: Bearer &amp;lt;access_token&amp;gt;&lt;/code> The access token uniquely identifies the combination of your application, the Onshape user and the set of permissions granted for the access token.&lt;/p>
&lt;p>The access token has a limited lifetime of 60 minutes, after which it will no longer work and attempts to use it will result in an error response for an Onshape API request. The application must use the refresh token returned by the original authorization code exchange to generate new access tokens&lt;/p>
&lt;h3 id="refreshing-the-access-token">Refreshing the access token&lt;/h3>
&lt;p>When the access token expires it must be refreshed by making another POST request to &lt;code>https://oauth.onshape.com/oauth/token&lt;/code> with the following URL encoded form body (again, with Content-Type &lt;code>application/x-www-form-urlencoded&lt;/code>):&lt;/p>
&lt;p>&lt;code>grant_type=refresh_token&amp;amp;refresh_token=&amp;lt;refresh_token&amp;gt;&amp;amp;client_id=&amp;lt;client_id&amp;gt;&amp;amp;client_secret=&amp;lt;client_secret&amp;gt;&lt;/code>.&lt;/p>
&lt;p>As with the authorization code data, the parameters in the form body must be URL encoded. The response to this POST request will be a JSON encoded structure as before with a new &lt;code>access_token&lt;/code> value that can be used for the next 60 minutes.&lt;/p>
&lt;p>Refresh tokens are valid for the lifetime of the user&amp;rsquo;s grant. If a user who has previously granted access to your application decides to revoke the grant, the refresh token is invalidated. If the user decides to re-grant application access, a new refresh token is generated and returned along with the access token.&lt;/p>
&lt;h2 id="notes-for-developers-of-installed-desktop-applications">Notes for developers of installed desktop applications&lt;/h2>
&lt;p>OAuth is designed for interactions between two servers utilizing a browser. However it can also be used by an installed desktop (or mobile) application. The application must perform a similar role to that of a third party server - it must exchange the code for an access token structure.&lt;/p>
&lt;p>In order to enable this to be as automatic as possible Onshape allows two special forms of redirect URI to be registered: &lt;code>http://localhost:&amp;lt;port&amp;gt;&lt;/code> and &lt;code>urn:ietf:wg:oauth:2.0:oob&lt;/code>&lt;/p>
&lt;p>The first causes the browser to attempt to load a page from the host upon which it is running. The code parameter etc will be supplied exactly the same as outlined above. If the application can listen on the registered port and behave as a simple web server for the redirect URI it can retrieve the code in the same way as a deployed web server would.&lt;/p>
&lt;p>The second will cause the browser to display a simple page containing the code after a request has been granted instead of going to a new URI. The page contains simple instructions to copy and paste the code into an application field. The browser will also update the title of the window to contain the code. An application could also look for browsers with window titles containing the string &lt;code>Success code=&amp;lt;code&amp;gt;&lt;/code> and automatically grab the code from the browser window title. If an error occurs (the grant is denied for example) then the browser window title will contain &lt;code>Error description=&amp;lt;error string&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="notes-for-debugging">Notes for debugging&lt;/h2>
&lt;p>Debugging OAuth can be a little tricky. Here are some things to bear in mind:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Make sure you are correctly URL encoding the values supplied to the oauth/authorize and oauth/token endpoints.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use a &lt;code>GET /oauth/authorize&lt;/code> but a &lt;code>POST /oauth/token&lt;/code> and make sure that the GET uses query parameters but that the POST uses a URL encoded form body.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If you supply a &lt;code>redirect_uri&lt;/code> to &lt;code>/oauth/authorize&lt;/code> you must also supply it as an additional parameter in the POST to /oauth/token&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use a tool such as Burp (&lt;a href="https://portswigger.net/burp" target="_blank">&lt;a href="https://portswigger.net/burp">https://portswigger.net/burp&lt;/a>&lt;/a>) or Charles (&lt;a href="http://charlesproxy.com" target="_blank">&lt;a href="http://charlesproxy.com">http://charlesproxy.com&lt;/a>&lt;/a>) to deliberately &amp;lsquo;man-in-the-middle&amp;rsquo; the connection requests between your server and Onshape, and verify that you are performing the correct REST operations (GET vs. POST) and correctly URL encoding the parameter values.&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: Integration Methodology Guide</title><link>https://onshape-public.github.io/docs/integrationguide/</link><pubDate>Tue, 07 Jun 2022 08:24:05 -0400</pubDate><guid>https://onshape-public.github.io/docs/integrationguide/</guid><description>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage3.png"
style="width:4.29167in;height:0.95498in" />&lt;/p>
&lt;h1 id="table-of-contents">Table of Contents&lt;/h1>
&lt;p>&lt;a href="#introduction">Introduction 4&lt;/a>&lt;/p>
&lt;p>&lt;a href="#about-this-book">About this book 6&lt;/a>&lt;/p>
&lt;p>&lt;a href="#who-is-this-book-for">Who is this book for?
6&lt;/a>&lt;/p>
&lt;p>&lt;a href="#how-this-book-is-organized">How this book is organized
6&lt;/a>&lt;/p>
&lt;p>&lt;a href="#conventions-used-throughout-this-book">Conventions Used throughout this book
7&lt;/a>&lt;/p>
&lt;p>&lt;a href="#onshape-a-new-architecture">Onshape â€“ a new architecture
8&lt;/a>&lt;/p>
&lt;p>&lt;a href="#traditional-three-tier-architecture">Traditional Three-Tier Architecture
8&lt;/a>&lt;/p>
&lt;p>&lt;a href="#single-vs-multiple-tenant-architectures">Single vs Multiple Tenant Architectures
9&lt;/a>&lt;/p>
&lt;p>&lt;a href="#what-is-a-rest-api">What is a REST API? 11&lt;/a>&lt;/p>
&lt;p>&lt;a href="#what-is-json">What is JSON? 13&lt;/a>&lt;/p>
&lt;p>&lt;a href="#the-onshape-difference">The Onshape difference
15&lt;/a>&lt;/p>
&lt;p>&lt;a href="#the-key-onshape-differentiators">The Key Onshape differentiators
15&lt;/a>&lt;/p>
&lt;p>&lt;a href="#data-driven-no-files">Data Driven â€“ No files
15&lt;/a>&lt;/p>
&lt;p>&lt;a href="#pdm-is-built-in">PDM is built-in 17&lt;/a>&lt;/p>
&lt;p>&lt;a href="#multi-part-part-studios">Multi-Part Part Studios
19&lt;/a>&lt;/p>
&lt;p>&lt;a href="#versions-and-releases">Versions and Releases
21&lt;/a>&lt;/p>
&lt;p>&lt;a href="#workflows">Workflows 22&lt;/a>&lt;/p>
&lt;p>&lt;a href="#the-document-structure">The Document Structure
24&lt;/a>&lt;/p>
&lt;p>&lt;a href="#the-onshape-url">The Onshape URL 26&lt;/a>&lt;/p>
&lt;p>&lt;a href="#integration-considerations">Integration Considerations
27&lt;/a>&lt;/p>
&lt;p>&lt;a href="#integrating-3rd-party-applications-with-onshape">Integrating 3&lt;sup>rd&lt;/sup> Party Applications with Onshape
29&lt;/a>&lt;/p>
&lt;p>&lt;a href="#authentication-overview">Authentication Overview
29&lt;/a>&lt;/p>
&lt;p>&lt;a href="#what-is-oauth2">What is OAuth2? 29&lt;/a>&lt;/p>
&lt;p>&lt;a href="#how-does-oauth-work">How Does OAuth Work? 30&lt;/a>&lt;/p>
&lt;p>&lt;a href="#enabling-a-3rd-party-application-in-onshape">Enabling a 3&lt;sup>rd&lt;/sup> Party Application in Onshape
33&lt;/a>&lt;/p>
&lt;p>&lt;a href="#implementing-oauth2-in-your-code">Implementing OAuth2 in your Code
37&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-1-get-the-user-authorization-code">Step 1: get the user authorization code
37&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step2-exchange-the-code-for-an-access-token">Step2: Exchange the code for an access token
43&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-3-using-the-access-token">Step 3: Using the access token
45&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-4-refreshing-the-token">Step 4: Refreshing the token
48&lt;/a>&lt;/p>
&lt;p>&lt;a href="#user-grant-of-authorization">User Grant of Authorization
51&lt;/a>&lt;/p>
&lt;p>&lt;a href="#oauth2-summary">OAuth2 Summary 53&lt;/a>&lt;/p>
&lt;p>&lt;a href="#the-methodology-of-specific-business-cases">The methodology of specific Business Cases
54&lt;/a>&lt;/p>
&lt;p>&lt;a href="#methodology-introduction">Methodology Introduction
54&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-1-sync-objects-and-metadata">Business Case 1: Sync Objects and Metadata
55&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-1-overview">Business case 1 Overview
55&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-1-define-properties-in-onshape">Step 1 Define Properties in Onshape:
56&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-2-create-corresponding-object">Step 2 Create Corresponding Object:
57&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-3-get-onshape-metadata">Step 3 Get Onshape Metadata:
58&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-4-modify-properties-in-onshape">Step 4 Modify Properties in Onshape:
59&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-5-request-part-number">Step 5: Request Part Number
60&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-6-push-updates-from-third-party-application">Step 6: Push Updates from Third-Party application
61&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-1-implementation">Business case 1 implementation
62&lt;/a>&lt;/p>
&lt;p>&lt;a href="#rest-api-tips-and-tricks">REST API Tips and Tricks
62&lt;/a>&lt;/p>
&lt;p>&lt;a href="#glassworks">Glassworks 62&lt;/a>&lt;/p>
&lt;p>&lt;a href="#debug-using-browser-developer-tools">Debug Using Browser Developer Tools
4&lt;/a>&lt;/p>
&lt;p>&lt;a href="#define-an-application-extension">Define an Application Extension
68&lt;/a>&lt;/p>
&lt;p>&lt;a href="#grant-onshape-access-to-3rd-party-data">Grant Onshape Access to 3&lt;sup>rd&lt;/sup> Party Data
71&lt;/a>&lt;/p>
&lt;p>&lt;a href="#defining-webhooks">Defining Webhooks 73&lt;/a>&lt;/p>
&lt;p>&lt;a href="#receiving-webhook-notifications">Receiving Webhook notifications
77&lt;/a>&lt;/p>
&lt;p>&lt;a href="#getting-onshape-properties">Getting Onshape Properties
78&lt;/a>&lt;/p>
&lt;p>&lt;a href="#updating-onshape">Updating Onshape 80&lt;/a>&lt;/p>
&lt;p>&lt;a href="#implementing-custom-part-numbers">Implementing Custom Part Numbers
81&lt;/a>&lt;/p>
&lt;p>&lt;a href="#implementing-part-number-code">Implementing Part Number Code
83&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-2-sync-revisions-and-releases">Business Case 2: Sync Revisions and releases
87&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-2-overview">Business case 2 Overview
87&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-1-initiate-release">Step 1: Initiate Release
89&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-2-initiating-release-process-in-3rd-party-app">Step 2: Initiating Release Process in 3&lt;sup>rd&lt;/sup> Party app
91&lt;/a>&lt;/p>
&lt;p>&lt;a href="#step-3-complete-release-process">Step 3: Complete Release Process
92&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-2-implementation">Business case 2 implementation
94&lt;/a>&lt;/p>
&lt;p>&lt;a href="#setup-webhook">Setup Webhook 94&lt;/a>&lt;/p>
&lt;p>&lt;a href="#receiving-web-hook-notifications">Receiving Web Hook Notifications
95&lt;/a>&lt;/p>
&lt;p>&lt;a href="#getting-release-package-data">Getting Release Package Data
97&lt;/a>&lt;/p>
&lt;p>&lt;a href="#saving-release-package-data">Saving Release Package Data
97&lt;/a>&lt;/p>
&lt;p>&lt;a href="#completing-the-release">Completing the Release
99&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-3-generate-derivative-files">Business Case 3: Generate Derivative Files
103&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-3-overview">Business case 3 Overview
104&lt;/a>&lt;/p>
&lt;p>&lt;a href="#business-case-3-implementation">Business case 3 implementation
106&lt;/a>&lt;/p>
&lt;p>&lt;a href="#initiating-the-translation">Initiating the Translation
107&lt;/a>&lt;/p>
&lt;p>&lt;a href="#ping-onshape-for-translation">Ping Onshape for Translation
108&lt;/a>&lt;/p>
&lt;p>&lt;a href="#retrieve-translated-file">Retrieve Translated File
110&lt;/a>&lt;/p>
&lt;p>&lt;a href="#translation-webhooks">Translation Webhooks
112&lt;/a>&lt;/p>
&lt;p>&lt;a href="#integrating-into-the-onshape-interface">Integrating into the Onshape Interface
114&lt;/a>&lt;/p>
&lt;p>&lt;a href="#setting-up-the-integration">Setting up the Integration
115&lt;/a>&lt;/p>
&lt;p>&lt;a href="#calling-a-page-in-the-extension">Calling a Page in the Extension
118&lt;/a>&lt;/p>
&lt;p>&lt;a href="#using-our-application-extension">Using our application extension
119&lt;/a>&lt;/p>
&lt;p>&lt;a href="#methodology-summary">Methodology Summary 121&lt;/a>&lt;/p>
&lt;p>&lt;a href="#table-to-figures">Table to Figures 122&lt;/a>&lt;/p>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>As long as there have been applications managing organizational data
into a database, there has been a need to share that data between
different departments and therefore, usually, different systems. In a
typical design/manufacturing organization there could be at least four
or five mission critical databases that manage the data for different
departments and for different stages in the productâ€™s lifecycle.&lt;/p>
&lt;p>Initially these systems provide the capabilities required by their
consumers, i.e., the departments that use these systems. For instance,
finance will use a finance system such as Quick books. Manufacturing
might use a manufacturing planning and execution system (MES).
Engineering, a Product Data management System (PDM) and so on for each
group in the organization.&lt;/p>
&lt;p>What this leads to is disparate silos of data and therefore knowledge.
The departments in an organization do not work in a vacuum â€“ each is
dependent on information that is generated by other groups. For
instance, Manufacturing canâ€™t produce correct assembly instructions
without input from engineering in the way of the designs and the bill of
materials. Finance canâ€™t cost the product without understanding its
contents or understanding which parts are manufactured in-house or
purchased.&lt;/p>
&lt;p>Therefore, the need to integrate these systems becomes critical for the
organization to function optimally. Initially, connecting one system to
another can be a straightforward process. Obviously is usually involves
some services to get the systems to talk to each other, however it
shouldnâ€™t be too painful as long as the requirements are clearly
defined.&lt;/p>
&lt;p>Anyone who has implemented integrations between PLM systems (Product
Lifecycle Management) or ERP (Enterprise Resource Planning) will tell
you of the nightmare scenarios that they encountered. Often this is the
result of poorly scoped and defined requirements, conflicting
requirements coming from multiple departments and the many integration
points required between systems. The result is that the organization is
not getting what it wanted or needs, the customer is paying for services
that do not provide the promised solution and usually the project is
long overdue. All this equals an unhappy customer and often the software
vendorâ€™s solutions are blamed for the disaster.&lt;/p>
&lt;p>Over the years many technologies have appeared and some of them, just as
quickly disappeared to help with enabling integration without the need
to write thousands of lines of custom code that needs to be re-written
every time thereâ€™s a software upgrade. Lately there have been several
new technologies that provide â€œcodelessâ€ integration between SaaS
products â€“ an example of this is Zapier (zapier.com). These solutions
are particularly good for generic use cases for data exchange between
systems but can be limited when it comes to custom modifications to the
data being sent that might be required by a specific customer. In
addition, they have the overhead of requiring a subscription to their
service. An additional concern that I have heard is regarding sending
corporate IP through another third party and data security.&lt;/p>
&lt;p>Therefore, we can understand that in most organizations integration
between systems is a necessary evil that must be tackled â€“ either with
an Out-Of-The-Box solution or through some custom coding.&lt;/p>
&lt;p>Early on, Onshape understood that as an engineering system, it cannot
exist in a vacuum â€“ it must be able to communicate with other systems.
For this reason, the REST API was developed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" /> An API, orÂ &lt;em>application
programming interface&lt;/em>, is a set of rules that define how applications
or devices can connect to and communicate with each other. A REST API is
an API that conforms to the design principles of the REST,
orÂ &lt;em>representational state transferÂ &lt;em>architectural style. For this
reason, REST APIs are sometimes referred to RESTful APIs&lt;/em>.&lt;/em>&lt;/p>
&lt;h1 id="about-this-book">About this book&lt;/h1>
&lt;h2 id="who-is-this-book-for">Who is this book for?&lt;/h2>
&lt;p>Whether you are a developer wanting to integrate Onshape to other
systems or you are just trying to educate yourself on how a modern
application such as Onshape integrates with other systems, this guide is
designed for you.&lt;/p>
&lt;p>While some programing experience will help a lot, it is not required.
For the first two sections of this guide, we focus on the technology and
how Onshape differs from other similar systems.&lt;/p>
&lt;p>The third section of the guide focuses on specific business cases for
integration and describes in detail the methodologies around each
business case. These business cases are generic in nature and very
common for any integration. Most of the code samples are very
self-explanatory and are commented to provide additional explanations
where required.&lt;/p>
&lt;h2 id="how-this-book-is-organized">How this book is organized&lt;/h2>
&lt;p>This guide is divided into three main sections:&lt;/p>
&lt;p>We start by introducing Onshape and how it differs from traditional CAD
and PDM/PLM systems. Onshape is a solution that was built from scratch
for the cloud â€“ a true multi-tenant SaaS solution. This means that the
architecture, the technologies used and many of the practices in Onshape
differ from traditional yet older systems. It is very important to
understand these differences when implementing an integration. In this
first section we highlight many of the important differences between
Onshape and traditional systems and how an integration might look using
these new concepts. We also discuss integration best practices for
Onshape.&lt;/p>
&lt;p>In the second section of the guide, we look at how to connect an
application to Onshape and authenticate that application against Onshape
using OAuth2. We provide an in-depth look at what OAuth2 and how to use
it to connect a third-party application to Onshape. We also discuss how
an application can be embedded inside the Onshape interface and how a
third-party application can make functionality available inside the
Onshape menu interface. This section of the book is critical to
understanding how to setup a third-party application, and enable it to
access Onshapeâ€™s resources securely.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.40278in;height:0.40278in" />Finally, in the third section
of the guide we examine in detail, three common business cases for
integration between Onshape and third-party systems. This section delves
into some code examples and best practices for using the APIs. We also
take a look at how to setup Application Extensions in Onshape and enable
Onshape to access a third-party applicationâ€™s resources. This section
also contains a detailed explanation and samples for using Onshapeâ€™s
webhooks.&lt;/p>
&lt;p>The code samples in this book use Node.js. Other programing languages
such as Python, C#, Java or PHP can be used based upon your use case and
own personal preference.&lt;/p>
&lt;h2 id="conventions-used-throughout-this-book">Conventions Used throughout this book&lt;/h2>
&lt;p>Throughout the book you will see various icons that either summarize or
highlight important additional information.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" /> &lt;strong>Information&lt;/strong>: Important
information that can help clarify a specific topic&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" /> &lt;strong>Note&lt;/strong>: Additional notes
or a summary related to a specific topic&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage8.png"
style="width:0.44444in;height:0.44444in" /> &lt;strong>Tips and Tricks&lt;/strong>:
Information that will help you get around problems&lt;/p>
&lt;h1 id="onshape--a-new-architecture">Onshape â€“ a new architecture&lt;/h1>
&lt;p>Onshape was built from the ground up as a true SaaS based system. The
importance of this is that Onshape had no investment in legacy code and
was able to develop an application that truly runs as a multi-tenant
SaaS solution from the first line of code. Many companies claim to run
cloud-based solutions, however, since they have such a large investment
in their legacy code that they canâ€™t just discard and start again from
scratch, they tend to try and port that code to the web.&lt;/p>
&lt;p>More often than not, porting existing code to the web and calling it a
SaaS solution is no more than a marketing ploy â€“ it isnâ€™t a true SaaS
solution if it wasnâ€™t written as one. These are generally known as cloud
hosted solutions. This means that a typical three tier data management
solution that could have previously been installed on a set or servers,
has now been modified to be hosted on the web.&lt;/p>
&lt;h3 id="traditional-three-tier-architecture">Traditional Three-Tier Architecture&lt;/h3>
&lt;p>Traditional PLM systems typically use a three-tier architecture â€“ mainly
consisting of an application server, a database server, and a client
which can be a web client or a thick client installed on the client
hardware.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage10.png"
style="width:4.91807in;height:3.27083in"
alt="The 3-tier architecture | Download Scientific Diagram" />&lt;/p>
&lt;p>&lt;span id="_Toc102977872" class="anchor">&lt;/span>Figure 1 - Typical
three-tier architecture&lt;/p>
&lt;p>To connect to this and integrate with it, generally APIs were exposed on
the application/Web server. Here we can already see that if this
architecture is ported to the web, it would not be possible to make
customizations through API since you would be modifying the behavior of
the program for everyone connected to this application server.&lt;/p>
&lt;h3 id="single-vs-multiple-tenant-architectures">Single vs Multiple Tenant Architectures&lt;/h3>
&lt;p>The architecture shown on the previous page is very typical of most
Product Lifecycle management solutions on the market today. It is fine
when you want the solution installed on company servers and only
accessible to people within the company.&lt;/p>
&lt;p>When such a solution is ported to the web, more often than not, software
vendors will be required to create a Single tenant application where an
application server and a database server are provisioned for each new
customer.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage11.png"
style="width:5.4311in;height:4.35417in"
alt="Enterprise SaaS Architecture - The Why | Frontegg" />&lt;/p>
&lt;p>&lt;span id="_Toc102977873" class="anchor">&lt;/span>Figure 2 - Single Tenant
Architecture&lt;/p>
&lt;p>In the case above, the vendor will be required to throw more expensive
hardware at the solution in order to host more customers â€“ this is not a
sustainable model long term.&lt;/p>
&lt;p>Modern 21&lt;sup>st&lt;/sup> century software solutions use multi-tenant
solutions that can be hosted on services such as Amazon cloud, Azure and
more. There are many benefits to this architecture however the immediate
clear benefits can be seen as servers can be provisioned and
decommissioned on the fly to provide ultimate performance whenever
required. Since servers cost money, decommissioning servers when they
are not required is a key benefit to a true SaaS solution.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage12.png" style="width:6.5in;height:4.65417in"
alt="Saas Solutions - Multi-tenant vs multi-instance architectures" />&lt;/p>
&lt;p>&lt;span id="_Toc102977874" class="anchor">&lt;/span>Figure 3 - Multi-Tenant
Architecture&lt;/p>
&lt;p>Since each application is separate in this architecture, we can
therefore enable customizations that canâ€™t be implemented in a single
tenant architecture where multiple customers are connected to one single
application server. An example of this is providing access to the REST
APIs that are required for integration. In the single-tenant
architecture, if you provide API access to the application server, one
customer will be modifying that application for all customers who are
registered on that tenant.&lt;/p>
&lt;h3 id="what-is-a-rest-api">What is a REST API?&lt;/h3>
&lt;p>As mentioned previously, Onshape uses REST APIs to communicate with
third party systems. In short you call a REST API as you would a web
page. It has a specific web address and often some additional parameters
that are required either in the URL itself or form data that can be
attached to the web call. The web call instead of returning a web page
will return information. The response from the API call is formatted in
JSON (JavaScript Object Notation).&lt;/p>
&lt;p>REST APIs use HTTP standards such as GET, POST, PUT and DELETE&lt;/p>
&lt;p>&lt;strong>GET&lt;/strong>: Retrieve information from the server. Any arguments are
included in the URL sent to the server&lt;/p>
&lt;p>&lt;strong>POST&lt;/strong>: Update the server with new information. Data required is
included in the body of the request â€“ the same as how a web form submits
data to a server.&lt;/p>
&lt;p>&lt;strong>PUT&lt;/strong>: Update an existing record&lt;/p>
&lt;p>&lt;strong>DELETE&lt;/strong>: Delete information from the server&lt;/p>
&lt;p>In addition, Header information will be sent with the request â€“ this
will include authentication credentials that verify if your application
is in fact authorized to run this API.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage13.jpeg"
style="width:5.48611in;height:4.1181in"
alt="PHP RESTful Web Service API â€“ Part 1 â€“ Introduction with Step-by-step Example - Phppot" />&lt;/p>
&lt;p>&lt;span id="_Toc102977875" class="anchor">&lt;/span>Figure 4 - REST API
Architecture&lt;/p>
&lt;p>An example of an Onshape REST API call would be the following. This GET
API is used to retrieve information about a specific document in
Onshape:&lt;/p>
&lt;p>&lt;a href="https://cad.onshpae.com/api/documents/72de34014b590a923c87">https://cad.onshpae.com/api/documents/72de34014b590a923c87&lt;/a>&lt;/p>
&lt;p>The response from this API is too long to show here however it will be
in JSON format and contain information regarding the documentâ€™s
workspace, the owner of the document, permissions and a lot of other
relevant information.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.375in;height:0.47222in" />For tips and tricks, regarding
Onshapeâ€™s APIs reference REST API Tips and Tricks section.&lt;/p>
&lt;h3 id="what-is-json">What is JSON?&lt;/h3>
&lt;p>JSON (&lt;strong>J&lt;/strong>ava&lt;strong>S&lt;/strong>cript &lt;strong>O&lt;/strong>bject &lt;strong>N&lt;/strong>otation)&lt;/p>
&lt;p>The following explanation of the JSON format is taken directly from
json.org:&lt;/p>
&lt;p>&lt;strong>JSON&lt;/strong>Â (JavaScript Object Notation) is a lightweight data-interchange
format. It is easy for humans to read and write. It is easy for machines
to parse and generate. It is based on a subset of the JavaScript
Programming Language Standard ECMA-262 3rd Edition - December 1999. JSON
is a text format that is completely language independent but uses
conventions that are familiar to programmers of the C-family of
languages, including C, C++, C#, Java, JavaScript, Perl, Python, and
many others. These properties make JSON an ideal data-interchange
language.&lt;/p>
&lt;p>JSON is built on two structures:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A collection of name/value pairs. In various languages, this is
realized as anÂ &lt;em>object&lt;/em>, record, struct, dictionary, hash table,
keyed list, or associative array.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An ordered list of values. In most languages, this is realized as
anÂ &lt;em>array&lt;/em>, vector, list, or sequence.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>These are universal data structures. Virtually all modern programming
languages support them in one form or another. It makes sense that a
data format that is interchangeable with programming languages also be
based on these structures.&lt;/p>
&lt;p>The following is the basic format of JSON:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00;background-color:#faa">Object:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œattributeâ€:&lt;/span> &lt;span style="color:#f00;background-color:#faa">â€œvalueâ€,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œattributeâ€:&lt;/span> &lt;span style="color:#f00;background-color:#faa">â€œvalueâ€&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A simple example of a JSON object could be the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00;background-color:#faa">â€œPersonâ€:&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œfirstnameâ€:&lt;/span> &lt;span style="color:#f00;background-color:#faa">â€œJoeâ€,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œlastname:&lt;/span> &lt;span style="color:#f00;background-color:#faa">â€œSmithâ€,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œAgeâ€:&lt;/span> &lt;span style="color:#f00;background-color:#faa">31&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is an object that describes a person named Joe Smith who is 31
years old.&lt;/p>
&lt;p>To this object we can add an array of children as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;Person&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œfirstnameâ€:&lt;/span> &lt;span style="color:#f00;background-color:#faa">â€œJoeâ€,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">â€œlastname&lt;/span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;: â€œSmithâ€,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold"> â€œAgeâ€: 31,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold"> &amp;#34;&lt;/span>&lt;span style="color:#f00;background-color:#faa">children&lt;/span>&lt;span style="color:#a50">&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a50"> {&amp;#34;&lt;/span>&lt;span style="color:#f00;background-color:#faa">name&lt;/span>&lt;span style="color:#a50">&amp;#34;: &amp;#34;&lt;/span>&lt;span style="color:#f00;background-color:#faa">Billâ€&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#099">5&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">{&lt;/span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;Sarah&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#099">2&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00;background-color:#faa">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see here, we added an array of 2 children to our â€œPersonâ€
object by using the square brackets [] â€“ which denotes an array.&lt;/p>
&lt;p>Thereâ€™s not much more to the JSON format that we need to know other than
this basic structure of objects with key pair values.&lt;/p>
&lt;p>Programing languages such as JavaScript will natively understand this
format and translate it to a list of objects that can be referenced in
your code in the following format â€“ Person.children[0].name in this
case the result will equal â€œBillâ€. Alternatively, you can iterate
through the results retrieving the relevant information from each
object.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage8.png"
style="width:0.44444in;height:0.44444in" /> The JSON returned from
Onshape can often contain a lot of information and be very long. In
order to understand this data a lot easier it can be useful to use a
JSON parser tool that enables you to browse the data in a tree view that
can be expanded.&lt;/p>
&lt;p>One of the oneâ€™s I use is &lt;a href="http://jsonviewer.stack.hu/">http://jsonviewer.stack.hu/&lt;/a>. This
application allows you to paste your JSON data directly into a text
editor and then view it in a viewer tab where you can easily view the
structure and find specific attributes and values.&lt;/p>
&lt;h2 id="the-onshape-difference">The Onshape difference&lt;/h2>
&lt;p>If your familiar with how other CAD systems function, or youâ€™ve worked
on integrations to other CAD systems, then please read this section.
Onshape does not work like other legacy CAD systems. As mentioned
previously, Onshape was built from scratch for the cloud and as a modern
CAD system. It stands to reason that many of the failings of legacy CAD
systems were not included in Onshape. Onshape does work differently to
any other CAD and as a result, you canâ€™t apply the same integration
methodology to a legacy CAD system to Onshape.&lt;/p>
&lt;h3 id="the-key-onshape-differentiators">The Key Onshape differentiators&lt;/h3>
&lt;p>In this section Iâ€™m going to focus on several of the key differences in
Onshape as it pertains to integrations. There are many more differences
and benefits to Onshape, however these are well documented in the Help
and training materials delivered through Onshape.&lt;/p>
&lt;p>The information in this section is important as far as integrations are
concerned given that Onshape does not behave as traditional file-based
systems do. With this in mind, when writing an integration, it is
critical to understand the nuances in Onshapeâ€™s design practices and how
data is organized in Onshape.&lt;/p>
&lt;h4 id="data-driven--no-files">Data Driven â€“ No files&lt;/h4>
&lt;p>Most traditional PDM/PLM systems that are integrated with CAD systems
enable this integration on a per-file basis. This means that you have an
object in the PDM/PLM system that corresponds directly to a file in the
CAD system. In this way the PDM/PLM system can manage access to the
files, build assemblies from the files, view the CAD data and much more.
Onshape does not work this way â€“ it is a data driven system.&lt;/p>
&lt;p>Being data-driven means that Onshape has no files â€“ just data. This will
already tell you that an integration into Onshape is going to look
different from any integration to a CAD system that you might have done
previously.&lt;/p>
&lt;p>In traditional CAD a single file represents a snapshot of what the
design looked like at a specific moment in time â€“ for all intense and
purposes, unless itâ€™s changed it will remain in that state forever. PDM
systems manage these files and once the designer decides to make a
revision or a release, the file is locked and a new file can be created
to represent any further updated versions or releases of the design.
PDM/PLM systems are very good at managing this data in an up-to-date
structure, however it does have the drawbacks of generating many file
copies of a specific design and once a file is taken out from the system
â€“ for instance; to share with a supplier, it is no longer managed and
tracked.&lt;/p>
&lt;p>Onshape uses data in place of files. The data is always up-to-date and
can be collaborated on in real-time without the need to send file copies
around. This means that Onshape views versions and releases differently
than those traditional systems do, therefore we should be re-thinking
how the integration will work with data in place of multiple files.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Files can be generated from
the Onshape data. An example of this could be generating a PDF of a
drawing upon release, or of a STEP file that can be used by other
systems downstream from engineering. The generation of such files can be
automated and is addressed in this guide.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />A key benefit of a data
driven system is the ability to retrieve real-time very detailed
analytics. Onshape has very comprehensive analytics; for instance, an
authorized person can view who edited a design, when and exactly what
they did to that design, i.e. which commands they used and how long they
spend on the modifying the design.&lt;/p>
&lt;h4 id="pdm-is-built-in">PDM is built-in&lt;/h4>
&lt;p>Up until now, CAD was one software program and PDM/PLM was another
program that had to be integrated with the CAD. In many cases both
programs could be sold by the same software vendor, even though there
are many PLM systems available that are sold by independent vendors who
have no CAD system. Regardless a PDM/PLM system always had to be a
â€œbolt-onâ€ solution to the CAD system.&lt;/p>
&lt;p>No matter how deep the integration between a CAD system and a PLM
system, there is always the need to sync data between the two systems,
this can always be a week point in any solution and prone to errors.&lt;/p>
&lt;p>Being data driven, Onshape already has PDM built in as part of the CAD
system. This is unique in the industry â€“ CAD and PDM as part and parcel
of the same solution with no bolt-on piece of software required. There
are many benefits to this approach beyond the fact that there is no
syncing between various systems in order to achieve the data management
aspects of the CAD system.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage14.png"
style="width:4.49202in;height:4.1652in"
alt="A picture containing graphical user interface Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977876" class="anchor">&lt;/span>Figure 5 - Onshapeâ€™s
revision and part number schema definition interface&lt;/p>
&lt;p>For instance:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Since the data is always up to date, the correct state of any design
is always represented in real-time with no delay for syncing between
systems.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The data is never locked as is the case in file-based systems â€“ it
is always available and always changing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The data management aspects of CAD that were generally associated
with the PDM system are now fully integrated into every aspect of
the CAD system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>True real-time collaboration/co-design on both design and data is
enabled&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>So, what does this mean when it comes to integrating Onshape with
another PLM system? First and foremost, we must understand that there
are many things that a PLM system does that Onshapeâ€™s PDM capabilities
canâ€™t do. Integrating Onshape to a PLM system should augment the
powerful capabilities already available inside Onshape and not
necessarily replace them. Likewise, Onshape does not come to replace PLM
native capabilities. Instead, depending on the business case we should
be using the best-in-class capabilities of each system to augment the
other.&lt;/p>
&lt;p>An example of augmenting capabilities of each system could be the
release process.&lt;/p>
&lt;p>Onshape has a specific way of managing the release of data that is
different from traditional PDM systems. This capability is inherently
suited to a data driven approach and provides a lot of value to the
update of design data in Onshape. At the same time, PLM systems provide
enterprise release processes that may include many people and different
departments that extend beyond the engineering domain. Such PLM
processes can be highly customized and suited to the organizations
established business processes.&lt;/p>
&lt;p>In this scenario it makes no sense to not use the enterprise release
processes in the PLM system, however also not using Onshapeâ€™s release
capabilities could put data between Onshape and the PLM system out of
sync and prevent Onshape from updating data â€“ such as watermarks and
title blocks on drawings, icons related the visualizing the state of
data and more.&lt;/p>
&lt;p>In this case we want to use the best-in-class features of each software
solution without compromising on capability provided by each solution.
If we plan our integration correctly this can be achieved by initiating
the release of the data in Onshape, transferring the release data to the
PLM system where the release process will be triggered and finally
automating the release in Onshape once the process has been completed in
the PLM system.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />This specific integrated
release scenario is detailed in this guide in the following sections. It
is a common requirement of larger enterprises that are making extensive
use of PLM systems and a scenario that is supported by Onshapeâ€™s REST
APIs.&lt;/p>
&lt;h4 id="multi-part-part-studios">Multi-Part Part Studios&lt;/h4>
&lt;p>In traditional CAD systems there is the understanding that one file =
one part. While design in context is available in most CAD systems and
multiple solid bodies can be created, it does not change the fact that
each part is self-contained in a separate file. For PLM systems this
makes it easy to associate an object in the PDM/PLM database with a
specific CAD file.&lt;/p>
&lt;p>This is not the case in Onshape.&lt;/p>
&lt;p>In Onshape, parts are designed in whatâ€™s called a â€œPart Studioâ€. Within
a Part Studio the designer is free to create as many parts as they want.
The general rule is that the parts should be related to each other in a
system thereby making it easier to design one part from another, however
there is a lot of flexibility in how the designer wishes to work.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage15.png"
style="width:4.45764in;height:4.12141in"
alt="A picture containing text Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977877" class="anchor">&lt;/span>Figure 6 - An example of
a multi-part Part Studio in Onshape&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />The structure of the Onshape
document is discussed in detail further on in this section. The Part
Studio is included in an Onshape document&lt;/p>
&lt;p>We can already begin to understand that the traditional CAD/PDM paradigm
of one file per object is not going to work with Onshape. If this
methodology were to be implemented, the designer would be forced by the
PDM/PLM system to only create one part per Part Studio. This would
therefore limit the designerâ€™s freedom for creativity in Onshape and
seriously reduce the powerful functionality available for the designer
to use.&lt;/p>
&lt;p>Therefore, we need to re-think how we integrate with Onshape vs how we
integrate with traditional CAD systems. Fortunately, Onshapeâ€™s REST API
supports the multi-part Part Studio scenario. Instead of associating a
file with an object in the PDM/PLM database, we now use the REST API to
associate a Part with its corresponding object.&lt;/p>
&lt;h4 id="versions-and-releases">Versions and Releases&lt;/h4>
&lt;p>Traditional PDM/PLM systems provide design release support by locking a
CAD file for access. The access controls are defined in the database and
the definition of a Part/Assembly/Drawing as released is controlled by
the database. When a new revision of the part is required, a file copy
is made, and the database provides access to the new copy. Generally,
the old copy representing the previous release persists in the file
store and can be referenced by the database.&lt;/p>
&lt;p>This is not how Onshape works.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage16.png"
style="width:2.66865in;height:3.09375in" />Since there are no files in
Onshape â€“ just data â€“ there is no file locking and copy mechanisms
available. Instead Onshape looks at the data as a continuous timeline
that is always moving forward and always changing as the design evolves.
The data is never locked, it is always available.&lt;/p>
&lt;p>In place of file copies representing versions and releases of the
design, Onshape provides the ability to create versions as â€œbookmarksâ€
in the timeline. When creating a version, Onshape places a bookmark in
the timeline that represents the state of the design at that specific
moment in time. Releases work in a similar way, however they are defined
as official company approved processes and have special meaning whereas
versions are personal bookmarks that save the state of the design at a
specific moment in time. Still, as far as Onshape is concerned, they are
points in the timeline that represent a release or a version.&lt;/p>
&lt;p>In addition to creating versions and releases Onshape has the capability
to create branches. These could be defined as alternative timelines. A
designer might want to experiment with alternate design ideas without
modifying the existing design that other people might be working on. By
creating a branch from any point in the timeline, the designer is now
free to experiment with alternate ideas. If the ideas work, they can be
merged into the current timeline at any point.&lt;/p>
&lt;p>Obviously from an integration perspective we need to take into
consideration how Onshape works with versions and releases. As
mentioned, Onshape understands that a release represents a company
approved design and it therefore provides processes for the approval of
a release and the change of state of a design. Onshape also provides
APIs and triggers (events) that enable integration points throughout the
release process. It is through the triggers and the APIs that
integration of any third-party system that wishes to manage the release
process is enabled.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />This scenario and the
methodologies around the integration of release processes is discussed
in depth in the last section of this book.&lt;/p>
&lt;h4 id="workflows">Workflows&lt;/h4>
&lt;p>Release and obsoletion workflows are included with Onshape â€“ these
processes can be customized to meet company standards. While this
section of the book doesnâ€™t go into any depth on the topic of
customizing workflows, it is important to understand how Onshapeâ€™s
workflows work and provide integration points.&lt;/p>
&lt;p>For details on how to implement and customize Onshapeâ€™s workflows,
please review these online help topics:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>How to Design release management Processes can be referenced
&lt;a href="https://cad.onshape.com/help/Content/relmgmt_custom.htm?tocpath=Enterprise%7CGetting%20Started%20as%20an%20Enterprise%20Administrator%7C_____8">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Creating a Customized Release Workflow can be referenced
&lt;a href="https://cad.onshape.com/help/Content/custom_workflow.htm?tocpath=Enterprise%7CGetting%20Started%20as%20an%20Enterprise%20Administrator%7C_____7">here&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Most PDM and PLM systems have the capabilities to model a companyâ€™s
business processes in a workflow. These can be highly automated
processes that move data and file references through a process of
reviews and approvals. Onshape also has this capability which is
currently used for release and obsoletion processes.&lt;/p>
&lt;p>However, in Onshape there are no files or file references that are moved
through the process. Onshape only has data. Therefore, it is the data
that is referenced at each stage of the process. Traditional PDM systems
might make file copies and lock files as they move through a release
process â€“ for instance. If the process is rejected at any stage, those
files must be discarded, the previous version of the files unlocked and
all states updated â€“ in short, rewind back to the state of the files and
the data when the workflow was initiated. This is a lot of complex
actions that need to occur when a process is rejected for any reason.&lt;/p>
&lt;p>Onshape doesnâ€™t work this way.&lt;/p>
&lt;p>A release process can be started on data â€“ such as assemblies, parts,
drawings, etc. The state of those referenced parts are updated to
â€œPendingâ€ for instance. If the process is rejected at any stage, there
is no rewinding of files and data â€“ the data just reverts to the
original â€œIn Progressâ€ state and the workflow is discarded. Since the
workflow didnâ€™t complete â€“ nothing related to the data has actually
changed. When you are used to traditional PDM systems, this feels like
an anti-climax and we often receive the question, â€œBut whereâ€™s my
process? Whereâ€™s the data that was attached to the process?â€. Well, the
answer is â€“ nothing changed â€“ until the process is completed, nothing
actually changes so the data is in the same state it was prior to the
initialization of the release process.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage17.png"
style="width:3.39863in;height:2.61034in"
alt="A picture containing chart Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977879" class="anchor">&lt;/span>Figure 8 - A custom
Release process in Onshape&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />We will be using a custom
workflow during the Business Case 2: Sync Revisions and releases
scenario that is detailed later in this book.&lt;/p>
&lt;h3 id="the-document-structure">The Document Structure&lt;/h3>
&lt;p>When integrating with Onshape itâ€™s very important to understand how an
Onshape document is defined. There are quite a few components to a
document that are inputs into most REST API calls. This section
describes the various parts of a document and how they are referenced.&lt;/p>
&lt;p>There are four key parts to a document as follows:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>A Document&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An element&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A Workspace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A version&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage18.png" style="width:6.5in;height:3.18681in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage19.png"
style="width:1.96875in;height:1.92945in" />The document is the container
that includes all the content related to a specific design. It could be
described as the project that contains all the relevant information
related to a design. This would include multiple versions, Assemblies,
Drawings and any other related documentation that has been attached to
the design.&lt;/p>
&lt;p>An element is a tab included in a document. You can add as many elements
to a document as you wish. An element can be a Part Studio, an Assembly,
A drawing, a file, or a custom application. Folders are not considered
elements â€“ they are containers that include elements and are used to
group elements together in logical groupings.&lt;/p>
&lt;p>Onshape can contain multiple workspaces however you always start off
with the â€œMainâ€ workspace. Additional workspaces are created by
branching from the main timeline. As mentioned previously, branches are
used to make modifications and experiments on a design without having to
change the main design that multiple people might be involved in. A
workspace can be merged back to the main workspace at any time.&lt;/p>
&lt;p>A version is any version or release created in the timeline. You can go
back to a specific version by clicking on it and viewing the state of
the design at that point in time. Versions can be referenced in the
APIs.&lt;/p>
&lt;h4 id="the-onshape-url">The Onshape URL&lt;/h4>
&lt;p>Since Onshape is a web based solution it uses a URL to define what gets
loaded in the browser. Depending what we are looking at in the browser,
the URL might change, however while we are working on a design we will
most often see a URL that looks something like the following:&lt;/p>
&lt;p>&lt;a href="https://cad.onshape.com/documents/1a1e1448eb196be9cb49d5b3/w/d6824c9ad8a44f4ae370bc56/e/4a823863687f4e7e1bbc858d">https://cad.onshape.com/documents/1a1e1448eb196be9cb49d5b3/w/d6824c9ad8a44f4ae370bc56/e/4a823863687f4e7e1bbc858d&lt;/a>&lt;/p>
&lt;p>The first part of the URL defines the Onshape enterprise that we are
working under â€“ in this case itâ€™s the default cad.onshape.com&lt;/p>
&lt;p>The second part: &lt;strong>/documents/&lt;/strong> provides the unique ID of the document
that we have loaded in the browser.&lt;/p>
&lt;p>The third part &lt;strong>/w/&lt;/strong> provides the unique ID of the workspace that we
are currently working in.&lt;/p>
&lt;p>The final part of the URL &lt;strong>/e/&lt;/strong> is the current element (or tab) that
is open.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />All these values are often
referenced in the API calls as either input to a POST request or
returned from a GET request.&lt;/p>
&lt;p>An additional value that is relevant is the version ID &lt;strong>/v/&lt;/strong> that will
be displayed in the URL when you click on a specific version in the
timeline.&lt;/p>
&lt;p>&lt;a href="https://cad.onshape.com/documents/1a1e1448eb196be9cb49d5b3/v/5d8dba3ffc41601291b5d7bf/e/4a823863687f4e7e1bbc858d">https://cad.onshape.com/documents/1a1e1448eb196be9cb49d5b3/v/5d8dba3ffc41601291b5d7bf/e/4a823863687f4e7e1bbc858d&lt;/a>&lt;/p>
&lt;p>These are the most important parts of a document related to
integrations. We will be presenting additional concepts related to
customizing a document in the next section of this guide.&lt;/p>
&lt;h2 id="integration-considerations">Integration Considerations&lt;/h2>
&lt;p>As we have seen, there is much to Onshape that is different from
traditional CAD and PDM systems. For system integrators who have
previous experience with these types of systems the instinct is to try
and apply the concepts developed for those integrations to an Onshape
integration â€“ this is a mistake. Applying existing integration concepts
to Onshape simply wonâ€™t work.&lt;/p>
&lt;p>There are several key points related to integrations that I want to make
here. Most of these points are generic concepts that should be applied
to any integration and are mostly common sense.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Do not limit the capabilities of the software&lt;/strong>: When applying
integration practices of legacy file-based solutions to Onshape you
will be required to adjust the way designers work in Onshape to
accommodate the limitations of your integration. Instead, the
integration should utilize best practices and methodologies that can
be applied to modern SaaS based solutions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Enable designers the freedom to work without constraints&lt;/strong>:
Designers working in a CAD system should never have their ability to
use the software features to the fullest restricted by the demands
of badly architected integration. The software is designed to
provide its users with the freedom to innovate and the flexibility
to adjust to how a designer wants to work. When an integrator places
usage constraints on the users of the software it is always to
intended to cover gaps in the solution and cut corners.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Utilize the best in class features from each solution&lt;/strong>: Different
software solutions are designed to provide features that should
provide expected functionality for whatever function the software
was designed to do. For instance, a CAD system should have best in
class tools for modeling, whereas data management tools should
provide capabilities to manage, analyze and report on data. While
there might be overlap between systems, it is a best practice to let
each software solution do exactly what it was designed to do instead
of forcing one to perform the functions of the other.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Map out your business processes&lt;/strong>: Decide which software solution
is responsible for which part of the process. It will be impossible
to develop a successful integration if the requirements arenâ€™t
clearly stated. The business process(es) that you are managing
through the integration should be mapped out as should the systems
involved, and which system is responsible for which function.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use standards&lt;/strong> &lt;strong>and Published APIs&lt;/strong>: The worst thing that can
happen is when thousands of lines of code and days of work are
thrown away because of an upgrade of a piece of software. By using
industry standards and published APIs you will protect yourself from
such a disaster.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="integrating-3suprdsup-party-applications-with-onshape">Integrating 3&lt;sup>rd&lt;/sup> Party Applications with Onshape&lt;/h1>
&lt;p>Onshape uses industry standards for establishing a secure connection
between itself and a third-party application. In order to access
Onshapeâ€™s resources, any application requesting those resources must be
authenticated by Onshape. Likewise, if Onshape needs to access resources
from a third-party application, Onshape must be correctly authenticated
by the third party prior to access being granted.&lt;/p>
&lt;p>In order to enable this Onshape uses OAuth 2.0&lt;/p>
&lt;h2 id="authentication-overview">Authentication Overview&lt;/h2>
&lt;h3 id="what-is-oauth2">What is OAuth2?&lt;/h3>
&lt;p>The OAuth (Open authorization) protocol was developed by the Internet
Engineering Task Force - The Internet Engineering Task Force is an open
standards organization, which develops and promotes voluntary Internet
standards, in particular the technical standards that comprise the
Internet protocol suite â€“ it enables secure delegated access to an
applications resources.&lt;/p>
&lt;p>The OAuth2 protocol enables an application to access a resource that is
under the control of someone else. In order to access that resource a
Token is required. The Token represent the delegated rights of access
(defines what rights this application has such as read/write/update,
scope, rights to different resources and more). In this way the
application can be accessed by a third party system without that system
impersonating the user who controls the resource.&lt;/p>
&lt;p>A good analogy is the hotel check-in process.&lt;/p>
&lt;p>When you arrive at the front desk of a hotel you are generally asked to
provide an ID and a form of payment. In response you are provided with a
key card that opens a specific door. When you reach that door, you swipe
your key card and you are granted access. The door itself doesnâ€™t know
who you are or anything about you â€“ it just knows that the key card was
encoded correctly, and it allows you access. At some point in time the
key card expires and the door no longer lets you into the room. This is
the same for Access Tokens in the OAuth2 flow.&lt;/p>
&lt;h3 id="how-does-oauth-work">How Does OAuth Work?&lt;/h3>
&lt;p>With the OAuth2 protocol, you register your application with the
3&lt;sup>rd&lt;/sup> party, you are given a set of keys. These keys get
exchanged for an Access Token that grants you access to resources in the
3&lt;sup>rd&lt;/sup> party application. Every now and then that token expires
and in order to access the resources, you are required to get a new
token. For this, you are provided with a refresh token. Sending the
refresh token to the authentication server will provide you with your
updated access token and a new refresh token. In our analogy the
Authorization server is the same as the clerk at the check-in desk, heâ€™s
validating that weâ€™re registered and that we can in fact access the
resources in the hotel. Once validated he provides us with a key card =
authorization token. With this card we can now access our room, the gym
and possibly some other hotel resources. Likewise, the authorization
token enables us to access the API resources.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage20.png"
style="width:5.2782in;height:3.375in"
alt="Getting Started with OAuth2 - Keap Developer Portal" />&lt;/p>
&lt;p>&lt;span id="_Toc102977881" class="anchor">&lt;/span>Figure 10 - OAuth2
Authorization Flow&lt;/p>
&lt;p>The first step to the OAuth flow is for the Onshape user to request
Onshape to authorize access for the 3&lt;sup>rd&lt;/sup> party application to
access Onshape.&lt;/p>
&lt;p>Once the user has authorized the application, they will be redirected to
a predefined URL together with a code that will be used to request an
access token from Onshape. Therefore, the redirect URL should contain a
script that can capture the authorization code.&lt;/p>
&lt;p>The access token is the token you will use to authenticate requests to
the Onshape API. Note that the token expires after predefined set amount
of time. In order to get a new valid access token after one has expired,
you must use the refresh token to request a new access token.&lt;/p>
&lt;p>Refreshing the Access Token will also provide you with an updated
refresh token that will be used in the next refresh access token
request. Make sure to store both the access token and the refresh token
and update them with each refresh of the token.&lt;/p>
&lt;p>The authorization token must accompany any call to the API, this is done
by adding the token to an Authorization field in the header of each
request:&lt;/p>
&lt;p>â€˜Authorizationâ€™ : â€˜Bearer [authorization code here]â€™&lt;/p>
&lt;p>If correctly authenticated the response from the REST API call will be a
stream of JSON data with an HTTP response code of 200.&lt;/p>
&lt;p>In the event that the authorization code is incorrect â€“ for instance, if
it expired, you will receive an &lt;strong>HTTP 401&lt;/strong> response. This response
means that the client request has not been completed since it lacks
valid authentication credentials for the requested resource. In this
event your code for each call to the REST API should include a catch
clause for a 401 exception. Once caught, you can refresh the token and
make the request again.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />&lt;/p>
&lt;p>We provide a complete code example for catching errors from the HTTP
request at the end of this section.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />You may find additional
information on implementing OAuth2 with Onshape at
&lt;a href="https://onshape-public.github.io/docs/oauth/">https://onshape-public.github.io/docs/oauth/&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />A very good resource for
learning more about OAuth2 can be found at
&lt;a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&lt;/a>&lt;/p>
&lt;h2 id="enabling-a-3suprdsup-party-application-in-onshape">Enabling a 3&lt;sup>rd&lt;/sup> Party Application in Onshape&lt;/h2>
&lt;p>Now that we have understood the basics of the OAuth2 flow, we should be
well equipped to understand how to setup a 3&lt;sup>rd&lt;/sup> party
application that can communicate with Onshapeâ€™s APIs and receive
notifications from Onshape via events.&lt;/p>
&lt;p>To get started you will be required to request a login for:&lt;/p>
&lt;p>&lt;a href="https://dev-portal.onshape.com/">https://dev-portal.onshape.com/&lt;/a> if you require a login, please email
&lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a>.&lt;/p>
&lt;p>This developer portal has links to documentation and some public
examples on the Onshape GitHub which can be found here:
&lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>.&lt;/p>
&lt;p>Letâ€™s get started by clicking on the OAuth applications menu option on
the left side of the screen. Then click on the â€œCreate new OAuth
applicationâ€ button on the top right.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage21.png"
style="width:4.22532in;height:4.4569in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977882" class="anchor">&lt;/span>Figure 11: Create new
OAuth Application interface&lt;/p>
&lt;p>The fields in this screen should be filled out as follows:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Name&lt;/strong> â€“ this is the application name that you wish to display to
the users. It should include the name of your company to
differentiate it from other possibly similar application. I.e.
â€œJambaCorp PLMâ€ instead of just â€œPLMâ€.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Primary format&lt;/strong> - this string uniquely identifies your
application and is a marker for the data it might store on Onshape
servers. It should take the form of a Java style reverse domain
name:Â com.jambacorp.plm. This value cannot be changed after the
application is registered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Summary&lt;/strong> â€“ this is a description of your application. This is
displayed to the user when theyâ€™re asked to grant the application
permission to access their data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Redirect URLs&lt;/strong> - Your application must specify at least one URL
used in the OAuth protocol exchanges. This URL must also use SSL (a
URL that begins withÂ https), with two exceptions applicable for
installed desktop applications. Possible reasons for specifying more
than one redirect URI is if you deploy â€œtestâ€ and â€œproductionâ€
versions of your application, and want to use a specific version of
your application for different sets of users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Admin Team&lt;/strong> â€“ this is an optional field. If defined, members of
the admin team selected will have access to make changes to the
definition of this OAuth application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OAuth URL&lt;/strong> â€“ This URL is the â€œAuthentication Pageâ€ for your
application. This is the first URL called from the Onshape
Applications page (described in detail in the next section). The
page hosted at this URL should handle the OAuth authentication. Once
your applicationâ€™s server has been authenticated on behalf of the
user, that user should be redirected to your applications content.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Permissions&lt;/strong> â€“ this is also called application scope and it
defines what access rights you want your application to have with
regards to the userâ€™s data. The options are as follows:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Application can read your profile information&lt;/strong> â€“ this will
enable your application to access the Onshape user profile.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Application can read your documents&lt;/strong> â€“ Onshape documents
created by this user can be accessed with read privileges only&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Application can write to your documents&lt;/strong> â€“ The user owned
Onshape documents can be modified by this application&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Application can delete documents and workspaces&lt;/strong> â€“ Your
application will be able to delete a workspace within a document
or the complete Onshape document.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Application can request Purchases on Your behalf&lt;/strong> â€“ The
application will have access to make purchases if required.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Application can Share and unshare documents on your behalf â€“
Onshapeâ€™s document sharing capabilities are very powerful and
enable other parties to access your shared documents with
predefined rights. If this option is checked, the application
will be able to automatically share a document with other
people.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>Once you fill in all this information and click on the â€œCreate
Applicationâ€ button, Onshape will return to you an OAuth Client ID and
an OAuth Client Secret string â€“ these keys will be used in your code for
requesting a one-time user authorization code from Onshape. They will
identify to Onshape the registered application. While the Client ID is
considered public - it is how your specific application is uniquely
identified in OAuth protocol exchanges - the Client SecretÂ mustÂ be
stored securely. For example, it should NOT be checked in to source code
control systems. Protect the Client Secret as you would any password
data.&lt;/p>
&lt;p>Your application is now registered with Onshape and you have options to
modify the application definition through this portal.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage22.png"
style="width:4.95449in;height:2.74509in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977883" class="anchor">&lt;/span>Figure 12 - OAuth
application definitions&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Later in this chapter we will
take a deep dive into defining Application Extensions in Onshape and
passing OAuth2 credentials to a third-party application in order that
Onshape may access the resources of that app.&lt;/p>
&lt;h2 id="implementing-oauth2-in-your-code">Implementing OAuth2 in your Code&lt;/h2>
&lt;p>In this section we take a look at some sample code of how the OAuth2
authorization flow is enabled. Weâ€™re not showing the complete code here,
just the relevant parts of the code that relate to authentication
against Onshape and using the REST API with the acquired access token.
There are plenty of online resources that show this flow in more detail,
however here we are focused on the implementation of OAuth2 in regards
to Onshape.&lt;/p>
&lt;p>The code samples are provided in node.JS, however you are free to use
any programing language of your choice in developing your integration.
There are good resources on the Onshape public GitHub in both node.JS,
Python, Java and C# - these can be found at:
&lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>.&lt;/p>
&lt;p>So far, we have registered our application with Onshape and received an
OAuth Client ID and an OAuth Client Secret string. We will be using
these strings in this section in order to receive a one-time user
authorization code.&lt;/p>
&lt;h3 id="step-1-get-the-user-authorization-code">Step 1: get the user authorization code&lt;/h3>
&lt;p>Weâ€™ll start by loading the basic libraries required to run this sample.
Since this is node.JS Iâ€™m using npm to directly load the libraries into
my development environment.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />The samples here just relate
to the authentication portions of the code and assume that you have
knowledge on setting up and running a Node.js server. All the settings
in this sample are stored in an .env file and referenced through config
class. Where required I have made comments which expected value each
setting is referencing&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Passport is Express
compatible authentication middleware for Node.js. Its sole purpose is to
authenticate requests which it does through plugins known as strategies.
In this sample we are using an Onshape developed plugin
â€œpassport-onshapeâ€, however this is not mandatory, and you can define
your own strategy to use with passport. The passport API is very
straightforward; you provide Passport a request to authenticate, and
passport will provide hooks for controlling what occurs when
authentication succeeds or fails. For more information on Passport
please reference &lt;a href="https://www.npmjs.com/package/passport">https://www.npmjs.com/package/passport&lt;/a>&lt;/p>
&lt;p>To install Passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>$ npm install passport
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To install passport-onshape plugin for Passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>$ npm install passport-onshape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Define your app.js (Server file).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> express = require(&lt;span style="color:#a50">&amp;#39;express&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> session = require(&lt;span style="color:#a50">&amp;#39;express-session&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> passport = require(&lt;span style="color:#a50">&amp;#39;passport&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> OnshapeStrategy = require(&lt;span style="color:#a50">&amp;#39;passport-onshape&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tell Express to use Passport and initialize passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">var&lt;/span> app = express();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(session({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret: session_secret,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resave: &lt;span style="color:#00a">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveUninitialized: &lt;span style="color:#00a">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.initialize());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.session());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Store Onshape user information so it can be retrieved from req.user in
each call.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>passport.serializeUser((user, done) =&amp;gt; done(&lt;span style="color:#00a">null&lt;/span>, user));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>passport.deserializeUser((obj, done) =&amp;gt; done(&lt;span style="color:#00a">null&lt;/span>, obj));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notes on serializeUser and deserializeUser:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Passport usesÂ the
serializeUserÂ function to persist user data (after successful
authentication) into the session. The functionÂ deserializeUserÂ is used
to retrieve user data from session.&lt;/p>
&lt;p>Passport needs the following setup to save user data after
authentication in the session:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.use(session({ secret: session_secret }));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.initialize());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.session());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The following diagram explains what happens with the serialize and
deserialize functions.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />To learn more about Passport
please reference &lt;a href="https://www.npmjs.com/package/passport">https://www.npmjs.com/package/passport&lt;/a>&lt;/p>
&lt;p>Initialize Passport with the Onshape Strategy&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>passport.use(&lt;span style="color:#00a">new&lt;/span> OnshapeStrategy({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clientID: oauth_clientid, &lt;span style="color:#aaa;font-style:italic">//the client ID string that you got when registering the app with Onshape
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> clientSecret: oauth_clent_secret, &lt;span style="color:#aaa;font-style:italic">//The secret string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> callbackURL: oauth_callback, &lt;span style="color:#aaa;font-style:italic">//The Oauth Callback URL ex: /oauthRedirect
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> authorizationURL: oauthurl, &lt;span style="color:#aaa;font-style:italic">//https://oauth.onshape.com/oauth/authorize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> tokenURL: oauthtokenurl, &lt;span style="color:#aaa;font-style:italic">//https://oauth.onshape.com/oauth/token
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> userProfileURL: userprofileurl &lt;span style="color:#aaa;font-style:italic">//https://cad.onshape.com/api/users/sessioninfo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(accessToken, refreshToken, profile, done) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> profile.accessToken = accessToken;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> profile.refreshToken = refreshToken;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//Here you can store the user profile, accessToken, RrefreshToken in your database
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> userController.updateUser(accessToken, refreshToken, user).then((data)=&amp;gt;{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">return&lt;/span> done(&lt;span style="color:#00a">null&lt;/span>, data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The OnshapeStrategy takes six values, all which should be stored in your
.env (or configuration) file. There are several values that donâ€™t change
and should use the following definitions:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>authorizationURL : &lt;a href="https://oauth.onshape.com/oauth/authorize">https://oauth.onshape.com/oauth/authorize&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tokenURL : &lt;a href="https://oauth.onshape.com/oauth/token">https://oauth.onshape.com/oauth/token&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>userProfileURL : &lt;a href="https://cad.onshape.com/api/users/sessioninfo">https://cad.onshape.com/api/users/sessioninfo&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The callback function will provide us with the accessToken, the
refreshToken and the userâ€™s Onshape profile once authentication has been
successfully passed. We can now use this to update our database with
user specific information.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that if you store the
accessToken and refreshToken in the database along with the user record,
this will have to be updated each time that the access codes are
refreshed.&lt;/p>
&lt;p>Next we define our endpoint where the authorization flow starts in this
case â€˜/oauthSigninâ€™. This is the endpoint that we previously defined in
the Onshape application setup. This will redirect to an Onshape page in
order for the user to confirm (or deny) the applications access to the
Onshape resources.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.use(&lt;span style="color:#a50">&amp;#39;/oauthSignin&amp;#39;&lt;/span>, (req, res) =&lt;span style="color:#f00;background-color:#faa">\&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">return&lt;/span> passport.authenticate(&lt;span style="color:#a50">&amp;#39;onshape&amp;#39;&lt;/span>, { state: uuid.v4() })(req, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, (req, res) =&lt;span style="color:#f00;background-color:#faa">\&lt;/span>&amp;gt; { &lt;span style="color:#099">/\* redirected to Onshape for authentication \*/&lt;/span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.43056in;height:0.46528in" />The state fields can be used
to store relevant information such as documentId, ElementId,
WorkspaceId, etc â€“ in the event that this information is sent from
Onshape. In this sample we have not defined any fields.&lt;/p>
&lt;p>The following page is displayed:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage23.png"
style="width:4.74911in;height:3.28125in"
alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977885" class="anchor">&lt;/span>Figure 14 - Onshape
Authorize Application Interface&lt;/p>
&lt;p>This page pulls information, such as the name, the description, the
permissions from the original application setup in Onshape. Once the
user clicks on the â€œAuthorize applicationâ€ button, the flow will
redirect to the redirectURL defined in the application setup.&lt;/p>
&lt;h3 id="step2-exchange-the-code-for-an-access-token">step2: Exchange the code for an access token&lt;/h3>
&lt;p>Fortunately, if you are using Passport, there really isnâ€™t a lot that
you need to do once the user clicks the â€œAuthorize Applicationâ€ button.
The return URL will contain the one-time authorization token and the
passport will extract that and exchange it for an access Token and a
refresh token. These will be available in the Passport callback function
shown previously.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//OAuth2 redirect code will be replaced for a token
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(&lt;span style="color:#a50">&amp;#39;/oauthRedirect&amp;#39;&lt;/span>, passport.authenticate(&lt;span style="color:#a50">&amp;#39;onshape&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>failureRedirect: &lt;span style="color:#a50">&amp;#39;/grantDenied&amp;#39;&lt;/span> }), (req, res, next) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">// additional optional redirect parameters to be added to the redirect
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>URL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res.redirect(&lt;span style="color:#a50">`/?authsuccess=true`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above code there are a few interesting points.&lt;/p>
&lt;p>Firstly, if the user clicked on the â€œDenyâ€ button, the user is navigated
to a page that notifies that access to the application was denied. We
can see that in the â€œfailureRedirectâ€ argument. The route for calling
the â€œgrantDenied.htmlâ€œ page is defined below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.get(&lt;span style="color:#a50">&amp;#39;/grantDenied&amp;#39;&lt;/span>, (req, res, next) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res.sendFile(path.join(__dirname, &lt;span style="color:#a50">&amp;#39;public&amp;#39;&lt;/span>, &lt;span style="color:#a50">&amp;#39;html&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a50">&amp;#39;grantDenied.html&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Another interesting point to mention is the following line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>res.redirect(&lt;span style="color:#a50">`/?authsuccess=true`&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, we can add additional parameters to the URL that gets called once
the OAuth process completes successfully. In this case Iâ€™m adding a
simple argument that lets my index page know that authorization
completed successfully. The index page then produces a notification that
the application has been successfully authenticated by Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage24.png" style="width:6.5in;height:1.88611in"
alt="Graphical user interface, text, application, website Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977886" class="anchor">&lt;/span>Figure 15 - Notifying the
user of successful authentication&lt;/p>
&lt;h3 id="step-3-using-the-access-token">step 3: Using the access token&lt;/h3>
&lt;p>Our application is now registered and successfully authenticated by
Onshape. This means that the application can access Onshapeâ€™s resources
as long as a valid access token is provided along with our API calls.&lt;/p>
&lt;p>The â€˜access_tokenâ€™ must be supplied on all subsequent Onshape API
requests as a header value:Â Authorization: Bearer &amp;lt;access_token&amp;gt;Â The
access token uniquely identifies the combination of your application,
the Onshape user and the set of permissions granted for the access
token.&lt;/p>
&lt;p>The access token has a limited lifetime of 60 minutes, after which it
will no longer work and attempts to use it will result in an error
response for an Onshape API request. The application must use the
refresh token returned by the original authorization code exchange to
generate new access tokens&lt;/p>
&lt;p>The following code is a complete example of getting metadata for a
specific Part. The documentId, WorkspaceId, ElementID and PartId have
been sent over as arguments. The user data including the access token
and the refresh token is included in the request object.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage25.emf" alt="">&lt;/p>
&lt;p>For making the web call I am using a library called â€œaxiosâ€ there are
many such libraries available on npm, however do check that they are
still supported. I initiated the axios library in this way after
installing it:&lt;/p>
&lt;p>const axios = require(&amp;lsquo;axios&amp;rsquo;).default;&lt;/p>
&lt;p>More details regarding the axios library can be found here:
&lt;a href="https://www.npmjs.com/package/axios">https://www.npmjs.com/package/axios&lt;/a>&lt;/p>
&lt;p>In the code above note the catch clause:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>}).&lt;span style="color:#00a">catch&lt;/span>(&lt;span style="color:#00a">function&lt;/span> (data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">if&lt;/span> (data.response.status === &lt;span style="color:#099">401&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authentication.refreshOAuthToken(req, res).then(&lt;span style="color:#00a">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getMetadata(docid, wsid, eleid, pid, req, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the call to the Onshape API fails for any reason it is caught by this
catch clause. The first reason for failure would probably be because the
accessToken has expired, this would return an HTTP 401 error â€“ not
authorized.&lt;/p>
&lt;p>If this is the case, we are sending a request to refresh the access
token. Once that request comes back with a new token, we are calling our
getMetadata function again.&lt;/p>
&lt;p>The refresh Token functionality is explained in detail in the next
section.&lt;/p>
&lt;p>In the code above, all the metadata properties are returned in JSON
format in the response.data.properties object.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that in the call
authentication.refreshOAuthToken â€œauthenticationâ€ is a library of
methods related to authenticating the user and the application through
OAuth2. For simplicity of explanation, I have until now, placed all my
calls in the app.js file, however it is a better practice to organize
all the OAuth2 calls in the same library.&lt;/p>
&lt;h3 id="step-4-refreshing-the-token">Step 4: Refreshing the token&lt;/h3>
&lt;p>We have already seen a call to refresh the access token in the previous
section. As mentioned previously I have all my OAuth2 refresh code in my
authentication library.&lt;/p>
&lt;p>When the access token expires it must be refreshed by making another
POST request toÂ https://oauth.onshape.com/oauth/tokenÂ with the following
URL encoded form body (again, with
Content-TypeÂ application/x-www-form-urlencoded):&lt;/p>
&lt;p>grant_type=refresh_token&amp;amp;refresh_token=&amp;lt;refresh_token&amp;gt;&amp;amp;client_id=&amp;lt;client_id&amp;gt;&amp;amp;client_secret=&amp;lt;client_secret&amp;gt;.&lt;/p>
&lt;p>As with the authorization code data, the parameters in the form body
must be URL encoded. The response to this POST request will be a JSON
encoded structure as before with a newÂ access_tokenÂ value that can be
used for the next 60 minutes.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Refresh tokens are valid for
the lifetime of the userâ€™s grant. If a user who has previously granted
access to your application decides to revoke the grant, the refresh
token is invalidated. If the user decides to re-grant application
access, a new refresh token is generated and returned along with the
access token.&lt;/p>
&lt;p>The following code takes care of the call to Onshapeâ€™s authorization
server to refresh the access token.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that in this sample it
is using the npm package â€œrequestâ€ to make the web call. This package
has since been depreciated and you should use another supported package,
such as axios.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage26.emf" alt="">&lt;/p>
&lt;p>We use the variable pendingTokenRefreshes to hold the value of the
session.id. If pendingTokenRefreshes is populated with the session.id,
that would mean that there is a token refresh already pending. This
would occur if there were multiple calls to the Onshape API while the
refresh was still pending.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage27.emf" alt="">&lt;/p>
&lt;p>The final part of the relevant code is the onOAthTokenReceived. This is
called following a successful call to refresh the token. The access
token and the refresh token are updated in the req.user object and if
you wish you can update the database with the refreshed information.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage28.emf" alt="">&lt;/p>
&lt;h3 id="user-grant-of-authorization">User Grant of Authorization&lt;/h3>
&lt;p>As mentioned previously, it is the Onshape user who actually grants
authorization to the third-party application to access the Onshape data.
This must be done by each user who needs to work with the third-part
application.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />In order to grant access,
after logging into Onshape, the user should click on the top right menu
that drops down from their name.&lt;/p>
&lt;p>Note that this menu will look different depending upon the users
specific rights and enterprises that he/she has access to.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage29.png"
style="width:1.89869in;height:2.26471in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>Click in the â€œMy Accountâ€ option. This will bring up the userâ€™s profile.
The click on the â€œApplicationsâ€ option on the left side menu.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage30.png" style="width:6.5in;height:3.20764in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>This is where the user grants access to an application. Find the
third-party application that you wish to authorize and click on the
â€œGrantâ€ button in the â€œOnshape accessâ€ column.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that where you see a
â€œGrantâ€ button in the â€œexternal accessâ€ column, this means that the
application requires Onshape to access its resources. We will examine a
business case in the next section where this is a requirement.&lt;/p>
&lt;p>Once you click on the â€œGrantâ€ button, you should see a page similar to
the following â€œAuthorize Applicationâ€ screen shown below.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage23.png"
style="width:5.13542in;height:3.54816in"
alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;p>Click to authorize the application and you will now be redirected to
that application and access to the Onshape resources and your user
profile in Onshape would have been granted successfully.&lt;/p>
&lt;h3 id="oauth2-summary">OAuth2 Summary&lt;/h3>
&lt;p>Implementing OAuth2 can be complex since itâ€™s a multi-step process that
requires specific data to be delivered at specific times in a specific
format. Using a library such as Passport does make our lives a lot
easier when implementing such a solution.&lt;/p>
&lt;p>Weâ€™ve covered a lot of ground in this section. First, defining a
third-part application in Onshape, understanding what OAuth2 is and how
it works through concreate examples of how to implement it and
communicate with Onshape.&lt;/p>
&lt;p>In the end, simplifying the explanation, OAuth2 is a three-step process
that secures your applications and guarantees that an application isnâ€™t
impersonating a user when it access the resources, but is a validated
â€œknownâ€ entity that the user approves to access the data.&lt;/p>
&lt;p>The code shown here is sample code intended to provide you with the
logic of how this process works. If youâ€™ve implemented OAuth previously
this should be very self explanatory, and if not, feel free to use these
code samples and adjust them to your own needs.&lt;/p>
&lt;p>It is important to mention that if you wish Onshape to access data from
your application, the same sort of mechanism must be implemented in your
code. Onshape supports through its app extensions the ability to connect
through OAuth2 to a third-party app and retrieve data from that
application. This implementation I shown in the next section where we
get into specific business cases for integration.&lt;/p>
&lt;h1 id="the-methodology-of-specific-business-cases">The methodology of specific Business Cases&lt;/h1>
&lt;h2 id="methodology-introduction">Methodology Introduction&lt;/h2>
&lt;p>This section of the guide focuses on the implementation of specific
common business cases that are found in most integrations. In the
previous section we have spent a lot of time attempting to clarify how
third-party apps are setup and communicate securely with Onshape through
the OAuth2 flow. In this section we will continue that topic and expand
upon it by looking at how we can setup a third-party app that Onshape
will pull data from.&lt;/p>
&lt;p>As part of the business cases documented here we will also look in depth
at the methodologies around setting up and using web hooks (events) in
Onshape.&lt;/p>
&lt;p>One of the most common business cases, which is the first we will look
at, will use both webhooks as well as expand upon the OAuth2 subject by
enabling Onshape to pull data from our third-party application. In this
business case, we will pull part numbers from the third-party
application. Those part numbers are calculated based upon input pushed
from Onshape to the third-party application.&lt;/p>
&lt;p>Another common business case deals with the release of data. Whether the
data is released initially in Onshape or in the third-party application,
we need to keep those releases in sync. The examples that we will use
here build off each other yet can also be provided as standalone
solutions. In our second business case we use data pushed to the
third-part application in the first scenario to release data and push
notifications back to Onshape.&lt;/p>
&lt;p>The third and final business case deals with the creation of derivative
files, such as PDF, STEP, etc. once the release has been successfully
completed.&lt;/p>
&lt;h2 id="business-case-1-sync-objects-and-metadata">Business Case 1: Sync Objects and Metadata&lt;/h2>
&lt;h3 id="business-case-1-overview">Business case 1 Overview&lt;/h3>
&lt;p>The first business case is probably the most common, â€œHow do I sync data
that I create in Onshape with my ERP or PLM system?â€. There could be
many reasons why you would want to sync data between two different
systems. Primarily Onshape is a system that creates new data. This data
is created by designers as they perform their daily tasks. While the
designer works primarily in Onshape, the actual data that they create
does not exist in a vacuum, it is used by other departments, other
processes within the organization. These departments and processes
probably do not have access to Onshape or the required knowledge of how
to use Onshape. In addition, quite often, the data generated by Onshape
will be augmented with additional data as the product lifecycle process
progresses.&lt;/p>
&lt;p>Therefore, Onshape could be considered the genesis of the data that will
be used to develop a product, yet it is not the only data that will be
required.&lt;/p>
&lt;p>In this business case we examine how a designer could work in Onshape
and how the data generated by Onshape can be used to make decisions in
other systems. Based upon the decisions made, data is pushed back to
Onshape as values calculated in another system. Letâ€™s look at the
process in much more detail.&lt;/p>
&lt;h4 id="step-1-define-properties-in-onshape">Step 1 Define Properties in Onshape:&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage31.png"
style="width:5.41667in;height:1.84722in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>In the first step, the designer starts a new part in Onshape â€“
remember that in Onshape a Part can be created along with other
parts in a Part Studio, so we can assume that there could be
multiple parts created in the single document. Obviously, we want
the designer to have the freedom to use all Onshape functionality
without constraints placed by the demands of the integration.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>At some point in the design process, the designer will be required
to enter property values for the part â€“ these could include values
such as the Part Name, the description, material and so on.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The designer clicks the â€œSaveâ€ or â€œApplyâ€ button for the properties
and closes the properties window.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A web hook that listens to any changes in the properties has been
defined. As the user saves the properties, the web hook is
triggered, and it will send a notification through the defined web
hook to the third-party system.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note: There are Part
properties, workspace properties and document properties â€“ all these
properties live at different levels of the document. While the trigger
could pick up changes to any to these properties, we are currently
focused on just Part properties â€“ the event will be triggered on any
saving of properties, however our third-party code can ignore anything
thatâ€™s not a Part (or an Assembly). In this next step we assume that a
new object is being created in the third-party application.&lt;/p>
&lt;h4 id="step-2-create-corresponding-object">Step 2 Create Corresponding Object:&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage32.png"
style="width:5.16667in;height:2.13889in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once the designer made changes to the properties in Onshape and
saved those changes, a message is sent to our third-party
application. This message is in JSON format and contains minimal
information such as the Workspace ID, the Document ID, the Element
ID, the Part ID (if itâ€™s a Part) and information regarding the event
that was triggered. The third-party application receives this
information to an endpoint that was defined during the setup of the
web hook.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The code in our application can now use the IDâ€™s sent over to check
if an object with corresponding IDs exists in our system. Here we
are assuming that no such object exists. This does mean that we must
store Onshape IDs into our objects in the third-party system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then create a new object and populate the ID information and save
it to the database. Note that at this point in time, we only have
minimal information that provides no more than the identity of the
Onshape Part.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Next, in order to get the complete metadata, we must make a REST API
call to Onshape in order to get the metadata for the part. Since we
were provided the ID information in the web hook, we have enough
information to go back to Onshape and request the metadata for a
specific, document, element, workspace and part.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that you can either
store the Onshape IDs in separate fields in your database or as one long
unique string which can be used to easily identify the part in your
application.&lt;/p>
&lt;h4 id="step-3-get-onshape-metadata">Step 3 Get Onshape Metadata:&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage33.png"
style="width:5.75in;height:2.04167in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The response from the call to the Onshape API is sent back as JSON.
The data will contain a lot of different objects that represent the
property values, their types, the IDs, name of the property, value
of the property, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once received this data must be parsed by your third-party
application code and the corresponding object updated as required.
For bi-directional update, it is important to store the Onshape
property IDs of any data that will need to be synced back to Onshape
from the third-party application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This is an optional stage. Once you have all the metadata values
imported, you could now calculate any values that are based off the
metadata. The most common use case scenario is the generation of
intelligent part numbers. Based off configuration, part type, etc.,
you could generate a part number that has specific meaning within
the context of the company.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If you calculated specific values, you can now store them in your
database.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="step-4-modify-properties-in-onshape">Step 4 Modify Properties in Onshape:&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage34.png"
style="width:5.04167in;height:3.97222in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>As in Step 1 the designer updates the properties in Onshape â€“ this
is obviously something that can happen multiple times&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The web hook is triggered when the designer saves the property
changes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Our third-party application is listening for property changes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The third-party applicationâ€™s code will check if the corresponding
object exists based off the IDs sent from Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In this scenario the corresponding object has already been saved in
our system&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We make a REST API call to Onshape to get the metadata based off the
IDs sent from Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape returns the JSON that represents the updated properties&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We ingest the updated metadata and update our existing object in the
third-party system.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="step-5-request-part-number">Step 5: Request Part Number&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage35.png"
style="width:5.76389in;height:2.13889in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>As we will see later, Onshape has the built in capability to pull
custom part numbers from a third-party system. From either the
properties window or the release candidate window, click the button
to request a part number&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape sends basic ID information to a predefined endpoint in our
third-party app.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The ID information sent by Onshape is enough data to find the
corresponding object in our database. We then extract from that
object the pre-calculated intelligent part number â€“ or we can
calculate it at this point.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The part number is returned to Onshape and populated in the Part
Number field&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that in order to pull a
part number from a third-party application we will need to implement
OAuth2 in our application and grant Onshape access to the resources of
our application. Onshape has a very good mechanism for achieving this
and we will be explaining this in detail in this section.&lt;/p>
&lt;p>Note that by default Onshape uses its own internal Part number
generator, in order to use a custom third-party generator, we will need
to define an app extension and then define in the Enterprise release
settings to use our custom part number generator.&lt;/p>
&lt;h4 id="step-6-push-updates-from-third-party-application">Step 6: Push Updates from Third-Party application&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage36.png"
style="width:5.75in;height:2.45833in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>In this scenario we are updating an Object in our third-party
application and expecting that some of the property values will be
updated in Onshape. We can either send over all the properties
populated for this object, or a subset of properties and values&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The REST API to update properties in Onshape requires that we
reference the IDs of the properties that we are updating. For this
reason we have stored the Onshape property IDs with our metadata
object in our database.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We construct the correct JSON that contains all the properties to
update and the new values. We can then call the Onshape REST API to
update the properties in Onshape with the new data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once successfully completed, the Onshape REST API call will return
HTTP 200 and we can notify the user if needed.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that updates to Onshape
will happen behind the scenes in real-time, therefore someone working on
the document in Onshape will be able to see the updates as soon as they
have been made. There is no notification in Onshape that notifies the
user that properties have been updated, however you can open the
properties window and view the updated data.&lt;/p>
&lt;h3 id="business-case-1-implementation">Business case 1 implementation&lt;/h3>
&lt;p>In this section of the guide, weâ€™ll really dig into the implementation
of the first business case that we outlined previously. The concepts and
procedures that we introduce here will be relevant for the rest of the
business cases and provide a foundation for any other integration
development with Onshape.&lt;/p>
&lt;p>Weâ€™ll start by defining an App Extension in Onshape so that we can
receive custom part numbers.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />It is important to mention
that this guide does not go into complete detail with regards to App
extensions, it just focuses on the requirements for this specific
business case. For the complete App Extension guide please reference
this link: &lt;a href="https://onshape-public.github.io/docs/extensions/">https://onshape-public.github.io/docs/extensions/&lt;/a>&lt;/p>
&lt;h4 id="rest-api-tips-and-tricks">REST API Tips and Tricks&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage8.png"
style="width:0.44444in;height:0.44444in" /> There are many endpoints
available in the Onshape REST API. While in this guide we have
documented a few of the APIs that are relevant to the business cases we
are discussing, there are many, many more APIs available. While there
isnâ€™t complete documentation available for all the endpoints, there are
some useful tools that we can use to better understand the APIs and what
input they require and output they provide.&lt;/p>
&lt;h5 id="glassworks">Glassworks&lt;/h5>
&lt;p>Glassworks is Onshapeâ€™s official API explorer. It lists all the
available endpoints, provides the ability to run the APIs within its
interface and provides the output from the API. Actual documentation of
each API is scant at the moment; however we can expect this to improve
over time.&lt;/p>
&lt;p>Glassworks can be found at: &lt;a href="https://cad.onshape.com/glassworks">https://cad.onshape.com/glassworks&lt;/a>&lt;/p>
&lt;p>Glassworks provides several ways to connect to Onshape so that you can
try out the APIs&lt;/p>
&lt;ol>
&lt;li>
&lt;p>OAuth2 â€“ input your OAUth2 credentials&lt;/p>
&lt;/li>
&lt;li>
&lt;p>API Key â€“ input your API key as defined in the Onshape developer
portal.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape Cookie â€“ If you are running Onshape in a browser tab,
Glassworks can use that logged in session to authenticate the API
calls.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage8.png"
style="width:0.44444in;height:0.44444in" />If you choose to use the
Onshape Cookie note that the domain names should match. Therefore of you
are using cad.onshpae.com, the domain for Glassworks should be:
&lt;a href="https://cad.onshape.com/glassworks">https://cad.onshape.com/glassworks&lt;/a> however, if you are using your own
enterprise such as myenterprise.onshape.com, then the correct URL for
Glassworks will be &lt;a href="https://myenterprise.onshape.com/glassworks">https://myenterprise.onshape.com/glassworks&lt;/a>&lt;/p>
&lt;p>All of these options can be set by clicking on the Authorize button
found close to the top of the page.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage37.png"
style="width:4.36685in;height:3.98802in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977893" class="anchor">&lt;/span>Figure 22 - Glassworks
Authentication Options&lt;/p>
&lt;p>The complete list of available endpoints is categorized by topic; i.e.
Document related endpoints appear in the Documents category, Metadata
related endpoints in the Metadata category â€“ so it should be relatively
easy to find the endpoint you are looking for.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage38.png"
style="width:5.51469in;height:4.04234in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977894" class="anchor">&lt;/span>Figure 23 Glassworks &amp;ldquo;Try
It Out&amp;rdquo; feature&lt;/p>
&lt;p>The above image shows the â€œTry It Outâ€ feature of Glassworks, in this
case we can see the JSON returned for a specified document.&lt;/p>
&lt;p>In some cases, the input requirements are not fully documented.
Specifically when a body is required for an API call. While we expect
Glassworks to improve with full documentation overtime, it still lacs
some key documentation.&lt;/p>
&lt;p>Fortunately there is another easy way to view the requirements of an API
and that is to actually run the command in Onshape.&lt;/p>
&lt;h5 id="debug-using-browser-developer-tools">Debug Using Browser Developer Tools&lt;/h5>
&lt;p>All Browsers now have developer tools exposed in their interface. These
tools provide us ways to debug client code, view console messages and
most importantly for our use case, view Network requests and their
response.&lt;/p>
&lt;p>In this example I am using Chromeâ€™s developer tools. Most other Browsers
have more or less copied Chromeâ€™s layout for the developer tools so it
should be easy to find the network section.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage39.png"
style="width:5.36972in;height:4.16096in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977895" class="anchor">&lt;/span>Figure 24 Accessing
Chrome&amp;rsquo;s Developer Tools&lt;/p>
&lt;p>Letâ€™s take the simple use case of trying to understand which endpoint
Onshape uses for saving Metadata.&lt;/p>
&lt;p>Open a document in Onshape and define some properties â€“ donâ€™t save yet.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage40.png"
style="width:3.42406in;height:2.25966in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>Prior to saving open the developer tools and click on the â€œNetworkâ€ tab.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage41.png" style="width:6.5in;height:2.37014in"
alt="Table Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977896" class="anchor">&lt;/span>Figure 25 Developer Tools
Network Tab&lt;/p>
&lt;p>Next save the updated properties by clicking either the Apply Button or
the Save Button&lt;/p>
&lt;p>In the Network tab you will see a new web request â€“ select it:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage42.png"
style="width:5.40656in;height:2.82458in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977897" class="anchor">&lt;/span>Figure 26 Network Request
Sample&lt;/p>
&lt;p>What we are seeing here is the response from the call to Save the
properties. We can expand this response to view the complete JSON.&lt;/p>
&lt;p>By clicking on the Headers we can view the actual request:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage43.png"
style="width:5.125in;height:2.47222in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977898" class="anchor">&lt;/span>Figure 27 HTTP POST
Request for Saving Properties&lt;/p>
&lt;p>Here we can see that this will correspond to the APIs listed in
Glassworks.&lt;/p>
&lt;p>Most importantly the â€œPayloadâ€ tab is our definition of the body of the
request. This is provided in JSON format and can be expanded. As shown
here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage44.png"
style="width:4.90769in;height:2.94205in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977899" class="anchor">&lt;/span>Figure 28 HTTP POST Body&lt;/p>
&lt;p>We now have the correct API call and the format of the body to
successfully make the API call. We can also see from the body that if we
wish to update properties in Onshape from our third-party application,
we need to store the propertyID value.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />It is important to mention â€“
ALWAYS use cad.onshape.com to make API calls (no matter what you see in
the Headers tab or is shown in the Payload tab.&lt;/p>
&lt;h4 id="define-an-application-extension">Define an Application Extension&lt;/h4>
&lt;p>An application extension is how Onshape embeds third-party application
features in its UI. There are two types of extension:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>An extension that embeds its UI from the application into the
Onshape UI in an iFrame. Such a application my call Onshape REST
APIs or just expose an application interface inside Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An extension that embeds and that calls a REST API exposed by the
application from the Onshape UI. For instance, embedding application
functionality in the context menus or toolbars. This type of
application extension relies on external OAuth information in order
to authenticate the call. In this case Onshape acts as the client
and the application as the server.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Each extension will exist at a specific location in the Onshape UI and
will work within the context of that location or a specific selection,
passing the relative information to the application.&lt;/p>
&lt;p>In order to define the Application Extension we return to the
development portal at &lt;a href="https://dev-portal.onshape.com/oauthApps">https://dev-portal.onshape.com/oauthApps&lt;/a> where
we initially defined our OAuth Application.&lt;/p>
&lt;p>Select the OAuth Application that you previously defined and click on
the Extensions tab.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage45.png" style="width:6.5in;height:3.37917in"
alt="Graphical user interface, text, application, Teams Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977900" class="anchor">&lt;/span>Figure 29 - Oauth
Applications - Extensions&lt;/p>
&lt;p>Start by clicking the â€œAdd Extensions button.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that you can create as
many extensions as you need for your application within the Onshape UI.&lt;/p>
&lt;p>This is the interface where you define where in the Onshape UI the
command will appear, and what endpoint in your application the command
will reference. Changing the Location dropdown will provide additional
fields that can be defined to specify context and other relevant fields.&lt;/p>
&lt;p>For our use case, Define a name, i.e. â€œCustom Part Number Generatorâ€,
define a description of the extension and select â€œPart Number Generatorâ€
from the Location dropdown. The only other field that you need to define
is the Action URL. This is the endpoint in your application where you
will fetch the part number from.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage46.png" style="width:4.125in;height:4.125in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977901" class="anchor">&lt;/span>Figure 30 - Define
Application Extension&lt;/p>
&lt;p>Once you save the definition you will see it in the list of extensions.
You can always come back and edit the definition of the extension.&lt;/p>
&lt;h4 id="grant-onshape-access-to-3suprdsup-party-data">Grant Onshape Access to 3&lt;sup>rd&lt;/sup> Party Data&lt;/h4>
&lt;p>If you require Onshape to access the resources of your application, then
you will need to define the external OAuth parameters. In our use case
we will need Onshape to access data in our application in order to pull
the part numbers into Onshape.&lt;/p>
&lt;p>Click on the External OAuth tab, the final tab on the OAuth Applications
page.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage47.png" style="width:6.5in;height:3.27361in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977902" class="anchor">&lt;/span>Figure 31 - Define
External OAuth&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />In this guide weâ€™re not
detailing the implementation of OAuth2 inside your application, this is
explained very well in many on-line guides. My favorite of these can be
found at:
&lt;a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&lt;/a>&lt;/p>
&lt;p>Onshape provides the fields that are required for it to make a secure
request to your application, receive an access Token and refresh it when
required. In this case Onshape acts as the client and your application
as the server â€“ this is the inverse to what we defined when we enabled
the third-party application to access Onshape.&lt;/p>
&lt;p>Once you have defined the fields, Save/Update the definitions. We have
now completed defining the application extension and enabling Onshape to
access your applications resources.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note if you havenâ€™t defined
all the endpoints at this time, you can come back later and update the
information once you have it defined in your application.&lt;/p>
&lt;p>The last thing we need to do is for the user to grant access for Onshape
to access your applications resources. We can do this through the same
interface that we used to grant access to Onshape.&lt;/p>
&lt;p>From inside Onshape go to your account settings, from the top right
dropdown menu. Click on the applications page.&lt;/p>
&lt;p>For applications that have an application extension and External OAuth
defined we have the â€œGrantâ€ button available in the â€œexternal Accessâ€
column as shown here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage48.png" style="width:6.5in;height:2.87083in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977903" class="anchor">&lt;/span>Figure 32 - Grant
External Access&lt;/p>
&lt;p>Click the â€œGrantâ€ Button in the External Access column.&lt;/p>
&lt;p>Your third-party application will present the user with option to
authorize access to the application â€“ similar to this simple interface:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage49.png"
style="width:4.25285in;height:1.71051in"
alt="Graphical user interface, text Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977904" class="anchor">&lt;/span>Figure 33 - Enabling
Onshape to access a 3rd parties data&lt;/p>
&lt;p>If you click â€œAllowâ€, you will be returned to Onshapes Applications page
and external access will be granted.&lt;/p>
&lt;h4 id="defining-webhooks">Defining Webhooks&lt;/h4>
&lt;p>Now that weâ€™ve defined our application extension and OAuth access to our
application, we can start on receiving notifications in our application
when events happen in Onshape.&lt;/p>
&lt;p>Onshape supports webhook notification for many different types of
events. We will register an endpoint in our application that will
receive a notification whenever something occurs in Onshape. In our
specific scenario this will be when the user updates the Onshape
properties â€“ as we defined in &lt;strong>Step 1 Define Properties in Onshape&lt;/strong>:&lt;/p>
&lt;p>For our purposes we will be registering to receive web hook
notifications for the onshape.model.lifecycle.metadata event. When
registering for an event in Onshape there are only two pieces of
information required:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The event (onshape.model.lifecycle.metadata)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Enterprise ID&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To easily find your enterprise ID, in Onshape select the Enterprise
Settings option from the top right dropdown menu and then click on the
â€œDetailsâ€ menu option on the left-hand menu bar.&lt;/p>
&lt;p>You will see your Enterprise ID and a â€œCopy to Clipboardâ€ button next to
it. This will enable you to directly copy this unique ID into your code.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage50.png"
style="width:3.0006in;height:2.70759in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977905" class="anchor">&lt;/span>Figure 34 - Finding Your
Enterprise ID&lt;/p>
&lt;p>The following code shows how we can register a webhook in Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage51.emf" alt="">In this example Iâ€™ve hard-coded a few of
the values for clarity, however this method could be re-written to be a
generic model for registering various webhooks. Some good examples of
registering for webhooks exist at &lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>.&lt;/p>
&lt;p>As with other calls to Onshape that weâ€™ve seen, we are passing the
accessToken in the header in order to establish a secure call to
Onshapeâ€™s resources.&lt;/p>
&lt;p>The information coming back from the registration call will be similar
to the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;2014-12-16T23:45:10.611-0500&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;event&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;webhook.register&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;workspaceId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;elementId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;webhookId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;544e91f7fb88ed44f5de1508&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;messageId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;34795d2e5f5f44eeb61fb7b1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;data&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;Some data&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;versionId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In our example we are saving the event
(onshape.model.lifecycle.metadata) and the returned webhookId to a
database in order that we can later ping it to make sure that it is
live.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Following the registration of
the webhook, Onshape will attempt to make a call to the Notify URL
defined in the body of the registration request. This is the endpoint of
your application that should be called when the event is fired in
Onshape. The most common reason for registration failures is that the
endpoint you defined, does not return an HTTP 200 status code.
Therefore, even if you registered for an event and received a
registration notification and a webhookId back from Onshape, your web
hook is not in fact registered until Onshape validates the notify URL
and receives the HTTP 200 notification back from it. Unfortunately there
is no way to easily know if your web hook has been successfully
registered until you either ping it, request to list it, or try to
activate the event through Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Also it is important to know
that even when your webhook is registered successfully, if you change
your code later on and Onshape fails to receive an HTTP 200 status code
back from the notify URL, the web hook will be removed.&lt;/p>
&lt;p>One of the ways we can validate that a webhook is â€œliveâ€ is by pinging
it using the Onshape REST API. The following code shows the
implementation of a ping to the webhook. If an HTTP status code of 200
is returned, we know that the webhook is enabled, if not then we can
re-register the webhook as needed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />&lt;img src="https://onshape-public.github.io/images/integrationguideimage52.emf" alt="">Once
we store the webhook ID in the database we can ping the webhook whenever
the application is loaded and validate that itâ€™s still registered. If we
need to re-register the webhook (usually only occurs when changes are
made to the code in the notify URL), we can create a new webhook
registration and update the database record.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that you can create many
duplicate webhook registrations for the same event with the exact same
notify URL. Onshape doesnâ€™t limit how many registrations are created for
a single webhook. In the event that this happens, the notify URL will be
called as many times as there are webhooks registered for that event.
You can validate the registered webhooks by calling the
&lt;strong>&lt;a href="https://cad.onshape.com/api/webhooks">https://cad.onshape.com/api/webhooks&lt;/a>&lt;/strong> API.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Use
&lt;a href="https://cad.onshape.com/glassworks">https://cad.onshape.com/glassworks&lt;/a> to call APIs and validate the
requirements for each REST API call. This interface lists all the
available Onshape REST APIs and provides examples of the values returned
from each call.&lt;/p>
&lt;h4 id="receiving-webhook-notifications">Receiving Webhook notifications&lt;/h4>
&lt;p>Once your webhook is registered and confirmed to be working you should
be getting a notification from the webhook to your notify URL. The
notification should be similar to the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;event&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;onshape.document.lifecycle.metadata&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;workspaceId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;elementId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;webhookId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;544e91f7fb88ed44f5de1508&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;messageId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;data&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;Some data&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;0f9c4392e5934f30b48ab645&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;versionId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentState&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;IN PROGRESS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In your case the workspaceId, elementID, documentID, and PartId should
be populated with the values from the Onshape document that was open
when the properties were updated.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />It is important to note that
there is currently no OAuth validation on the webhook response,
therefore the endpoint in your application will not receive any access
token data for directly calling Onshape APIs. Therefore, if you need to
make a call to the Onshape REST APIs inside the notify URL endpoint make
a call to an endpoint in your application and include your application
OAuth credentials in the body of the request. In this way, you can make
a call to your application and load the passport and the Onshape
credentials.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Onshape takes security very
seriously and for this reason, unauthenticated calls only provide
minimal details such aa, in this case, idâ€™s.&lt;/p>
&lt;h4 id="getting-onshape-properties">Getting Onshape Properties&lt;/h4>
&lt;p>In our specific use case, when we received the webhook notification, we
want to use the ID data provided to find the corresponding object in our
database (or create a new one) as shown in Step 2 Create Corresponding
Object: Then we make a call to the Onshape REST API:
/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}&lt;/p>
&lt;p>All the relevant data is provided in the response from the webhook so we
can pass this to the method which will call this API as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage53.emf" alt="">From this call I am returning the
â€œpropertiesâ€ part of the JSON â€“ this contains all the metadata
definitions that I wish to store in my database and associate with the
corresponding object. The following is an example of one of the property
objects:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage54.emf" alt="">&lt;/p>
&lt;p>In fact there is probably only three key pairs that weâ€™re interested in
here:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Name â€“ name of the property. In this case â€œNameâ€&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Value â€“ the value of the property. In this case â€œTop Plateâ€&lt;/p>
&lt;/li>
&lt;li>
&lt;p>propertyId â€“ the ID of this property. We might need this if we want
to enable a bi-directional sync between both applications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that for valueType
CATEGORY the actual name, value and id will be embedded deeper in the
object inside an array. I suggest copying and pasting the output from
the API call into a JSON viewer such as &lt;a href="http://jsonviewer.stack.hu/">http://jsonviewer.stack.hu/&lt;/a> so
that it will be easier to find where the correct values are.&lt;/p>
&lt;p>We can now update our corresponding object with the Onshape metadata
values as described in Step 3 Get Onshape Metadata:&lt;/p>
&lt;h4 id="updating-onshape">Updating Onshape&lt;/h4>
&lt;p>So far we have pulled data from Onshape and populated it into our
third-party application, however what if we make updates in our
application that we want to propagate back to Onshape? This is certainly
possible through Onshapeâ€™s REST API. Usually this would be implemented
in your application on the click of a button â€“ such as â€œSaveâ€, if you
have multiple properties to update, or when a property is updated if you
want to trigger the sync for the update of a specific field.&lt;/p>
&lt;p>Either way it is fairly straight forward to send the REST API call to
Onshape to update properties. The following snippet of code shows how
the call can be made:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage55.emf" alt="">As we can see here, we provide the body in
the form of JSON that includes an array of items (in this case one item)
and a nested array of properties (two property objects are listed here).
Each property has a value and an ID of the property in Onshape to
update.&lt;/p>
&lt;p>The response from this API call should be an HTTP 200 status. If this is
the case, we can update the user that the sync was successful.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />If you know that you want to
update Onshape with property values from your application, it will be
important to build a data model that can store the properties with the
unique ID provided by Onshape.&lt;/p>
&lt;h4 id="implementing-custom-part-numbers">Implementing Custom Part Numbers&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage56.png"
style="width:2.95556in;height:2.94924in" />&lt;/p>
&lt;p>The final step in this
business case is to pull the part numbers form our third-party
application. The part numbers can be calculated based on metadata values
that were previously synced from Onshape or they might be numbers being
pulled from yet another system â€“ such as an ERP or even a Google
Spreadsheet. The important thing is that when the user clicks a button
in Onshape, the correct Part Numbers get populated.&lt;/p>
&lt;p>To first understand how the setup for pulling part numbers from a
third-party application we need to go back to the definition of our
Application Extension in the Onshape developerâ€™s portal.&lt;/p>
&lt;p>Here we can see that we gave the application extension a name, defined
the location as â€œPart Number Generatorâ€ and defined the â€œAction URLâ€ â€“
this is the endpoint in our application where we will fetch the part
number from.&lt;/p>
&lt;p>Once we have the application extension defined as Location = Part Number
Generator, you will be able to use this option inside Onshape Release
Management settings.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that in order to use the
Part Number Generator option you will have to define the External OAuth
option and grant Onshape access to the resources of your application.
This is because Onshape will need to access the defined endpoint in
order to pull the part number from the application&lt;/p>
&lt;p>From within Onshape Select the â€œEnterprise Settingsâ€ from the top right
dropdown menu. Navigate to the â€œRelease Managementâ€ settings and scroll
down to the â€œRevisions and part numbersâ€ section of the page.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage57.png"
style="width:4.05994in;height:3.27831in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977907" class="anchor">&lt;/span>Figure 36 - Revisions and
Part Number Settings&lt;/p>
&lt;p>In the Part Number Generation dropdown select the â€œCustom Part Number
Generatorâ€. Note that this is the name that you defined in your
Application Extension so it might differ from whatâ€™s shown here.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage58.png"
style="width:2.73732in;height:2.03131in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977908" class="anchor">&lt;/span>Figure 37 - Selecting
Custom Part Number Generator&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Finally scroll to the bottom
of the page and save the settings.&lt;/p>
&lt;p>Note that you will need the Admin role in order to access the enterprise
settings.&lt;/p>
&lt;h4 id="implementing-part-number-code">Implementing Part Number Code&lt;/h4>
&lt;p>Onshape will send a message to the endpoint defined in your application
extension settings. The content of this message will be an array of the
following data.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage59.emf" alt="">There might be one or more object depending
upon where the user initiated the call for part numbers from. For
instance, if the call was initiated from the Part properties window,
there will only be one object, however if initiated from the release
candidate window, multiple parts/assemblies and drawings might be
requested in the single call. Therefore, your code should be able to
handle these two situations.&lt;/p>
&lt;p>Onshape will expect a response back from your endpoint and it should be
formatted in the following manner:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage60.emf" alt="">Note that in fact only the id and
partNumber fields are actually required â€“ the other fields are optional.&lt;/p>
&lt;p>The following is an implementation of the getNextPartNumber endpoint
that was defined in the application extension â€œAction URLâ€ field:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage61.emf" alt="">This in turn calls a function that pulls
the next part number from the corresponding object in the database (this
was defined in, Step 5: Request Part Number). In this function Iâ€™m
defining the object that will be sent to Onshape with the part number.
This will be called multiple times depending how many objects were sent
from Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage62.emf" alt="">In this case Iâ€™m sending back all the data
required by Onshape, however it would be enough to just populate the id
and the partNumber.&lt;/p>
&lt;p>Once you load the Part Properties window or the Release candidate
window, you can now request the Next Part number. The part number will
be pulled from the third-party application and populated in the relevant
fields as shown below.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage63.png"
style="width:4.59649in;height:3.80143in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977909" class="anchor">&lt;/span>Figure 38 - Release
Candidate Part Number generation&lt;/p>
&lt;h2 id="business-case-2-sync-revisions-and-releases">Business Case 2: Sync Revisions and releases&lt;/h2>
&lt;p>Our next business case builds off the previous one as far as we have
corresponding objects in both systems that are in sync with each other
through the REST API integration and by using Webhooks.&lt;/p>
&lt;p>In this case, weâ€™ll be looking at the ability for Onshape to sync its
release data with an external system and for that system to send
information back to Onshape with regards to released data.&lt;/p>
&lt;p>This specific business case will look at what happens when you wish for
a PLM system to control the release of data instead of Onshape having
that control â€“ this is in fact a common use case.&lt;/p>
&lt;h3 id="business-case-2-overview">Business case 2 Overview&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage64.png"
style="width:3.21077in;height:2.56522in" />&lt;/p>
&lt;p>We have mentioned before that
Onshape has the ability to release data â€“ it is totally integrated to
Onshape since there is no division between CAD capabilities and PDM
capabilities in Onshape â€“ they are all part of the same solution. See
Versions and Releases for more information on how Onshape manages
releases. There is importance in releasing data through Onshape. Onshape
uses visual cues to show which parts are released in an assembly for
instance and which parts might have a newer revision. Onshape can also
add/remove watermarks to drawings and update the title block depending
on release states. Also, the BOM table can pull a parts release data and
display it. All this is dependent upon a release process being completed
in Onshape.&lt;/p>
&lt;p>Many organizations have implemented Product Lifecycle management systems
(PLM). One of the key benefits of a PLM system is that it manages more
than just engineering data originating from the engineering department,
it deals with all the data related to the product â€“ from concept through
retirement. Therefore, it is a system that is used by many groups and
departments throughout the organization.&lt;/p>
&lt;p>Often, in release processes or Engineering Change processes, additional
input and approvals are required from various departments downstream
from engineering. PLM systems are very good at routing the data for
approval to users from multiple departments and groups throughout the
organization. Onshape, on the other hand, is very focused on the
engineering department and the data generated there. While it certainly
has the capabilities to bring other groups into approval processes, it
is not considered a process centric enterprise-wide system with the
capabilities of a PLM system.&lt;/p>
&lt;p>Many companies will have well established processes that have been
modeled in their PLM system, it is much easier for us to integrate into
those processes than reinvent the wheel in Onshape.&lt;/p>
&lt;p>This section looks at how we might have the best of both worlds,
initiate release processes in Onshape and update our Onshape visual cues
as well as have the PLM system manage the actual approvals and release.&lt;/p>
&lt;p>This section uses concepts such as OAuth and web hooks that we have
introduced in detail in previous sections, therefore feel free to
reference those sections for more information on these topics.&lt;/p>
&lt;h4 id="step-1-initiate-release">Step 1: Initiate Release&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage65.png"
style="width:4.88889in;height:2.02778in"
alt="Application Description automatically generated" />&lt;/p>
&lt;p>In this first step we are using Onshapeâ€™s out-of-the-box capabilities to
initiate a release candidate â€“ just as we would if we were releasing
natively in Onshape.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We start by initiating the release on all the data that is required.
In this step you should use a custom workflow that simply has one
approval node.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Define the mandatory and any other release properties in the release
candidate window. &lt;img src="https://onshape-public.github.io/images/integrationguideimage66.png"
style="width:4.70609in;height:3.12281in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;span id="_Toc102977911" class="anchor">&lt;/span>Figure 40 - Initiating a
release candidate&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>Since an approver is required, we must provide a fictious
user/approver that has been defined in the system â€“ this could be
named â€œRelease Approverâ€ for instance. The process will be sent to
this approver even though they are not a real person and will not be
able to approve the release. Instead, our release process will be
approved by an external source.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally, when everything is defined, submit the release. The window
will close. Since the release is pending approval, the parts
involved in the release will enter the state of â€œPendingâ€ as shown
here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage67.png"
style="width:4.40131in;height:2.9375in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;span id="_Toc102977912" class="anchor">&lt;/span>Figure 41 - Pending
Release&lt;/p>
&lt;p>They will remain in this state until the release has been completed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage68.png"
style="width:2.71208in;height:1.52174in" />&lt;/p>
&lt;p>It is important to note that
unlike traditional PDM systems where the files are locked for change
until the release is completed or rejected, Onshape does not lock the
files. As mentioned previously, Onshape views the releases as a point in
time. As far as Onshape is concerned, time moves forward, parts can
change and at a specific point in time, the parts are in a state of
pending. It is important to mention that this does in fact prevent
another release from being initiated on the parts until the previous
release has been completed.&lt;/p>
&lt;h4 id="step-2-initiating-release-process-in-3suprdsup-party-app">Step 2: Initiating Release Process in 3&lt;sup>rd&lt;/sup> Party app&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage69.png"
style="width:5.34722in;height:3.34722in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;p>Once the user initiates the release candidate and the parts transition
to the â€œpendingâ€ state we can register for a webhook that will notify
our third-party application that the parts have changed state.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once the parts enter the workflow, the onshape.workflow.transition
webhook will be triggered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Our third-party application should be listening for this event along
with other data, we are provided with the objectId of the release
package â€“ this is all the data associated with the parts that are to
be released. The response also contains the objectType and the
transitionName; for our use case we will only concern ourselves with
requests that have an objectType of â€œReleaseâ€ and a transitionName
of â€œSubmitâ€.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Using the ObjectId we make an API call to onshape;
/api/releasepackages/&amp;lt;releasePackageId&amp;gt;?detailed=true&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This API call will return to us a JSON response containing all
assemblies and parts in the release package. The following
information should be extracted from the release package:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>For each line item (assembly or part) extract the documentId,
the elementId, elementType, versionId and PartId&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Iterate through the top level properties and record the
propertyId for property with the name â€œcommentâ€ â€“ this will be
used to update the release comments later on.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Now that we have the relevant IDs we can update the state of our
corresponding objects in the third party system and record any
additional data such as the release comment field.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally, we can kick off our official release process in the
third-party application. This could be an automated process or a
manual one.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="step-3-complete-release-process">Step 3: Complete Release Process&lt;/h4>
&lt;p>The release process continues in the third-party application until
approvals have been received by all required actors. Meanwhile in
Onshape the parts are in the pending state. In this step we close the
loop once the release process is completed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage70.png"
style="width:5.375in;height:3.34722in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The release process managed by the third-party application is
completed and the data in that system is released.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once this happens, we make a call to the Onshape API;
/api/releasepackages/&amp;lt;releasePackageId&amp;gt; the releasePackageId is
the ID we were provided with at the start of this process â€“ While
there are different ways of implementing this, I tend to store the
ID and any other data related to the release in a custom â€œrelease
Objectâ€ in my database so I can retrieve and update the release as
required. In addition to the passing the release package ID, in the
body of the request we should pass the id of the release comment and
a value for the comment. This will update the release in Onshape
with any relevant data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape releases the data that was included in the release candidate
and that completes the workflow process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape will return a status code that indicates success or failure&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally we can optionally update the corresponding object to
indicate that it is in sync with the Onshape data.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In the event that the release process is rejected at anytime, we can
send the releasePackages API request to Onshape with a REJECT workflow
Action argument. This will cause Onshape to reject the workflow and the
state of the parts at the specific release point in time, will be set to
â€œRejectedâ€.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage71.png"
style="width:4.69737in;height:3.12807in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977914" class="anchor">&lt;/span>Figure 43 - release
candidate rejected&lt;/p>
&lt;p>Since our timeline is moving forward this has no actual effect on the
parts other than to cancel the pending release and enable them to be
released at another future point in time.&lt;/p>
&lt;h3 id="business-case-2-implementation">Business case 2 implementation&lt;/h3>
&lt;p>In this section we will take a closer look at how to implement the
release scenario in our code. The first thing we need to do is define
the correct web hook to listen for the initiation of the release â€“ this
means that once the user clicks the submit button on the release
candidate dialog, this web hook will be triggered.&lt;/p>
&lt;h4 id="setup-webhook">Setup Webhook&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage72.emf" alt="">&lt;/p>
&lt;p>This code is very similar to what we defined previously for the metadata
update, instead here we are defining a hook for the
onshape.workflow.transition hook. As with other code examples that
require authentication, we have included error handling in order to
refresh that access token in the event that it has expired.&lt;/p>
&lt;p>The onshape.workflow.transition will in fact fire whenever a revision or
release package transitions through different workflow states. In his
specific case we are only interested in catching the event when the
workflow is initially submitted. This can be filtered by the information
sent to the return URL, in this case
&lt;a href="https://myserver.com/api/getReleaseData">https://myserver.com/api/getReleaseData&lt;/a>&lt;/p>
&lt;p>In this implementation we are storing he webhook ID in the database so
that we can ping it when the application is loaded to make sure that it
is still active. Other implementations delete the webhook after it is
used and then recreate it as required. There is no specific preference
for which methodology is better â€“ that depend s upon the requirements of
your integration.&lt;/p>
&lt;h4 id="receiving-web-hook-notifications">Receiving Web Hook Notifications&lt;/h4>
&lt;p>Once the user who is initiating the release clicks the Submit button on
the Release Candidate dialog, the webhook will be triggered and a
message will be sent to the third-party application listening for that
webhook.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage66.png"
style="width:4.70609in;height:3.12281in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>In our example the URL that the webhook data from Onshape gets sent to
is:&lt;/p>
&lt;p>&lt;a href="https://myserver.com/api/getReleaseData">https://myserver.com/api/getReleaseData&lt;/a>&lt;/p>
&lt;p>In our application we can define a router for that end point as follows:&lt;/p>
&lt;p>router.route(&amp;rsquo;/getReleaseData&amp;rsquo;).post(mymodule.getReleaseData);&lt;/p>
&lt;p>In this case â€œmymoduleâ€ is where Iâ€™ve defined all the functionality for
managing data coming from Onshape. Since the webhook data contains no
authentication information (just minimal data is sent from the webhoom
for security reasons), we canâ€™t directly authenticate our application
against Onshape, therefore we need to pass the data received from the
webhook through a method that will then add the authentication data to
our request object. The getReleaseData method simply passes the webhook
information received by the application to another authenticated
endpoint as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage73.emf" alt="">&lt;/p>
&lt;p>Here is the endpoint defined for processReleasePackage:&lt;/p>
&lt;p>router.route(&amp;rsquo;/processReleasePackage&amp;rsquo;).post(authController.isAuthenticated,
releaseController.processReleasePackage);&lt;/p>
&lt;p>As we can see here, we have now added in the authentication middleware -
authController.isAuthenticated - and can make secure calls to Onsahpeâ€™s
API.&lt;/p>
&lt;h4 id="getting-release-package-data">Getting Release Package Data&lt;/h4>
&lt;p>The parameter that the web hook sent over to our application that we
need to make use of is the ID of the release package. We can now make a
call to Onshape to retrieve the complete release package with the ID.&lt;/p>
&lt;p>We get the release package ID from the request object and make the REST
API call to get the package as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage74.emf" alt="">&lt;/p>
&lt;p>The complete release package should be returned in â€œresponseâ€. We can
now parse that data to retrieve the properties we need. The most
important properties will the IDs of the parts that we are going to
release â€“ these should already be synced with our system â€“ if not, we
can create them from the data in the release package.&lt;/p>
&lt;h4 id="saving-release-package-data">Saving Release Package Data&lt;/h4>
&lt;p>The next step is to save the properties of the release package to a
corresponding object in our database. We need at least the ID of the
release package so we can later release it automatically from the
third-party application. In this case Iâ€™m storing other properties that
came from the release candidate such as release name and description.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage75.emf" alt="">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage76.png"
style="width:3.01875in;height:4.38889in" />&lt;/p>
&lt;p>Most of this code deals with
retrieving values from the release package and storing them as a new
release object in the database. Additional values are associated with
the part in the PLM system. In a typical production scenario this code
would interface with the PLMs workflow capabilities and possibly kick
off a release or change process in that system. For our basic example we
are storing values from Onshape with our items and setting a state on
the part so that users can see that the part is pending release and take
actions required.&lt;/p>
&lt;p>At this point in time, Onshape does not care that the part is pending a
release. The part in Onshape will remain in a pending state until it is
released by the PLM system. As noted previously, we used a user setup in
the system to specifically initiate the release, therefore no other
users will receive notifications from Onshape with regards to release
actions on this part.&lt;/p>
&lt;h4 id="completing-the-release">Completing the Release&lt;/h4>
&lt;p>Once the release or change workflow has completed in the PLM system and
all approvals have been received, the Part/Item will be in a released
state in the PLM system. However, we must now update Onshape with the
correct release status of the parts. It is important that Onshape data
is in sync with the corresponding data in the PLM system for reasons of
data integrity and the visual cues used within Onshape to identify a
part as released.&lt;/p>
&lt;p>In a typical scenario Onshape will be automatically updated once the
workflow completes in the PLM system. In our use case we are simplifying
the process by clicking a button to release the item. This will update
the state of the part in our system and send a REST API call to Onshape
to release the data in the release package (be it one part, an assembly
with multiple parts, or drawings).&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage77.emf" alt="">&lt;/p>
&lt;p>This code snippet updates the database with the released status of a
part. Since we stored data from the release package in our database we
now retrieve the â€œCommentâ€ property so that we can send an updated value
to Onshape with the release.&lt;/p>
&lt;p>let attrid = rp.props.find(ob =&amp;gt; ob.name == &amp;ldquo;Comment&amp;rdquo;);&lt;/p>
&lt;p>The important line of code here is the REST API call to Onshape:&lt;/p>
&lt;p>&lt;strong>axios.post(&amp;lsquo;&lt;a href="https://cad.onshape.com/api/releasepackages/'">https://cad.onshape.com/api/releasepackages/'&lt;/a> + id +
&amp;lsquo;?wfaction=RELEASE&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>The id provided here is the ID of the release package that we stored
when the web hook was called at the beginning of the process. The
â€œwfactionâ€ argument indicates that the workflow action in Onshape should
be to release the data associated with this release package.&lt;/p>
&lt;p>In this example we are also updating the release comments in Onshape,
for this reason we required the property ID of the Comment field â€“ which
we also previously stored in our release object in the database.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage78.png" style="width:6.5in;height:4.25903in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977916" class="anchor">&lt;/span>Figure 45 - Release
completed automatically in Onshape&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage79.png" style="width:6.5in;height:4.25625in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977917" class="anchor">&lt;/span>Figure 46 - Release
comments Updated from third-party system&lt;/p>
&lt;h2 id="business-case-3-generate-derivative-files">Business Case 3: Generate Derivative Files&lt;/h2>
&lt;p>Itâ€™s clear by now that Onshape doesnâ€™t use files to store its data,
instead it is a data driven solution that is always up to date. Files
are a snapshot in time that provide a view of the design at a specific
point in time - such as at a release or version. A new file is required
for each â€œsnapshotâ€ and managing these files can get quite cumbersome.
However, there are situations that require that files be generated from
the Onshape data.&lt;/p>
&lt;p>In general, we want files to be generated at defined points of time and
within the context of a business process â€“ such as a release process.
The derived file could be a format such as a PDF of the drawing that is
generated following the successful release of the data. Also, a common
requirement is to generate STEP files or JT files that can be used in 3D
Printing or viewers embedded in PLM solutions. Regardless of the use
case Onshape has very good export capabilities for many different file
formats.&lt;/p>
&lt;p>This business case examines how to automatically generate files derived
from the Onshape data. The process described here can be plugged into
many different use cases. In this specific example we are plugging the
translation use case into the Release Business case just after the
release is completed in the third-party application and Onshape is
updated. Since we already have all the relevant ID information for the
parts to translate from the release package data, we can directly call
the translation APIs after receiving notification that the release was
successfully executed in Onshape.&lt;/p>
&lt;p>This business case could also be added as an application extension
directly into a context menu in Onshape see
&lt;a href="https://onshape-public.github.io/docs/extensions/">https://onshape-public.github.io/docs/extensions/&lt;/a> for more information
on how to add extensions to menus.&lt;/p>
&lt;p>For more information on the Translation APIs please see
&lt;a href="https://onshape-public.github.io/docs/translation/">https://onshape-public.github.io/docs/translation/&lt;/a>&lt;/p>
&lt;h3 id="business-case-3-overview">Business case 3 Overview&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage80.png"
style="width:5.5in;height:4.79167in" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once we have received an HTTP 200 status from the call to Onshape to
release the release Package, we can proceed with the translation.
The reason why we may want to wait till the release has successfully
completed could be for several reasons:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We are generating a PDF of the drawing and want the â€œIn
Progressâ€ watermark removed, and the title block updated with
release information&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We are generating files for 3D printing or for sending to a
vendor to manufacture and we only want to send released data&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>We can now make an API call to Onshape. In both the following cases
we must pass the document Id, the version Id and element Id â€“ all
values that were available in the release package. Other values are
dependent upon your specific use case and can be referenced in
&lt;a href="https://cad.onshape.com/glassworks/explorer/#/PartStudio/createPartStudioTranslation">https://cad.onshape.com/glassworks/explorer/#/PartStudio/createPartStudioTranslation&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>For Assembly translation we can POST to :/api
/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For Parts we can POST to:
/api/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Three variables of importance are returned from the API call to
translate: requestState, id (of the translation) and
resultExternalDataIds. We should store or keep this data in memory
until the translation is completed. Depending upon the requestState
there might be additional data available in the response.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We can now periodically ping the translation web service with the id
retrieved in the last step. Using the GET call to
/api/translation/{id} we will receive one of three responses in the
requestState:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>DONE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACTIVE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FAILED&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Depending on the response we can either continue to periodically
ping the translation service if we received ACTIVE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notify the user of a failed translation attempt if we received a
FAILED response&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Make a call to Onshape to GET the translated file if we received a
DONE response. To retrieve the translated file make a GET request to
/api/documents/d/{documentId}/externaldata/{externalDataId}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The file can now be stored in your third-party system or stored to
an external drive depending upon your specific use case.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="business-case-3-implementation">Business case 3 implementation&lt;/h3>
&lt;p>As use cases go, this is a very straightforward process. The only
complexity here is deciding how to receive the notification from Onshape
that the translation has completed. There are several ways of
implementing this including using a webhook to notify us when the
translation completes. In the examples here I will show both the webhook
methodology as well as pinging Onshape with a status request every
couple of seconds. The status request can be initiated from the client
through an AJAX call or, as in the example I use here, from the server.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage81.png"
style="width:3.3395in;height:3.66667in" /> In our example I have added a
button to the interface of my third-party system that enables me to
request a translated file. In this use case I have hard coded that the
resulting file should be a STEP file â€“ in a production ready
implementation, we would expect that one or more formats are available
and possibly selected by the user. In addition, a production ready
implementation might have automated the translation for whenever a part
is released. Other considerations for automation might include
identifying what is being released. I.e. if itâ€™s a part then translate
to STEP, if itâ€™s a Drawing then translate to PDF, etc. These are all
very common use cases.&lt;/p>
&lt;h4 id="initiating-the-translation">Initiating the Translation&lt;/h4>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage82.emf" alt="">The code snippet shown here is fairly
straightforward. First it gets the ID of the part that was sent from the
client, it then uses that ID to retrieve the part from the database. The
part stored in our database already has all the required values to
successfully communicate with Onshape, such as the document ID, the
workspace ID and the element ID â€“ all these values are used in the
translation request.&lt;/p>
&lt;p>In the body of the request we can see some of the required values that
define how the part is to be translated to STEP. In this case I have
only included the minimum required key pairs for this translation.&lt;/p>
&lt;p>The REST API call to translate an Onshape element returns an object that
includes the translationId â€“ this is the value that will be used to ping
Onshape and request the status of the translation.&lt;/p>
&lt;h4 id="ping-onshape-for-translation">Ping Onshape for Translation&lt;/h4>
&lt;p>In this code snippet I have simplified things by including a function
that waits for a second and then pings Onshape again, It will continue
pinging Onshape until it receives back a status that is not â€œACTIVEâ€.
Once the status returned is anything except â€œACTIVEâ€ it returns the
resulting object back to the client.&lt;/p>
&lt;p>The id used here is the translationId retrieved from the result object
when the translation was initiated.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage83.emf" alt="">&lt;/p>
&lt;p>Once the requestState is changed, this will indicate that the
translation has completed either with a FAIL or a DONE status. Depending
on the result we can define our logic on the client appropriately.&lt;/p>
&lt;p>The following shows the object returned to the client from the
translation REST API. Note that the requestState is now set to â€œDONEâ€,,
meaning that the translation has completed
successfully.&lt;img src="https://onshape-public.github.io/images/integrationguideimage84.png" style="width:6.5in;height:3.17986in"
alt="A picture containing timeline Description automatically generated" />&lt;/p>
&lt;p>With this data we can now request the file directly from Onshape. The ID
that we need to use to retrieve the file is the â€œresultExternalDataIdsâ€.
Note that this is an array of values â€“ since it makes sense that we
might be translating more than one part.&lt;/p>
&lt;h4 id="retrieve-translated-file">Retrieve Translated File&lt;/h4>
&lt;p>With the resultExternalDataIds we can now retrieve the translated file
from Onshape. The following code snippet does exactly this.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage85.emf" alt="">&lt;/p>
&lt;p>The Onshape REST API&lt;/p>
&lt;p>&lt;a href="https://cad.onshape.com/api/documents/d/'">https://cad.onshape.com/api/documents/d/'&lt;/a> + did + &amp;lsquo;/externaldata/&amp;rsquo; + id&lt;/p>
&lt;p>retrieves the translated file â€“ in this case the ID is
resultExternalDataIds[0] value.&lt;/p>
&lt;p>Once this is completed, we use the response to save the file directly to
our server where the application is hosted. Finally, Iâ€™m sending a JSON
object to the client that provides a direct link to the file that is now
hosted on our server.&lt;/p>
&lt;p>The client can then request the translated file from our server, even
though this is a function of the server and not related to Onshape, I
have included a code snippet here that will send the file to the client.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage86.emf" alt="">&lt;/p>
&lt;p>In our sample implementation Once the translation has completed
successfully I display a link to the translated file that calls the
â€œgetfileâ€ endpoint shown above.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage87.png" style="width:6.5in;height:2.32917in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;p>Clicking the link will cause the file to be downloaded as shown here.&lt;/p>
&lt;h4 id="translation-webhooks">Translation Webhooks&lt;/h4>
&lt;p>As we mentioned at the beginning of this section there is more than one
way to receive notification back from Onshape that the translation has
completed. We can also define a webhook that will notify us once the
translation completes. The drawback with this methodology is that the
webhook must be created for each translation and then deleted.&lt;/p>
&lt;p>A complete example of this can be found at:
&lt;a href="https://github.com/onshape-public/app-gltf-viewer/blob/main/services/webhook-service.js">https://github.com/onshape-public/app-gltf-viewer/blob/main/services/webhook-service.js&lt;/a>&lt;/p>
&lt;p>The following function is used in this application to define the
webhook:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage88.emf" alt="">&lt;/p>
&lt;p>The following line would call this function once the user requests to
initiate a translation.&lt;/p>
&lt;p>WebhookService.registerWebhook(req.user.accessToken,
req.session.passport.user.id, did)&lt;/p>
&lt;p>Finally the endpoint registered with the webhook could be defined as
follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage89.emf" alt="">&lt;/p>
&lt;p>In this case once the translation is completed, this endpoint receives a
notification. If the event is equal to&lt;/p>
&lt;p>onshape.model.translation.complete&lt;/p>
&lt;p>We can assume that the translation has completed and we can unregister
the webhook and retrieve the translated file.&lt;/p>
&lt;p>The complete sample including it setup and deployment can be found at:
&lt;a href="https://github.com/onshape-public/app-gltf-viewer">https://github.com/onshape-public/app-gltf-viewer&lt;/a>&lt;/p>
&lt;h1 id="integrating-into-the-onshape-interface">Integrating into the Onshape Interface&lt;/h1>
&lt;p>So far, we have seen how we can integrate Onshape with a third party
application. We reviewed how we can use OAuth2 to authenticate access to
Onshape from our third-party application and enable Onshape to access
and the resources of our third-party application.&lt;/p>
&lt;p>In this section we will review a few of the more common options for
embedding a third-party application into the Onshape interface. For the
most part this will already be setup since we have already defined one
such interface â€“ the retrieval of part numbers from the third-party
application.&lt;/p>
&lt;p>Onshape provides many options for embedding commands in various menus to
embedding interfaces in fly-out panels and elements. In this specific
use case we will look at embedding a custom web page inside the
documentâ€™s right side fly-out panel. This interface will receive
information from Onshape and push information from the panel back to
Onshape, thereby providing a complete bi-directional integration
scenario. This is very similar to what we have already done in the first
scenario by enabling a bi-directional exchange of metadata.&lt;/p>
&lt;p>The following screen shot is an example of what we will be achieving
with this integration:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage90.png"
style="width:5.39312in;height:2.61532in"
alt="Diagram Description automatically generated with medium confidence" />&lt;/p>
&lt;p>&lt;span id="_Toc102977918" class="anchor">&lt;/span>Figure 47 - Integrating
into the document right panel&lt;/p>
&lt;p>In this case we have created a custom web page that is displayed in the
right-hand fly-out panel. This interface displays metadata pulled from
the third-party system when a part in Onshape is selected.&lt;/p>
&lt;p>This interface is also able to update metadata in Onshape through the
Update functionality.&lt;/p>
&lt;h2 id="setting-up-the-integration">Setting up the Integration&lt;/h2>
&lt;p>We have already seen how to setup an application extension for the Part
Number Generator. Access the Developer portal from
&lt;a href="https://dev-portal.onshape.com">https://dev-portal.onshape.com&lt;/a> and click on the OAuth applications
option in the left menu. Select your application and click on the
extensions tab.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage91.png" style="width:6.5in;height:3.48958in"
alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977919" class="anchor">&lt;/span>Figure 48 - Oauth
Application Extensions&lt;/p>
&lt;p>Click on the Add Extension button on the top right.&lt;/p>
&lt;p>As we did with the Part Number Generator we can select the Location â€“ in
our specific case weâ€™ll select â€œElement Right Panelâ€, however as you can
see from the dropdown list, there are many other options available for
embedding your interfaces and commands inside Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage92.png"
style="width:5.05785in;height:5.66469in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977920" class="anchor">&lt;/span>Figure 49 - Defining
Application Extension&lt;/p>
&lt;p>Next, we must define the context. The context defines what parameters
can be sent from Onshape to our application. There are some basic
parameters automatically sent with any context, however based upon the
context selected, additional information can be passed to our
application. In our case we will select the â€œSelected Partâ€ option. This
will send the Part Id and Part Number to our application in addition to
the Document Id, the Element ID and the workspace/version ID.&lt;/p>
&lt;p>Note that the full list of contexts and the parameters sent from Onshape
can be found at: &lt;a href="https://onshape-public.github.io/docs/extensions/">https://onshape-public.github.io/docs/extensions/&lt;/a>&lt;/p>
&lt;p>In the Action URL field, fill in the URL of the page that you wish to
load in the right element panel. The parameters can be added as
arguments. These are variable that get replaced with real values when
the page is loaded from Onshape.&lt;/p>
&lt;p>In our case our URL might look something like the following:&lt;/p>
&lt;p>&lt;a href="https://ourserver.com/bom?documentId=$%7Bdocumentid%7D&amp;amp;elementId=$%7Belementid%7D&amp;amp;partId=%7B$partId%7D&amp;amp;partNumber=%7B$partNumber%7D">https://ourserver.com/bom?documentId=${documentid}&amp;amp;elementId=${elementid}&amp;amp;partId={$partId}&amp;amp;partNumber={$partNumber}&lt;/a>&lt;/p>
&lt;p>In the case of the selected Part context for the Element Right Panel,
the possible parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>{$documentId} - The Onshape ID for the current document.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace
or version respectively depending on current opened document state
or selection.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$workspaceOrVersionId} - The Onshape ID for the current or selected
workspace or version.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$workspaceId}Â - The Onshape ID for the current or selected
workspace. This is being deprecated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$versionId}Â - The Onshape ID for the current or selected version.
This is being deprecated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$elementId} - The Onshape ID for the current element (Part Studio,
Assembly, Drawing).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$partNumber} - The Part number property for the selected part,
Assembly or Drawing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$revision} - The Revision property for the selected part, Assembly
or Drawing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$featureId} - In case of feature selected in the Feature list in a
Part Studio.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$nodeId} - In case of mate or mate feature selected in the Assembly
list.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$occurrencePath} - In case of part instances, mates, mate
connectors and sub assemblies.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>{$configuration} - The active configuration of the current element.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Finally select an icon for your extension. This will appear on the tab
that opens the right element panel.&lt;/p>
&lt;p>We have now defined the extension and it will appear in the Onshape
interface.&lt;/p>
&lt;h2 id="calling-a-page-in-the-extension">Calling a Page in the Extension&lt;/h2>
&lt;p>As mentioned previously we defined the URL with the parameters to load
in the application extension definition window. This will load a regular
web page within the Onshape interface. For instance, you could load your
favorite news web site in the Onshape interface, there is no requirement
to pass any parameters to the web site. However, a more practicle
implementation would require passing parameters and using those
paramters to retrieve data from our third-party application and load
that data in the resulting web page.&lt;/p>
&lt;p>The following code snippet shows how we use our previous definition to
pull data from our third-party application and send it to our web page:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage93.emf" alt="">&lt;/p>
&lt;p>In this snippet we are checking that the partNumber parameter actually
got populated â€“ this means that a part number is defined for the
selected part. If it is defined we can then use the part number to
retrieve information about the selected part from our third-party
application.&lt;/p>
&lt;p>In the event that the part number isnâ€™t defined we can send information
to our web page that will be used to notify the user that a part number
must be defined in order to use this web page.&lt;/p>
&lt;p>Note that we could also use the document ID, the element ID and the Part
ID to retrieve the correct part if they are stored with our part in our
application.&lt;/p>
&lt;h2 id="using-our-application-extension">Using our application extension&lt;/h2>
&lt;p>In Onshape load a document. You will already see your icon embedded in
the right element panel.&lt;/p>
&lt;p>Select a part in a Part Studio and open the application:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage94.png" style="width:6.5in;height:3.94236in"
alt="Graphical user interface Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977921" class="anchor">&lt;/span>Figure 50 - Application
Extension with Part Selected&lt;/p>
&lt;p>In this case we selected a part that has not yet been synced with our
third-party application. Therefore no part number has been generated and
the system canâ€™t find a corresponding object in our database.&lt;/p>
&lt;p>When we select a part that has been synced and a part number has been
generated we will get a correct result as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage95.png"
style="width:5.49548in;height:3.32019in"
alt="Graphical user interface Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977922" class="anchor">&lt;/span>Figure 51 - Application
extension with synced part&lt;/p>
&lt;p>Since the context we selected for this application extension was
â€œSelected Partâ€, a part must be selected in order to load anything in
the extension. If no part is selected you will see a notification
similar to the following:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage96.png"
style="width:5.10442in;height:1.41408in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977923" class="anchor">&lt;/span>Figure 52 - Application
extension with no selected Part&lt;/p>
&lt;p>As we have seen in this section, Onshape provides a very flexible and
easy to use interface for adding in our third-party application
functionality directly into the Onshape interface. Once we have our
application setup and correctly authenticated against Onshape, we can
easily embed third-party functionality directly into Onshape. This
enables a seamless integration with our other enterprise applications.&lt;/p>
&lt;h2 id="methodology-summary">Methodology Summary&lt;/h2>
&lt;p>We have covered a lot of ground in this guide. While we have focused on
three common business cases, there are many more and we will add them to
this documentation as they come up.&lt;/p>
&lt;p>What is clear from this guide is that Onshape enables something that no
other cloud-based system provides â€“ the ability to access Onshapeâ€™s
resources, integrate and update Onshape through an open and secure REST
API. This is unique in the market today and is a result of Onshape being
developed from the first line of code for the cloud, for multi-tenant
and with the end user in mind. It is a true modern SaaS solution. It is
for this reason that we can integrate our third-party applications
commands and interfaces directly into the Onshape interface, as
explained in the last chapter of this guide.&lt;/p>
&lt;p>We have seen many tips and tricks in this guide that can help you
through the development process. Many integrators who have in the past
programed for traditional three-tier solutions, struggle with the
concepts of secure REST APIs, for this reason we spent a lot of time
explaining in detail what OAuth2 is and how to use it. Concepts such as
webhooks might be foreign to the traditional integrator, therefore we
spend a lot of time looking at the requirements for webhooks and why
they might not work, providing some best practices for their
implementation.&lt;/p>
&lt;p>At the start of this guide, we reviewed the Onshape difference, this is
a key chapter for understanding why an integration to Onshape will look
different from any traditional integration you might have done before.
Programing for a SaaS solution uses different practices than you might
have used prior to implementing an Onshape integration. The key point is
to never limit the designerâ€™s ability to innovate with the full toolset
that Onshape provides by placing integration constraints on that user.
This has been the purpose of this guide, to show you how to correctly
integrate with a true 21&lt;sup>st&lt;/sup> century SaaS product.&lt;/p>
&lt;h1 id="table-to-figures">Table to Figures&lt;/h1>
&lt;p>&lt;a href="#_Toc102977872">Figure 1 - Typical three-tier architecture
8&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977873">Figure 2 - Single Tenant Architecture
9&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977874">Figure 3 - Multi-Tenant Architecture
10&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977875">Figure 4 - REST API Architecture 12&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977876">Figure 5 - Onshapeâ€™s revision and part number schema definition
interface 17&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977877">Figure 6 - An example of a multi-part Part Studio in Onshape
20&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977878">Figure 7 - Onshape History and Versions
21&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977879">Figure 8 - A custom Release process in Onshape
23&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977880">Figure 9 - The Onshape Document
24&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977881">Figure 10 - OAuth2 Authorization Flow
30&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977882">Figure 11: Create new OAuth Application interface
33&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977883">Figure 12 - OAuth application definitions
36&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977884">Figure 13- passport serialize visual flow
40&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977885">Figure 14 - Onshape Authorize Application Interface
43&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977886">Figure 15 - Notifying the user of successful authentication
44&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977887">Figure 16 - Step 1 Initiating properties sync
56&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977888">Figure 17 Step 2, Create Object in 3rd Party System
57&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977889">Figure 18 - Step 3, Sync Metadata
58&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977890">Figure 19 - Step 4, Update 3rd Part Object
59&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977891">Figure 20 - Request Custom Part Number in Onshape
60&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977892">Figure 21 - Bi-directional Update of Properties
61&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977893">Figure 22 - Glassworks Authentication Options
63&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977894">Figure 23 Glassworks &amp;ldquo;Try It Out&amp;rdquo; feature
64&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977895">Figure 24 Accessing Chrome&amp;rsquo;s Developer Tools
65&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977896">Figure 25 Developer Tools Network Tab
66&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977897">Figure 26 Network Request Sample 66&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977898">Figure 27 HTTP POST Request for Saving Properties
67&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977899">Figure 28 HTTP POST Body 67&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977900">Figure 29 - Oauth Applications - Extensions
69&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977901">Figure 30 - Define Application Extension
70&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977902">Figure 31 - Define External OAuth 71&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977903">Figure 32 - Grant External Access 72&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977904">Figure 33 - Enabling Onshape to access a 3rd parties data
73&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977905">Figure 34 - Finding Your Enterprise ID
74&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977906">Figure 35 - Application Extension Definition for Part Numbers
81&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977907">Figure 36 - Revisions and Part Number Settings
82&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977908">Figure 37 - Selecting Custom Part Number Generator
83&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977909">Figure 38 - Release Candidate Part Number generation
86&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977910">Figure 39 - release visual cues
87&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977911">Figure 40 - Initiating a release candidate
89&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977912">Figure 41 - Pending Release 90&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977913">Figure 42 - Release and changes
90&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977914">Figure 43 - release candidate rejected
93&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977915">Figure 44 - Displaying Onshape Release data
98&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977916">Figure 45 - Release completed automatically in Onshape
101&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977917">Figure 46 - Release comments Updated from third-party system
102&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977918">Figure 47 - Integrating into the document right panel
114&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977919">Figure 48 - Oauth Application Extensions
115&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977920">Figure 49 - Defining Application Extension
116&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977921">Figure 50 - Application Extension with Part Selected
119&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977922">Figure 51 - Application extension with synced part
120&lt;/a>&lt;/p>
&lt;p>&lt;a href="#_Toc102977923">Figure 52 - Application extension with no selected Part
120&lt;/a>&lt;/p></description></item><item><title>Docs: Extensions</title><link>https://onshape-public.github.io/docs/extensions/</link><pubDate>Mon, 18 May 2020 20:39:14 -0400</pubDate><guid>https://onshape-public.github.io/docs/extensions/</guid><description>
&lt;h1 id="onshape-api-and-application-extensions">Onshape API and Application Extensions&lt;/h1>
&lt;p>We are enhancing the Onshape API to enable a more integrated user experience and new capabilities.&lt;/p>
&lt;p>The new capabilities called extensions allow the following:&lt;/p>
&lt;ol>
&lt;li>Embedding application UIs at multiple locations in the Onshape UI&lt;/li>
&lt;li>Enabling actions within the Onshape UI that can invoke application code via REST APIs or open custom URLs.&lt;/li>
&lt;li>Enabling background process integration into release workflows.&lt;/li>
&lt;li>An OAuth connection from Onshape to the application which enables seamlessly calling application code via REST APIs&lt;/li>
&lt;/ol>
&lt;h2 id="creating-extensions">Creating extensions&lt;/h2>
&lt;p>Once the application has been created, we can configure it in the Developer Portal. While viewing or editing the application, we earlier had 4 sections - Details, Settings, Keys, and Secrets and Permissions. We now have 2 new sections - &lt;strong>Extensions&lt;/strong> and &lt;strong>External OAuth&lt;/strong>.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage01.png" alt="image alt text">&lt;/p>
&lt;p>At a high level, we can classify extensions into 2 types. The first type of extensions embeds a UI from the application into the Onshape UI. The embedded UI is an HTTPS page that is shown in an iFrame in the Onshape UI. The UI is served from the application, and can choose to make API calls to Onshape for additional information. This is exactly like the traditional tab-based applications in Onshape, except that such extensions exist at different UI locations.&lt;/p>
&lt;p>The second type of extension embeds an action that calls a REST API exposed by the application from the Onshape UI. Examples of these are context menu actions and toolbar actions. These types of extensions rely on the External OAuth information to authenticate and make a call where Onshape acts as a client and the application acts as a server.&lt;/p>
&lt;p>Each extension exists at a specific place in the Onshape UI and works with a specific context or selection. The attributes of an extension are:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Name - This should be short and explicit. It will appear in the Onshape UI as a menu item, a toolbar tooltip, a collapsed panel icon tooltip, or a panel icon. It might be truncated in the UI if it is too long.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Description - This is where the developer can record a detailed description of the extension. It does not appear in the Onshape UI, but could appear in the grant process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Location - This describes where the extension exists in the Onshape UI. Over time, this will cover various panels in the UI, context menus, toolbars, actions in dialogs, etc. You can see the list of currently supported locations &lt;a href="#supported-locations-and-contexts">here&lt;/a>.
Please note that you can create only one element tab extension per application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Context(selection) - Some locations will work in the context of a selection. Letâ€™s say the application developer wants to show some information from a third-party system, pertinent only to parts (not assemblies or drawings). In this scenario, the developer would choose a location like â€˜Document list info panelâ€™, and the context as â€˜Selected partâ€™. If the user searches for something in the document list, some documents, Part Studios, parts, and Assemblies would be returned. This extension will show up in the Info panel only if the selected entity is a part. Using context enables application developers to control when the extension is displayed. Check the list of contexts available for different locations &lt;a href="#supported-locations-and-contexts">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Action URL - Locations that embed a UI use the action URL to define the address of the page to display. The action URL is used to specify the REST endpoint if the location is an action (context menu, toolbar item, action in dialog etc.) and the action type is GET or POST. If the location is an action and the action is â€˜Open in new windowâ€™, the action URL is the URL to open in the new window.&lt;br>
The action URL can be parameterized to pass information from Onshape to the application. The action URL replaces attributes in the format {$attribute} with the appropriate value. These attributes can be used to identify the selected entity and/or make calls back to Onshape via the API. The currently supported attributes are:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current or selected document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current or selected element (part studio, assembly, drawing).&lt;/li>
&lt;li>{$partId} - The Onshape ID for the current or selected part.&lt;/li>
&lt;li>{$partNumber} - The Part number property for the current or selected part, assembly or drawing.&lt;/li>
&lt;li>{$revision} - The Revision property for the current or selected part, assembly or drawing.&lt;/li>
&lt;li>{$mimeType} - The mime type if the current or selected element is a blob.&lt;/li>
&lt;li>{$featureId} - In case of feature selected in the Feature list in a Part Studio.&lt;/li>
&lt;li>{$nodeId} - In case of mate or mate feature selected in the Assembly list.&lt;/li>
&lt;li>{$occurrencePath} - In case of part instances, mates, mate connectors and sub assemblies.&lt;/li>
&lt;li>{$configuration} - In case of extensions inside the document, this attribute will be replaced by current element active configuration.&lt;/li>
&lt;/ul>
&lt;p>The attributes can exist as path parameters or query parameters or attributes in the POST body. For example: &lt;a href="https://whispering-sea-42267.herokuapp.com/oauthSignin?documentId=%7B$documentId%7D&amp;amp;workspaceId=%7B$workspaceId%7D&amp;amp;elementId=%7B$elementId%7D&amp;amp;partId=%7B$partId">https://whispering-sea-42267.herokuapp.com/oauthSignin?documentId={$documentId}&amp;amp;workspaceOrVersion={workspaceOrVersion}&amp;amp;workspaceOrVersionId={$workspaceOrVersionId}&amp;amp;elementId={$elementId}&amp;amp;partId={$partId}&amp;amp;server=https://cad.onshape.com&amp;amp;companyId=cad&amp;amp;userId=5f1eba76c14a434817d9c588&amp;amp;locale=en-US&lt;/a> OR &lt;a href="https://cad.onshape.com/api/partstudios/d/%7B$documentId%7D/w/%7B$workspaceId%7D/e/%7B$elementId%7D/stl">https://cad.onshape.com/api/partstudios/d/{$documentId}/{$workspaceOrVersion}/{$workspaceOrVersionId}/e/{$elementId}/stl?server=https://cad.onshape.com&amp;amp;companyId=cad&amp;amp;userId=5f1eba76c14a434817d9c588&amp;amp;locale=en-US&lt;/a>&lt;/p>
&lt;p>The attributes available for replacement differ by location and context selection. You can see the available attributes for each location &lt;a href="#supported-locations-and-contexts">here&lt;/a>.&lt;/p>
&lt;p>The &lt;strong>timeout&lt;/strong> for action_url of type GET or POST is &lt;strong>180 seconds&lt;/strong>.&lt;/p>
&lt;ol start="6">
&lt;li>Action type: The action type is only applicable for locations that act as actions and not for locations that embed UIs. Check if action type is valid for a location &lt;a href="#supported-locations-and-contexts">here&lt;/a>. The supported action types are:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>GET - This makes a GET API call using the action URL. Parameter replacement is done on the action URL.&lt;/li>
&lt;li>POST - This makes a POST API call using the action URL and the action body as the post body. Parameter replacement is done on both the action URL and the action body.&lt;/li>
&lt;li>Open in new window - This opens the action URL in a new browser window. Parameter replacement is done on the action URL.&lt;/li>
&lt;/ul>
&lt;ol start="7">
&lt;li>
&lt;p>Action body: This is only applicable if the action type is POST. The action body is passed in a POST API call and must be in a valid json format.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Show response: This is only applicable if the action type is GET or POST. If this is checked, the UI will wait for a response and show the response in a dialog in the UI. The response must be in a valid json format.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Icon: The icon will be shown where the extension exists. This can be an icon in an Info panel, context menu action, toolbar button, action button in a dialog, or other supported locations.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage02.png" alt="image alt text">&lt;/p>
&lt;h2 id="3rd-party-oauth">3rd-party OAuth&lt;/h2>
&lt;p>This section lists the details required by Onshape to connect to the application. Refer to the sample application for details about building OAuth server functionality into your application.&lt;/p>
&lt;p>Please note that this section is compulsory for now. You have to build an OAuth server application at this time. In the future we may make this optional, or even support other authentication models.&lt;/p>
&lt;p>The attributes are:&lt;/p>
&lt;ol>
&lt;li>Client ID - The Client ID is considered public. It is how your specific application is uniquely identified in OAuth protocol exchanges.&lt;/li>
&lt;li>Client Secret - The client secret is like a password and is saved securely in Onshape storage. It is used to establish a valid OAuth connection to your application.&lt;/li>
&lt;li>Authorization URL - This is the URL where we initiate the OAuth process from Onshape to your application.&lt;/li>
&lt;li>Access Token URL - This is the URL used to access the token for making API calls to your application.&lt;/li>
&lt;li>Scopes - These are the scopes which your application wants to grant. This can be empty.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage03.png" alt="image alt text">&lt;/p>
&lt;h2 id="supported-locations-and-contexts">Supported locations and contexts&lt;/h2>
&lt;p>This is the list of supported locations, their valid contexts, and whether they support action types.&lt;/p>
&lt;h3 id="location-element-context-menu">Location: Element context menu&lt;/h3>
&lt;p>This is the context menu for elements.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage04.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>Part Studio&lt;/li>
&lt;li>Assembly&lt;/li>
&lt;li>Drawing&lt;/li>
&lt;li>Blob element - These are file elements like pdf, stl, Parasolid file, etc.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacements:&lt;/p>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current or selected document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current or selected element (Part Studio, Assembly, Drawing, blob).&lt;/li>
&lt;li>{$partNumber} - The Part number property for the current or selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$mimeType} - The mime type of the currently selected blob element.&lt;/li>
&lt;li>{$configuration} - The active configuration of the current element.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>server - The address of the current Onshape server&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location supports action types.&lt;/p>
&lt;h3 id="location-tree-context-menu">Location: Tree context menu&lt;/h3>
&lt;p>This is the context menu for the part tree, assembly tree and feature tree in part studios.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage05.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>Part - Part in a Part Studioâ€™s Part list&lt;/li>
&lt;li>Sub assembly - Sub assembly in an Assembly list&lt;/li>
&lt;li>Feature - Feature in a Part Studioâ€™s feature list&lt;/li>
&lt;li>Mate - Mate in an Assembly list&lt;/li>
&lt;li>Mate feature - Mate in an Assembly list&lt;/li>
&lt;li>Instance - Part instance in an Assembly list&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current or selected document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current or selected element (Part Studio, Assembly, Drawing).&lt;/li>
&lt;li>{$partNumber} - The Part number property for the current or selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$revision} - The Revision property for the current or selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$featureId} - In case of feature selected in the Feature list in a Part Studio&lt;/li>
&lt;li>{$nodeId} - In case of mate or mate feature selected in the Assembly list&lt;/li>
&lt;li>{$occurrencePath} - In case of part instances, mates, mate connectors and sub assemblies.&lt;/li>
&lt;li>{$configuration} - The active configuration of the current element.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>server - The address of the current Onshape server&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location supports action types.&lt;/p>
&lt;h3 id="location-document-list-context-menu">Location: Document list context menu&lt;/h3>
&lt;p>This the context menu available on items in the document list. This is normally documents but can be multiple types based on search results.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage06.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>Part&lt;/li>
&lt;li>Document&lt;/li>
&lt;li>Part Studio&lt;/li>
&lt;li>Assembly&lt;/li>
&lt;li>Drawing&lt;/li>
&lt;li>Blob element - These are file elements like pdf, stl, Parasolid file, etc.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current or selected document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current or selected element (Part Studio, Assembly, Drawing).&lt;/li>
&lt;li>{$partNumber} - The Part number property for the current or selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$revision} - The Revision property for the current or selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$configuration} - The active configuration of the current or selected part, Assembly if applicable.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>server - The address of the current Onshape server&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location supports action types.&lt;/p>
&lt;h3 id="location-document-list-info-panel">Location: Document list info panel&lt;/h3>
&lt;p>This is the Info panel to the right in the document list. The document list normally contains documents, but can contain other entities as the result of a search.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage07.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>Part&lt;/li>
&lt;li>Document&lt;/li>
&lt;li>Part Studio&lt;/li>
&lt;li>Assembly&lt;/li>
&lt;li>Drawing&lt;/li>
&lt;li>Blob element - These are file elements like pdf, stl, Parasolid file, etc.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current or selected document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current or selected element (Part Studio, Assembly, Drawing).&lt;/li>
&lt;li>{$partId} - The Onshape ID for the current or selected part.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>server - The address of the current Onshape server&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location does NOT support action types.&lt;/p>
&lt;h3 id="location-element-right-panel">Location: Element right panel&lt;/h3>
&lt;p>This is the panel inside a document. It currently houses the BOM, configurations, etc. Applications can use this extension location to add items in this panel.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage08.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>Part - Part selected in the part tree in the Part Studio.&lt;/li>
&lt;li>Document - Shown in the document irrespective of any selections.&lt;/li>
&lt;li>Part studio - Shown in the Part Studio irrespective of other selections.&lt;/li>
&lt;li>Assembly - Shown in the Assembly element irrespective of other selections.&lt;/li>
&lt;li>Sub assembly - Sub assembly selected in the Assembly list.&lt;/li>
&lt;li>Feature - Feature selected in the feature list in the Part Studio.&lt;/li>
&lt;li>Mate - Mate selected in the Assembly list.&lt;/li>
&lt;li>Mate feature - Mate feature selected in the Assembly list.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>{$documentId} - The Onshape ID for the current document.&lt;/li>
&lt;li>{$workspaceOrVersion} - This will be either â€˜wâ€™ or â€˜vâ€™ for workspace or version respectively depending on current opened document state or selection.&lt;/li>
&lt;li>{$workspaceOrVersionId} - The Onshape ID for the current or selected workspace or version.&lt;/li>
&lt;li>&lt;em>{$workspaceId}&lt;/em> - The Onshape ID for the current or selected workspace. This is being deprecated.&lt;/li>
&lt;li>&lt;em>{$versionId}&lt;/em> - The Onshape ID for the current or selected version. This is being deprecated.&lt;/li>
&lt;li>{$elementId} - The Onshape ID for the current element (Part Studio, Assembly, Drawing).&lt;/li>
&lt;li>{$partNumber} - The Part number property for the selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$revision} - The Revision property for the selected part, Assembly or Drawing.&lt;/li>
&lt;li>{$featureId} - In case of feature selected in the Feature list in a Part Studio.&lt;/li>
&lt;li>{$nodeId} - In case of mate or mate feature selected in the Assembly list.&lt;/li>
&lt;li>{$occurrencePath} - In case of part instances, mates, mate connectors and sub assemblies.&lt;/li>
&lt;li>{$configuration} - The active configuration of the current element.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>server - The address of the current Onshape server.&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location does NOT support action types.&lt;/p>
&lt;h3 id="location-new-element-tab">Location: New Element tab&lt;/h3>
&lt;p>This is the menu option for &lt;code>+ menu -&amp;gt; Add application&lt;/code> inside a document . After menu click, a new tab will be created with the action url associated with this extension.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage09.png" alt="image alt text">&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>There are no supported contexts.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>Parameter replacement not supported.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>documentId - Current document ID&lt;/li>
&lt;li>workspaceId - Current workspace ID&lt;/li>
&lt;li>versionId - Current version ID&lt;/li>
&lt;li>elementId - Current (application) element ID&lt;/li>
&lt;li>server - The address of the current Onshape server&lt;/li>
&lt;li>companyId - Default value is â€˜cadâ€™. If the document owner is company/enterprise, then the value is company/enterprise ID.&lt;/li>
&lt;li>userId - Current user ID&lt;/li>
&lt;li>locale - Locale of current user (ex. en-US)&lt;/li>
&lt;li>clientId - The OAuth client ID for the application&lt;/li>
&lt;/ul>
&lt;p>This location supports action types.&lt;/p>
&lt;h3 id="location-part-number-generator">Location: Part number generator&lt;/h3>
&lt;p>This extension helps partners to embed their own custom part number generation scheme in Onshape. Each application can have only one extension of this type. Once defined, these extensions are listed as one of the part numbering schemes in the release management configuration in Company settings.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage10.png" alt="image alt text">&lt;/p>
&lt;p>In the above screen shot, â€˜Part number generation schemeâ€™ is the user-defined name of the extension.&lt;/p>
&lt;p>Supported contexts:&lt;/p>
&lt;ul>
&lt;li>There are no supported contexts.&lt;/li>
&lt;/ul>
&lt;p>Supported parameters for replacement:&lt;/p>
&lt;ul>
&lt;li>Parameter replacement is not supported.&lt;/li>
&lt;/ul>
&lt;p>Default parameters as query string:&lt;/p>
&lt;ul>
&lt;li>No default query parameters&lt;/li>
&lt;/ul>
&lt;p>Action URL defined by the user is assumed to be a POST API. This API should consume a predefined request body as shown below. This definition may have additional attributes in future.&lt;/p>
&lt;pre tabindex="0">&lt;code> [
{
&amp;#34;id&amp;#34; : &amp;lt;internal part number id&amp;gt;,
&amp;#34;documentId&amp;#34; : &amp;lt;documentId&amp;gt;,
&amp;#34;elementId&amp;#34; : &amp;lt;elementId&amp;gt;,
&amp;#34;workspaceId&amp;#34; : &amp;lt;workspaceId&amp;gt;,
&amp;#34;elementType&amp;#34; : &amp;lt;elementType&amp;gt;,
&amp;#34;partId&amp;#34; : &amp;lt;partId&amp;gt;,
&amp;#34;companyId&amp;#34; : &amp;lt;companyId&amp;gt;, // Id of the company that owns the document, else the text â€œcadâ€
&amp;#34;partNumber&amp;#34; : &amp;lt;current part number&amp;gt;,
&amp;#34;configuration&amp;#34; : &amp;lt;configuration string&amp;gt;,
&amp;#34;categories&amp;#34; : &amp;lt;array of category ids and names&amp;gt; // [ { &amp;#34;id&amp;#34;: &amp;lt;String&amp;gt;, &amp;#34;name&amp;#34;: &amp;lt;string&amp;gt; } ]
}
]
&lt;/code>&lt;/pre>&lt;p>Note - Categories are only passed from the Release dialog and properties dialogs for now. They are empty when part number generation is called from the BOM table or configuration table.&lt;/p>
&lt;p>Expected response sent to Onshape is as follows:&lt;/p>
&lt;pre tabindex="0">&lt;code> [
{
&amp;#34;id&amp;#34; : &amp;lt;internal part number id&amp;gt;,
&amp;#34;documentId&amp;#34; : &amp;lt;documentId&amp;gt;,
&amp;#34;elementId&amp;#34; : &amp;lt;elementId&amp;gt;,
&amp;#34;workspaceId&amp;#34; : &amp;lt;workspaceId&amp;gt;,
&amp;#34;elementType&amp;#34; : &amp;lt;elementType&amp;gt;,
&amp;#34;partId&amp;#34; : &amp;lt;partId&amp;gt;,
&amp;#34;partNumber&amp;#34; : &amp;lt;next part number generated by third party numbering scheme&amp;gt;
}
]
&lt;/code>&lt;/pre>&lt;p>Third-party applications can simply fill up the &lt;code>&amp;quot;partNumber&amp;quot;&lt;/code> attribute with part number generated by the custom numbering scheme and send it as a response. However, the response should at least contain &lt;code>&amp;quot;id&amp;quot;&lt;/code> and &lt;code>&amp;quot;partNumber&amp;quot;&lt;/code> as highlighted above, other attributes are optional.&lt;/p>
&lt;p>Custom numbering schemes for part generation, once set in the Release management page, can be invoked from all the places where we set part numbers, including the Release candidate dialog shown below.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage11.png" alt="image alt text">&lt;/p>
&lt;h2 id="sample-application">Sample application&lt;/h2>
&lt;p>We have provided a sample application which supports the features described in this document.&lt;/p>
&lt;p>The source code for this â€˜Inventory managementâ€™ application can be found &lt;a href="https://github.com/onshape-public/inventory-oauth2-app">here&lt;/a>.&lt;/p>
&lt;p>The instructions to install and try out the application are available in the README.md file in the repository.&lt;/p>
&lt;p>The application is built on the Passport node module. It is based on this &lt;a href="http://scottksmith.com/blog/2014/05/02/building-restful-apis-with-node/">article&lt;/a>. Please read the article before proceeding with this section.&lt;/p>
&lt;p>Some structural information about the application:&lt;/p>
&lt;ul>
&lt;li>The dependencies are defined in package.json&lt;/li>
&lt;li>The routing for inbound calls is defined in server.js. This includes routing for OAuth2 calls as well as calls for the rest APIs we expose that Onshape can call via the extensions.&lt;/li>
&lt;li>The OAuth2 calls are routed to controllers/oauth2.js. These include calls to authenticate as calls to get the bearer token.&lt;/li>
&lt;li>controllers/oauth2.js uses controllers/auth.js to interact with Passport to manage the authentication and storage.&lt;/li>
&lt;li>Other API calls to get part number, etc, route to the appropriate controller in the controllers directory.&lt;/li>
&lt;li>The controllers use the model defined in the model directory.&lt;/li>
&lt;/ul>
&lt;p>The application is defined in the Developer Portal with extensions that use the exposed APIs.&lt;/p>
&lt;p>The following screenshots define the base configuration of the application and some of the sample extensions.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage12.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage13.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage14.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage15.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage16.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage17.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage18.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage19.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage20.png" alt="image alt text">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage21.png" alt="image alt text">&lt;/p>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;em>Q. What is the user experience of granting and revoking OAuth access?&lt;/em>&lt;/p>
&lt;p>Once users have purchased the application from the App Store, they will start seeing actions and panel icons as described by the extensions. When they try to use these actions and panels, they will be prompted by an error message stating that they need to grant access first.&lt;/p>
&lt;p>They can grant access by navigating to the â€˜Applicationsâ€™ section under â€˜My Accountâ€™.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/extensionsimage22.png" alt="image alt text">&lt;/p>
&lt;p>Users will have to grant 2 permissions. The first button called â€˜Onshape accessâ€™ will enable the application to make calls to the Onshape API. This will require the userâ€™s Onshape credentials.&lt;/p>
&lt;p>The second button calls â€˜External accessâ€™ and enables Onshape to make calls to the application API. This will require the userâ€™s credentials in the application. Both modes of access use OAuth, so credentials are not stored in the other system.&lt;/p>
&lt;p>If the access is revoked at any time, the actions and panels will ask the user to re-authenticate from the â€˜Applicationsâ€™ page. Access may be revoked manually from Onshape or the application, or because a new version is installed that requires a different scope.&lt;/p>
&lt;p>&lt;em>Q. Who can get access to my app, and how?&lt;/em>&lt;/p>
&lt;p>Applications with extensions are only available to people who have been explicitly granted this permission in Onshape. Users who have been given this permission will be able to go to the App Store and purchase the application. There is no change to this process from earlier. They will then be able to grant access to the application as described in the previous question.&lt;/p>
&lt;p>Do not publish your application if it contains extensions in the App Store for all users. Other users (who have not been granted permission) will not be able to see the extensions and will have a bad experience.&lt;/p>
&lt;p>&lt;em>Q. How is my application informed about selection changes in the Onshape UI?&lt;/em>&lt;/p>
&lt;p>Letâ€™s take the case where your application has an extension that is showing some information in the document info panel that is based on document selection. As the selection changes, the action URL passed to the extension will change (based on parameterization). The new action URL will be loaded into the IFrame for the extension, and the application page will reload. We are adding support for post messages to reduce loading overhead in the future.&lt;/p>
&lt;p>&lt;em>Q. What is the timeout for the action_url of extensions? Is it configurable?&lt;/em>&lt;/p>
&lt;p>Timeout set for each GET or POST request set as action_url of an extension is 180 seconds. Timeout is not configurable.&lt;/p>
&lt;p>&lt;em>Q. What changed when my legacy application migrated to extensions&lt;/em>&lt;/p>
&lt;p>If you had created a desktop or connected ckoud app, nothing has changed.&lt;br>
If you had created an integrated cloud app, the following changes have been made to the app.&lt;/p>
&lt;ul>
&lt;li>The IFrame URL has been changed to the OAuth URL. This is now invoked from the user&amp;rsquo;s application setting page to grant OAuth access. A redirect URL is passed along with the call as a query parameter named &amp;lsquo;redirectOnshapeUri&amp;rsquo;. You will need to modify your code to redirect to this URL if it is present.&lt;/li>
&lt;li>A new tab extension is automatically created for your applications. The target URL for this extension is the earlier IFrame URL. This should continue to work as earlier.&lt;/li>
&lt;li>The tab icon will also be populated into the extension from the earlier application icon and should work as earlier.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Structured Storage</title><link>https://onshape-public.github.io/docs/structuredstorage/</link><pubDate>Mon, 18 May 2020 20:40:16 -0400</pubDate><guid>https://onshape-public.github.io/docs/structuredstorage/</guid><description>
&lt;h2 id="sub-elements">Sub Elements&lt;/h2>
&lt;p>Onshape provides application elements storage that is controlled by applications through the API. These elements allow a set of named sub-elements.&lt;/p>
&lt;p>The application can make changes to sub-elements independently or in arbitrary groupings. Changes may be wholesale replacements, or may be deltas. When performing a delta update, the application may post a full version as well, which allows the api to return a smaller number of deltas for subsequent queries.&lt;/p>
&lt;p>An application may need to perform multiple versionable actions in the course of performing a user-level action, and we want to allow the individual actions to be collected into a single action from the perspective of document history. We do this by providing support for creation of a private transaction and support for atomically committing the transaction to the document workspace as a single user-visible action.&lt;/p>
&lt;p>Onshape does not assume any knowledge about the semantics of application deltas. All merging of deltas into a consolidated form is done by the application. Applications should typically send checkpoint state for a sub-element if many delta changes have been made since the last checkpoint.&lt;/p>
&lt;p>Document content and changes are logically an array of bytes, but since they are transmitted through JSON, then are expected to be presented a Base-64 encoding of the array into string form.&lt;/p>
&lt;p>We use some terminology in this document that is new.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>changeId&lt;/strong> - an opaque identifier for the state of an application element. Each change to the application element results in a new changeId&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>transaction&lt;/strong> - a private workspace within a document workspace for composing modifications to an application element. These changes are not visible to the user until committed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>transaction commit&lt;/strong> - an operation that moves the changes performed within a transaction to the application element workspace as a single user-visible action.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Concurrent access by multiple users&lt;/strong>&lt;/p>
&lt;p>If the element is being concurrently accessed by multiple sessions, updates may encounter conflicts during update. If the application has a mechanism that ensures that all accesses to the element are mediated by a single process, as is done with our part studio and assemblies, this can be addressed directly by the application. However, if the application is not able to mediate access in this way, updates by one session may invalidate state held by another session. We address this by notifying updaters when an update cannot be directly applied because their state is out of date and allowing them to refresh their state before re-applying the change.&lt;/p>
&lt;p>This policy of requiring the application have current state when posting updates could be overly conservative in some cases. Detecting conflict at the sub-element level might provide for better concurrent access performance, but there probably are cases where this fails, so it probably would need some level of application control.&lt;/p>
&lt;h2 id="json-tree">JSON Tree&lt;/h2>
&lt;p>In contrast with sub elements, JSON tree storage is a more managed data storage mechanism that Onshape itself can merge and diff. At the root of it, the data structure is a single JSON object per Application Element. The user submits incremental changes that are then applied by Onshape to the JSON tree. Onshape stores these &amp;lsquo;diffs&amp;rsquo; in a new microversion created as a result of the update request, or during a subsequent transaction commit request. When the user then performs a merge or restore operation, Onshape can sum and apply the requisite incremental changes. By storing diffs, Onshape provides to the user a storage mechanism that is more robust to race conditions, since multiple simultaneous edits can be optionally merged by Onshape. All of these qualities make JSON tree a preferred way to store application element data in an Onshape-native manner.&lt;/p>
&lt;h3 id="json-tree-edit-semantics">JSON Tree Edit Semantics&lt;/h3>
&lt;h5 id="btjedit-encoding">BTJEdit Encoding&lt;/h5>
&lt;p>A JSON tree edit represents an incremental change to an application element&amp;rsquo;s JSON tree. The edit is a &lt;code>BTJEdit&lt;/code> class, which is encoded as one of the following:&lt;/p>
&lt;ul>
&lt;li>Deletion:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJEditDelete-1992&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;path&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Insertion:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJEditInsert-2523&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;path&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;newValue&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Change:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJEditChange-2636&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;path&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;newValue&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Move:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJEditMove-3245&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;sourcePath&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;path&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;destinationPath&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;path&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>List (where edit1, edit2, etc. are zero or more edits.):&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJEditList-2707&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;edits&amp;#34;&lt;/span> : [ &lt;span style="color:#a50">&amp;#34;edit1&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;edit2&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;...&amp;#34;&lt;/span>] }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Within the above encoding, &lt;code>newValue&lt;/code> is a stand in for any valid JSON, and &lt;code>path&lt;/code> is a stand in for an object representing a path to the node at which to perform the edit.&lt;/p>
&lt;h5 id="btjpath-encoding">BTJPath Encoding&lt;/h5>
&lt;p>The BTJPath object describes a path through the JSON tree to a particular node, and is encoded as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;startNode&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span> : [ &lt;span style="color:#a50">&amp;#34;pathElement1&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;pathElement2&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;...&amp;#34;&lt;/span>] }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>where startNode is a string that is either empty to specify the root node or a nodeId of a node in the tree. The pathElement is one of:&lt;/p>
&lt;ul>
&lt;li>Key:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;string&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Index:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;BTJPathIndex-1871&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;index&amp;#34;&lt;/span> : &lt;span style="color:#a50">&amp;#34;integer&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the insertion and move type edits the path elements can describe a path that doesn&amp;rsquo;t currently exist. Onshape will generate the proper keys and values as needed to place the node value in the proper location.&lt;/p>
&lt;h3 id="json-tree-examples">JSON Tree Examples&lt;/h3>
&lt;p>Below are some examples that show the body required to perform the particular edit on a JSON tree.&lt;/p>
&lt;h4 id="deletion-example">Deletion Example&lt;/h4>
&lt;p>If the pre-existing JSON tree looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and a delete edit looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditDelete-1992&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>}]}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>then the resulting JSON is the result of deleting the node specified by &lt;code>path&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="insert-example">Insert Example&lt;/h4>
&lt;p>If the pre-existing JSON tree looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and the insertion edit looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditInsert-2523&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;insertedKey&amp;#34;&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>then the resulting JSON is the result of inserting the node described by &lt;code>value&lt;/code> at the node specified by &lt;code>path&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;insertedKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="change-example">Change Example&lt;/h4>
&lt;p>If the pre-existing JSON tree looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and the change edit looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditChange-2636&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myOtherValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>then the resulting JSON is the result of changing the node specified by &lt;code>path&lt;/code> to the node described by &lt;code>value&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myOtherValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="move-example">Move Example&lt;/h4>
&lt;p>If the pre-existing JSON tree looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myOtherKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myOtherValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and the move edit looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditMove-3245&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;sourcePath&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;destinationPath&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;keyCreatedFromMove&amp;#34;&lt;/span>}]}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>then the resulting JSON is the result of moving the node from the specified &lt;code>sourcePath&lt;/code> to the &lt;code>destinationPath&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;keyCreatedFromMove&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="list-example">List Example&lt;/h4>
&lt;p>If the pre-existing JSON tree looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and the list edit looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditList-2707&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;edits&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditInsert-2523&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditChange-2636&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span>: [&lt;span style="color:#a50">&amp;#34;firstValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;secondValue&amp;#34;&lt;/span>]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditInsert-2523&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathIndex-1871&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;index&amp;#34;&lt;/span>: &lt;span style="color:#099">1&lt;/span>}]},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myBetterSecondValue&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJEditDelete-1992&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPath-3073&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;startNode&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;path&amp;#34;&lt;/span>: [{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathKey-3221&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;key&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myKey&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;btType&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;BTJPathIndex-1871&amp;#34;&lt;/span>, &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;index&amp;#34;&lt;/span>: &lt;span style="color:#099">2&lt;/span>}]}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>then the resulting JSON is the result of applying all the given edits in order:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: [&lt;span style="color:#a50">&amp;#34;firstValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;myBetterSecondValue&amp;#34;&lt;/span>]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The intermediate steps were:&lt;/p>
&lt;ol>
&lt;li>Insertion:
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;myValue&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Change:
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: [&lt;span style="color:#a50">&amp;#34;firstValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;secondValue&amp;#34;&lt;/span>]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>List insertion:
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: [&lt;span style="color:#a50">&amp;#34;firstValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;myBetterSecondValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;secondValue&amp;#34;&lt;/span>]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>List deletion:
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;myKey&amp;#34;&lt;/span>: [&lt;span style="color:#a50">&amp;#34;firstValue&amp;#34;&lt;/span>, &lt;span style="color:#a50">&amp;#34;myBetterSecondValue&amp;#34;&lt;/span>]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>All the examples above were tested and validated using the Python client &lt;a href="https://github.com/onshape-public/onshape-clients/blob/next/python/test/test_app_element_json_tree.py">here&lt;/a>.&lt;/p></description></item><item><title>Docs: Tessellation Performance</title><link>https://onshape-public.github.io/docs/tessellationperformance/</link><pubDate>Mon, 18 May 2020 20:42:24 -0400</pubDate><guid>https://onshape-public.github.io/docs/tessellationperformance/</guid><description>
&lt;hr>
&lt;p>This note provides guidance in getting good performance from the Onshape tessellation API.&lt;/p>
&lt;p>We experimented with the &amp;ldquo;render fan&amp;rdquo; model, with the following results.&lt;/p>
&lt;p>For this model, all of the parts are referenced in a single part studio. This provides a very large opportunity for performance improvements.&lt;/p>
&lt;p>Our tests indicate that we are limited to about 25 REST calls per second. However, you can dramatically reduce the number of calls if you use the &amp;ldquo;partstudios&amp;rdquo; interface instead of the &amp;ldquo;parts&amp;rdquo; interface.&lt;/p>
&lt;p>Make a single call to retrieve the metadata for the part studio, returning an array that has color information and other metadata for each part:&lt;/p>
&lt;pre>&lt;code>/api/partstudios/.../metadata
&lt;/code>&lt;/pre>
&lt;p>Make a single call to retrieve the tessellation data for the part studio, returning an array with mesh data for each part:&lt;/p>
&lt;pre>&lt;code>/api/partstudios/.../tessellatedfaces
&lt;/code>&lt;/pre>
&lt;p>We used explicit tolerance settings based on the defaults used by Onshape - you can increase/decrease to balance mesh size and performance.&lt;/p>
&lt;pre>&lt;code># define render constants based on Onshape defaults
# double ANGULAR_TOLERANCE_FINE = 0.087267; // about 5 degree, a circle will have 72 segments
# double ANGULAR_TOLERANCE_MEDIUM = 0.2618; // about 15 degree, a circle will have 24 segments
# double ANGULAR_TOLERANCE_COARSE = 0.5236; // about 30 degree, a circle will have 12 segments
&lt;/code>&lt;/pre>
&lt;p>For simplicity, we used constant values for the chord tolerance. Onshape calculates these based on the size of the model as follows:&lt;/p>
&lt;pre>&lt;code># double CHORD_TOLERANCE_RATIO_FINE = 0.0025; // 0.25% of model size radius
# double CHORD_TOLERANCE_RATIO_MEDIUM = 0.01; // 1% of model size radius
# double CHORD_TOLERANCE_RATIO_COARSE = 0.05; // 5% is the max
&lt;/code>&lt;/pre>
&lt;p>For these experiments, we assumed the model had a radius of 1 meter, so the tolerances were set to the values described above.&lt;/p>
&lt;p>To get reproducible results, we pre-loaded the model. This took about 7 seconds; if the model is not already loaded, the first call to retrieve data would incur this cost:&lt;/p>
&lt;p>WARMUP THE SYSTEM&lt;/p>
&lt;p>Read mesh data for a single part to ensure the model is loaded onto a server in Onshape&lt;/p>
&lt;p>Time 7.8 seconds&lt;/p>
&lt;p>SINGLE CALL CASES:&lt;/p>
&lt;p>(Making a single call to retrieve the tessellation for an entire part studio)&lt;/p>
&lt;p>Getting full studio COARSE mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 240222&lt;/p>
&lt;p>Time 11.2&lt;/p>
&lt;p>Getting full studio MEDIUM mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 530234&lt;/p>
&lt;p>Time 14.9&lt;/p>
&lt;p>Getting full studio FINE mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 2214309&lt;/p>
&lt;p>Time 65.6&lt;/p>
&lt;p>MULTIPLE CALL CASES:&lt;/p>
&lt;p>(Make a separate call for each part in the part studio)&lt;/p>
&lt;p>Getting individual COARSE mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 240222&lt;/p>
&lt;p>Time 356.6&lt;/p>
&lt;p>Getting individual MEDIUM mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 530234&lt;/p>
&lt;p>Time 340.7&lt;/p>
&lt;p>Getting individual FINE mesh&amp;hellip;&lt;/p>
&lt;p>Triangle count 2214309&lt;/p>
&lt;p>Time 359.7&lt;/p>
&lt;p>Some things to note:&lt;/p>
&lt;ol>
&lt;li>The time is dominated by the total number of calls in the multiple call cases, as the REST overhead is significant&lt;/li>
&lt;li>These timings are reproducible within about 10% in my tests&lt;/li>
&lt;li>We used the indexTable option to reduce the total data size.&lt;/li>
&lt;li>We used the header: Accept-Encoding: gzip to ensure that the data was compressed in transit.&lt;/li>
&lt;li>When making multiple calls, we were able to get about 10-15% improvement when I allowed up to 10 concurrent calls at at time&lt;/li>
&lt;li>If the model is an assembly, it is worthwhile to collect all parts from a partstudio in a single call for each partstudio used in the assembly&lt;/li>
&lt;li>Note that the FINE mesh has about 2.2M triangles total, COARSE and MEDIUM returned smaller data sets.&lt;/li>
&lt;li>Performance will of course vary depending on the speed of your internet connection. =&lt;/li>
&lt;li>The tests were written in Python 3.&lt;/li>
&lt;/ol>
&lt;p>If you follow these guidelines, you should be able to get very acceptable performance.&lt;/p>
&lt;p>The worst case would be an assembly that pulled in a single part from each of hundreds of different part studios, but this is not typical of Onshape usage. We would need to enhance our API to better support that case.&lt;/p></description></item><item><title>Docs: Testing Guidelines</title><link>https://onshape-public.github.io/docs/testingguidelines/</link><pubDate>Mon, 18 May 2020 20:42:57 -0400</pubDate><guid>https://onshape-public.github.io/docs/testingguidelines/</guid><description>
&lt;p>The purpose of this document is to help you get your application and App Store entry ready for QA testing.&lt;/p>
&lt;p>Application Release Workflow (ARW)&lt;/p>
&lt;p>Each application submitted to the Onshape App Store goes through a series of stage-gates.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Ok to deploy to Production (Beta testing) (limited visibility)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ok to make Public&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Application is Public&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The starting state is â€˜Ok to deploy to limited visibility on Productionâ€™â€™. The end goal is â€˜Application is Public on Productionâ€™. To advance to the next stage, your application must pass testing and your app store entry must pass review.&lt;/p>
&lt;p>Testing may be requested at any time.&lt;/p>
&lt;p>Testing is done on a first-come basis.&lt;/p>
&lt;p>When testing is complete (pass or fail), you go to the back of the queue.&lt;/p>
&lt;p>Testing protocol&lt;/p>
&lt;p>Testing of Partner Applications will be performed against the checklist in addendum A.&lt;/p>
&lt;p>Testing of Production App Store entries will be performed against the checklist in addendum B.&lt;/p>
&lt;p>The result of each test will be one of;&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Pass - no action needed and no notification will be issued&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An enhancement - these are suggestions that should you chose to implement them, we believe would make the application better.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A bug (low priority) - these are slight deviations from the criteria but have low end user impact and will not prevent the application being turned on for public access and there is no stipulated time-frame for their resolution&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A bug (medium priority) - these are material deviations from the criteria that are noticeable to the end-user and represent a minor problem requiring a work-around. A medium priority bug will not prevent the application from being turned on for public access, but should be fixed within 30 days.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A bug (high priority) - this is a significant deviation from the criteria and will prevent the application from being turned on for public access but will not prevent the application from being promoted from the partner stack.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A bug (MUST FIX) - this category usually represents a significant deviation from protocol or security violation. A MUST FIX will prevent an application on Production being turned on for public access and MAY, if the application is already public, cause it to be temporarily suspended from the app store.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Any test may be annotated with a â€˜*â€™.&lt;/p>
&lt;p>This indicates that the test is a must-pass in order for the application or app store entry to be promoted. A failure of this test will generate a bug (MUST FIX).&lt;/p>
&lt;h2 id="actions-that-you-can-initiate-from-jira">Actions that you can initiate from JIRA&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Request application testing - This puts your application in the testing queue. We will note when testing has started (â€˜in progressâ€™) and when concluded, the ticket will be closed. The outcome will include notes and links to any issues generated (â€˜ticketsâ€™). This phase may include as many iterations as needed to get your application ready. If necessary, the Application Release Workflow (ARW) will be updated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Request public (general) authorization. We will note when testing has started (â€˜in progressâ€™) and this request will trigger a review of your app store entry and any outstanding bugs. Note there is no implied testing of your application, simply a review of outstanding issues (tickets) and of the app store entry. Success at this stage will advance the Application Release Workflow (ARW) and you will now be able to request public (general) release.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Request public (general) release. This request states that you have coordinated with the Partner Application Manager (Joe Dunne) and the Onshape marketing department and general agreement has been reached that now is the time - Congratulations!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="addendum-a---application-testing-criteria">Addendum A - Application Testing Criteria&lt;/h2>
&lt;ol>
&lt;li>Applied to all Applications&lt;/li>
&lt;li>Applies to Integrated Cloud Applications&lt;/li>
&lt;li>Applies to Connected Cloud Applications&lt;/li>
&lt;li>Applies to Connected Desktop Applications&lt;/li>
&lt;/ol>
&lt;p>x Denotes that this is a â€˜must-passâ€™. A failure of this test results in a must-fix&lt;/p>
&lt;ul>
&lt;li>(1)x The application must use the Onshape OAUTH mechanism&lt;/li>
&lt;li>(1)x The OAUTH must be against the correct stack&lt;/li>
&lt;li>(2)(3)x To be promoted to the Production stack, and hosted service must be on a monitored production server with worldwide 24/7 availability.&lt;/li>
&lt;li>(2)(3) The application should not generate any avoidable console (browser) errors&lt;/li>
&lt;li>(1) The application should should provide one or more of the following options;
&lt;ul>
&lt;li>Login using the Onshape ID (account created silently on first use)&lt;/li>
&lt;li>Login with partner product account credentials&lt;/li>
&lt;li>Create a new partner account&lt;/li>
&lt;li>The user should not have to leave the registration workflow to complete a pre-requisite&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(1) The application must be capable of managing/displaying documents in excess of 20 - suggested strategies include;
&lt;ul>
&lt;li>Use of a â€˜Nextâ€™ button to load the next 20&lt;/li>
&lt;li>Infinite scroll (loading the next 20 if/when the scrollbar reaches the bottom of the dialog&lt;/li>
&lt;li>The application must display â€˜reasonableâ€™ performance when reading documents, workspaces, elements and parts. Consider at-scale than an account may have thousands of documents, many with multiple workspaces and each with multiple elements. Strategies may include any combination of;&lt;/li>
&lt;li>Displaying the most-recently-opened first&lt;/li>
&lt;li>Displaying a counter of documents/workspaces/elements read&lt;/li>
&lt;li>Progressive loading&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(1) The application should correctly list valid documents when â€˜per document app accessâ€™ is turned on.&lt;/li>
&lt;li>(1) The application should correctly handle selection of versions&lt;/li>
&lt;li>(1) The application should correctly handle selection of workspaces (branches)&lt;/li>
&lt;li>(1) The application should correctly handle/display elements that;
&lt;ul>
&lt;li>Are part studios that contain nothing&lt;/li>
&lt;li>Are assemblies that contain nothing&lt;/li>
&lt;li>Are part studios that contain only surfaces&lt;/li>
&lt;li>Are part studios that contain only â€˜wireâ€™ data (eg helices)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(1) The application should appropriately handle revocation of a grant&lt;/li>
&lt;/ul>
&lt;h2 id="addendum-b---app-store-testing-criteria">Addendum B - App Store Testing Criteria&lt;/h2>
&lt;ol>
&lt;li>Applied to all Applications&lt;/li>
&lt;li>Applies to Integrated Cloud Applications&lt;/li>
&lt;li>Applies to Connected Cloud Applications&lt;/li>
&lt;li>Applies to Connected Desktop Applications&lt;/li>
&lt;li>Required for deployment to production&lt;/li>
&lt;li>Only where the application is using Onshape billing&lt;/li>
&lt;/ol>
&lt;p>x Denotes that this is a â€˜must-passâ€™. A failure of this test results in a must-fix&lt;/p>
&lt;ul>
&lt;li>(1) The application should have a descriptive name&lt;/li>
&lt;li>(1) The application summary should be accurate&lt;/li>
&lt;li>(1)x The redirect URLS should be valid&lt;/li>
&lt;li>(2)x The iframe URL should be valid&lt;/li>
&lt;li>(1) The Grant (permissions) request should be no more than is needed&lt;/li>
&lt;li>(1) The Application Type should be correctly set&lt;/li>
&lt;li>(1) Team Visibility should be set&lt;/li>
&lt;li>(1) The Category should be appropriate&lt;/li>
&lt;li>(1) The application description should be accurate&lt;/li>
&lt;li>(1) The Sign-In URL should be valid&lt;/li>
&lt;li>(1) The pricing summary should be accurate. For instance, it cannot say â€˜Freeâ€™ if this is a trial - it should say â€˜Free for 30 days and then $30/month&lt;/li>
&lt;li>(1) Any pay-plans should have an accurate description&lt;/li>
&lt;li>(1) The support URL should point to a resource for help - this can be;
&lt;ul>
&lt;li>A support ticketing system (eg Zendesk)&lt;/li>
&lt;li>A page giving a telephone number&lt;/li>
&lt;li>A page giving an email address&lt;/li>
&lt;li>A forum&lt;/li>
&lt;li>It cannot be to an FAQ page (unless that page also contains one of the other options)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(1)The EULA link should point to an English Language EULA&lt;/li>
&lt;/ul></description></item><item><title>Docs: Model Translation</title><link>https://onshape-public.github.io/docs/translation/</link><pubDate>Mon, 18 May 2020 20:43:20 -0400</pubDate><guid>https://onshape-public.github.io/docs/translation/</guid><description>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>This document describes the APIs provided by Onshape for model translation. This document makes reference to specific APIs using the naming convention &lt;em>Group Name - Api Name&lt;/em>, where the &lt;group name> identifies an API group and &lt;api name> identifies a specific API defined in the group. See the Glassworks API Explorer for details on the APIs.&lt;/p>
&lt;p>Onshape provides several APIs to support model format translation. These fall into 3 basic categories&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#simple-conversions">Simple conversions&lt;/a> - these support translation of Onshape content into STL and Parasolid format.&lt;/li>
&lt;li>&lt;a href="#general-translations">General translation&lt;/a> - these support translation from a variety of formats into a variety of other formats.&lt;/li>
&lt;li>&lt;a href="#import-translation">Import translation&lt;/a> - these translation operations are performed by default when a translatable file is uploaded to a blob element&lt;/li>
&lt;/ol>
&lt;h2 id="simple-conversions">Simple conversions&lt;/h2>
&lt;p>Simple conversions are limited to generating Parasolid and STL output. Most of the interfaces defined here operate by requesting an HTTP redirect to a different URL where the request will be fulfilled. Applications must be sure that they are explicitly handling the redirect and attaching authentication headers to the follow-up request or it will fail.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>STL-specific&lt;/p>
&lt;p>Onshape Part Studio tabs and individual parts can be translated to STL format using the dedicated APIs&lt;/p>
&lt;ul>
&lt;li>&lt;em>Part Studios - Export Part Studio to STL&lt;/em>&lt;/li>
&lt;li>&lt;em>Parts - Export Part to STL&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>These interfaces require a Part Studio element Id and all use redirect behavior.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Parasolid-specific&lt;/p>
&lt;p>Onshape Part Studio tabs and individual parts can be translated to Parasolid format using the dedicated APIs&lt;/p>
&lt;ul>
&lt;li>&lt;em>Part Studios - Export Part Studio to STL&lt;/em>&lt;/li>
&lt;li>&lt;em>Parts - Export Part to STL&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>These interfaces also require a Part Studio element Id and all use redirect behavior.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Multi-purpose&lt;/p>
&lt;p>In addition to the format-specific APIs defined for Parts and Part Studios, there are two similar multi-purpose APIs that can convert multiple source types to both STL and Parasolid.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;em>Documents - Export Element&lt;/em> (POST)&lt;/p>
&lt;p>This form requires the caller to perform an HTTP POST operation followed by an HTTP GET to a URL returned by the POST operation. There is no HTTP redirect performed; the application must explicitly follow the returned link.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Documents - Export Element&lt;/em> (GET)&lt;/p>
&lt;p>This form takes all configuration information in the form of query parameters and uses the redirect mechanism.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>These APIs allow conversion of Assemblies as well as Parts and Part Studios into Either STL or Parasolid.
The primary reason for the existence of the POST form of the API in addition to the GET form of the API is to overcome limits in URL and HTTP header length that can be exceeded when using long lists of part Id values.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="general-translations">General translations&lt;/h2>
&lt;p>The simple conversions listed above perform the format conversion synchronously, returning the output immediately after some processing delay. Other format conversions are more complex and time-consuming, and in many cases, cannot be completed quickly enough to prevent connection errors. The solution we use instead is a model where the application performs a 3-step process:&lt;/p>
&lt;ol>
&lt;li>HTTP POST operation to create a translation request&lt;/li>
&lt;li>Poll for operation completion or wait for webhook notification of completion&lt;/li>
&lt;li>HTTP GET operation to retrieve the translation result.&lt;/li>
&lt;/ol>
&lt;h3 id="translation-formats">Translation Formats&lt;/h3>
&lt;p>The general translation APIs do not support STL, but do support a wide range of industry formats.&lt;/p>
&lt;h4 id="output-formats">Output Formats&lt;/h4>
&lt;p>Supported output formats currently include PARASOLID, STEP, ACIS, IGES, SOLIDWORKS, ONSHAPE.&lt;/p>
&lt;h4 id="source-formats">Source Formats&lt;/h4>
&lt;p>We allow a larger range of input formats that output formats. In addition to the formats listed above for input format,
you can also convert from Part Studio, Assembly, PROE, NX, CATIA and INVENTOR.&lt;/p>
&lt;h3 id="apis">APIs&lt;/h3>
&lt;p>We provide APIS to allow programatically determining supported formats:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;em>Translations - Get Translation Formats&lt;/em>&lt;/p>
&lt;p>This API presents the full list of supported translation formats&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Part Studios - Get Translation Formats&lt;/em>&lt;/p>
&lt;p>Returns a list of the formats to which a particular Part Studio tab can be converted. Note that empty Part Studio
tabs cannot be converted to other formats.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Assemblies - Get Translation Formats&lt;/em>&lt;/p>
&lt;p>Returns a list of the formats to which a particular Assembly tab can be converted. Note that empty Assembly
tabs cannot be converted to other formats.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Note that the source format for a translation is currently always automatically detected by Onshape. Part Studios and Assemblies are known to be ONSHAPE format. File uploads have their type determined by the filename suffix. For example, a file named part7.step is assumed to be in STEP format.&lt;/p>
&lt;h3 id="translation-initiation">Translation initiation&lt;/h3>
&lt;p>Translation is initiated by performing an HTTP POST operation to one of the &amp;ldquo;Create Translation&amp;rdquo; APIs.&lt;/p>
&lt;p>These APIs have some common options:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>formatName&lt;/p>
&lt;p>This is the name of the format to which the source will be translated. This formatName must be one of the supported
names (names are case-sensitive). Note that translation to ONSHAPE format requires storeInDocument=true.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>storeInDocument&lt;/p>
&lt;p>Allows the caller to decide whether the output should be part of the document (as a Part Studio, Assembly or Blob
tab) or whether the output should be external to the document.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>APIs which use an upload or blob element common options when translating to ONSHAPE:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>flattenAssemblies&lt;/p>
&lt;p>If the source file contains an assembly and flattenAssemblies is set to true, the assembly structure is removed and
a single part studio is created.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>yAxisIsUp&lt;/p>
&lt;p>Allows the application to tell Onshape translation whether the Y axis or Z Axis is the &amp;ldquo;Up&amp;rdquo; direction.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="apis-1">APIs&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;em>Translations - Create translation from upload&lt;/em>&lt;/p>
&lt;p>This API allows an application to provide an input source file that will be converted to another format without
requiring that the uploaded file be stored as a blob tab in the document. The API requires a document to be provided
to define ownership context, but the uploaded file is not stored in the document.&lt;/p>
&lt;p>The file is uploaded as multipart form data. Each of the API parameters is a separate field in the multipart upload.
The two required fields are &amp;ldquo;file&amp;rdquo; and &amp;ldquo;formatName&amp;rdquo;. The file part must contain the upload and should normally have
a filename attribute set. The filename attribute can be omitted if the form data also has an encodedFilename field
that contains the filename in URL-encoded form.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Blob Elements - Create Translation&lt;/em>&lt;/p>
&lt;p>A blob element containing a translatable file can be translated using this API. The blob element can be the result
of a previous upload or it can be the output of a previous translation operation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Part Studios - Create Translation&lt;/em>&lt;/p>
&lt;p>Initiate translation for a Part Studio element&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Assemblies - Create Translation&lt;/em>&lt;/p>
&lt;p>Initiate translation for an Assembly element&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The response from these APIs includes the fields:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>id&lt;/p>
&lt;p>An identifier for the created translation operation. It can be used for later retrieval of translation results&lt;/p>
&lt;/li>
&lt;li>
&lt;p>href&lt;/p>
&lt;p>A URL for the &lt;em>Translations - Get Translation Status&lt;/em> API for this specific translation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>requestState
Identifies the state of the translation request. The request will be done when the state changes from ACTIVE to
DONE or FAILED. If FAILED, the translation was not successfully completed. If DONE, it completed successfully.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="waiting-for-translation-completion">Waiting for translation completion&lt;/h3>
&lt;p>The simplest way to determine when the translation is complete is to poll. You do this in one of two ways (which are really the same thing):&lt;/p>
&lt;ul>
&lt;li>Call the href returned in the translation response, which returns an updated state object&lt;/li>
&lt;li>Call the &lt;em>Translation - Get Translation Status&lt;/em> API, using the id returned in the translation response&lt;/li>
&lt;/ul>
&lt;p>Once the requestState changes to some value other than ACTIVE you will be ready to retrieve results.&lt;/p>
&lt;p>An alternate way to wait for translation completion is to register a webhook and wait for a notification to be delivered. This is discussed &lt;a href="#webhook-translation-completion-notification">later&lt;/a>.&lt;/p>
&lt;h3 id="retrieving-results">Retrieving results&lt;/h3>
&lt;p>Once a translation requestState becomes DONE, results are available to be used. How they are accessed depends on the specifics of the translation. A completed request has several additional fields that may be populated. If your original request specified storeInDocument=false then the results are stored as external data, in which case the resultExternalDataIds status field provides identifiers to be used for retrieval (see External Data, below). If the request specified storeInDocument=true then the resultElementIds field will be populated (see Element Data, below).&lt;/p>
&lt;h4 id="external-data">External Data&lt;/h4>
&lt;p>External data is data that is associated with, but external to the document used as translation context. This data is not versioned as is done with in-document data. A translation request to a format other than ONSHAPE currently always produces a single data file (from resultExternalDataIds).&lt;/p>
&lt;p>To retrieve an external data file, use the API
Documents - Download External Data&lt;/p>
&lt;h4 id="element-data">Element Data&lt;/h4>
&lt;p>When storeInDocument=true is specified, the results are stored as new elements in the document. The new elements are reported in the resultElementIds field in the translation status response. If the selected format is ONSHAPE, these elements will be Assemblies/Part Studios, and there may be multiple created elements. If the selected format is something other than ONSHAPE, there will be a single blob element result.&lt;/p>
&lt;p>A blob element result can be extracted using the &lt;em>Blob Elements - Download File From Blob Element&lt;/em> API.&lt;/p>
&lt;h2 id="import-translation">Import Translation&lt;/h2>
&lt;p>When uploading a file to a blob element, either as a new element or an update to an existing element, if the file
is a recognized format for import, it will, by default, be converted into ONSHAPE format. This behavior can be
overridden by the application, if desired.&lt;/p>
&lt;h2 id="webhook-translation-completion-notification">Webhook Translation Completion notification&lt;/h2>
&lt;p>If an application runs in a server with a network address that is reachable across the internet, the application may choose to use webhooks to find out about translation completion. For reliable operation, a webhook should be registered for the translation document prior to initiating translation. If registered after translation initiation, the notification might be lost. See the help document on Webhook Notifications for more details.&lt;/p></description></item><item><title>Docs: Webhook Notifications</title><link>https://onshape-public.github.io/docs/webhook/</link><pubDate>Mon, 18 May 2020 20:44:05 -0400</pubDate><guid>https://onshape-public.github.io/docs/webhook/</guid><description>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>Webhook notifications allow an application to register to receive notifications of certain events that occur within the
Onshape environment. To receive a notification, an application must expose an endpoint that Onshape can call.&lt;/p>
&lt;h2 id="example-code">Example Code&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/onshape-public/onshape-clients/blob/master/python/test/test_webhooks.py#L126">Python&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="events">Events&lt;/h2>
&lt;p>Each type of event that an application may receive notifications for has a unique identifier known as the event type.
Event types are grouped into Event Groups. Each group shares specification requirements, as described below.&lt;/p>
&lt;h3 id="event-groups">Event Groups&lt;/h3>
&lt;p>Event types are categorized into several different groups based on the dominant user resource of the event. The group
that a given event is part of defines the required parameters needed in the registration process to identify the
resource or group of resources to watch. For instance, if registering for an event in the &lt;code>document&lt;/code> event group,
the application must identify either a specific document&amp;rsquo;s id or a specific company&amp;rsquo;s id. If registered for a company,
the event will be registered for all present and future documents owned by the company.&lt;/p>
&lt;h4 id="application-group">Application Group&lt;/h4>
&lt;p>Monitor changes to applications.&lt;/p>
&lt;h5 id="registration-requirements">Registration Requirements&lt;/h5>
&lt;ul>
&lt;li>&lt;code>clientId&lt;/code>&lt;/li>
&lt;/ul>
&lt;h5 id="supported-event-types">Supported Event Types&lt;/h5>
&lt;ul>
&lt;li>&lt;code>onshape.user.lifecycle.updateappsettings&lt;/code> - occurs when user application settings are modified&lt;/li>
&lt;/ul>
&lt;h4 id="document-group">Document Group&lt;/h4>
&lt;p>Monitor various aspects of document changes.&lt;/p>
&lt;h5 id="registration-requirements-1">Registration Requirements&lt;/h5>
&lt;ul>
&lt;li>&lt;code>documentId&lt;/code> OR &lt;code>companyId&lt;/code> must be specified in the registration body.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Note&lt;/strong>: only &lt;code>documentId&lt;/code> is valid for the &lt;code>onshape.document.lifecycle.statechange&lt;/code>.&lt;/p>
&lt;h5 id="supported-event-types-1">Supported Event Types&lt;/h5>
&lt;ul>
&lt;li>&lt;code>onshape.model.lifecycle.changed&lt;/code> - occurs when a change to a model has been made&lt;/li>
&lt;li>&lt;code>onshape.model.translation.complete&lt;/code> - occurs when a translation request is completed&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.metadata&lt;/code> - occurs when part or element metadata is modified&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.createversion&lt;/code> - occurs when a new version of a document is created&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.createworkspace&lt;/code> - occurs when a new workspace is created&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.createelement&lt;/code> - occurs when a new element is created&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.deleteelement&lt;/code> - occurs when an element is deleted&lt;/li>
&lt;li>&lt;code>onshape.document.lifecycle.statechange&lt;/code> - occurs when an document changes state&lt;/li>
&lt;li>&lt;code>onshape.model.lifecycle.changed.externalreferences&lt;/code> - occurs when an external reference changes&lt;/li>
&lt;li>&lt;code>onshape.document.lifecycle.created&lt;/code> - occurs when a document is created&lt;/li>
&lt;li>&lt;code>onshape.revision.created&lt;/code> - occurs when a revision is created&lt;/li>
&lt;li>&lt;code>onshape.comment.create&lt;/code> - occurs when a comment is created in a document&lt;/li>
&lt;li>&lt;code>onshape.comment.update&lt;/code> - occurs when a comment is updated in a document&lt;/li>
&lt;li>&lt;code>onshape.comment.delete&lt;/code> - occurs when a deleted is deleted in a document&lt;/li>
&lt;/ul>
&lt;h4 id="workflow-group">Workflow Group&lt;/h4>
&lt;p>Monitor release management actions.&lt;/p>
&lt;h5 id="registration-requirements-2">Registration Requirements&lt;/h5>
&lt;ul>
&lt;li>&lt;code>companyId&lt;/code>&lt;/li>
&lt;/ul>
&lt;h5 id="supported-event-types-2">Supported Event Types&lt;/h5>
&lt;ul>
&lt;li>&lt;code>onshape.workflow.transition&lt;/code> - occurs when a revision or release package transitions through workflow states.&lt;/li>
&lt;/ul>
&lt;h4 id="lifecycle-group">Lifecycle Group&lt;/h4>
&lt;p>Monitor webhook changes.&lt;/p>
&lt;h5 id="registration-requirements-3">Registration Requirements&lt;/h5>
&lt;p>No requirements. This event type responds to any and all webhooks registered by the same application.&lt;/p>
&lt;h5 id="supported-event-types-3">Supported Event Types&lt;/h5>
&lt;ul>
&lt;li>&lt;code>webhook.ping&lt;/code> - occurs either in response to a request by an application to call a registered webhook, or as a post-registration validation initiated by Onshape&lt;/li>
&lt;li>&lt;code>webhook.register&lt;/code> - occurs in response to a notification registration API call&lt;/li>
&lt;li>&lt;code>webhook.unregister&lt;/code> - occurs in response to a notification deregistation API call&lt;/li>
&lt;/ul>
&lt;h2 id="webhook-registration">Webhook Registration&lt;/h2>
&lt;p>An application registers for event notification by making a REST call to the Onshape web service, providing a URL to
notify, and the required parameters for the event types to be registered, as mentioned in &lt;a href="#event-groups">Event Groups&lt;/a>.
If the registration request is well-formed, the registration API call returns information about the registration,
including a unique ID string. This ID string identifies the webhook registration. No de-duplication of notification
registrations is performed by the API. Each registration call will yield a new registration ID, even if the parameters
are identical to those passed in a prior call. Shortly after an application calls the notification registration API,
Onshape will make make an asynchronous trial notification call to the URL generated from the URL template with an event
type of webhook.register in order to test whether the application notification server is accessible. If the trial
notification delivery fails to return an HTTP 200 status code, the notification registration is cancelled. The trial
notification is usually delivered after the notification registration has been received by the application. However,
variations in network delays may result in the trial notification occurring before response is received and processed by
the application, so the notification handler should be ready to process notifications before the registration call is
made.&lt;/p>
&lt;h2 id="notifications">Notifications&lt;/h2>
&lt;p>Notifications are delivered to an application as an HTTP POST with a JSON body. The body includes information about the
identity of the registration request plus information specific to the event and notification message. An application may
register for notifications to a URL that uses either HTTP or HTTPS. If HTTPS is specified by the URL template, the
notification server must supply a certificate that is signed by a certificate authority (CA) recognized by Onshape.&lt;br>
Self-signed certificates as well as certificates signed by unrecognized CAs will be rejected, causing notification
delivery to fail.&lt;/p>
&lt;h2 id="notification-deregistration">Notification Deregistration&lt;/h2>
&lt;p>When an application no longer needs to be notified of changes specified by a particular notification registration, it should normally de-register the notification request. De-registration is performed by making an HTTP that specifies the hook to deregister. Onshape will attempt to call the deregistered hook with an event type of webhook.unregister as validation for the application that the de-registration is complete. If the application does not de-register the webhook, Onshape will continue delivering notifications until either the the application returns an error in response to a notification for the webhook, or fails to respond at all for an extended period of time.&lt;/p>
&lt;h2 id="notification-api-example-messages">Notification API example messages&lt;/h2>
&lt;p>registration&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:45:10.611-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;webhook.register&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;34795d2e5f5f44eeb61fb7b1&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;versionId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>ping&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:24.368-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;webhook.ping&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;6808d9a622644330b6cd95f5&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;versionId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>model change&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;onshape.model.lifecycle.changed&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;f925722bee1c43fc80fb5bb2&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;0f931a1ceba842299192823f&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;0f9c4392e5934f30b48ab645&amp;#34;,
&amp;#34;versionId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>document state change&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;onshape.document.lifecycle.statechange&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;0f9c4392e5934f30b48ab645&amp;#34;,
&amp;#34;versionId&amp;#34;: &amp;#34;000000000000000000000000&amp;#34;,
&amp;#34;documentState&amp;#34;: &amp;#34;TRASH&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>Possible values of documentState are:&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;ACTIVE&amp;rdquo; - document is in a normal, usable state&lt;/li>
&lt;li>&amp;ldquo;TRASH&amp;rdquo; - document has been moved to the trash (User can move out of trash to ACTIVE state)&lt;/li>
&lt;li>&amp;ldquo;DELETED&amp;rdquo; - document has been deleted&lt;/li>
&lt;/ul>
&lt;p>user application settings change&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;onshape.user.lifecycle.updateappsettings&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;f925722bee1c43fc80fb5bb2&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;0f931a1ceba842299192823f&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;userId&amp;#34;: &amp;#34;567953d60a1a5fbb95940333&amp;#34;,
&amp;#34;clientId&amp;#34;:&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXZY234567ABCDEFG=&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>translation completion&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;onshape.model.translation.complete&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;f925722bee1c43fc80fb5bb2&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;0f931a1ceba842299192823f&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;,
&amp;#34;data&amp;#34;: &amp;#34;Some data&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;0f9c4392e5934f30b48ab645&amp;#34;,
&amp;#34;userId&amp;#34;: &amp;#34;567953d60a1a5fbb95940333&amp;#34;,
&amp;#34;translationRequestId&amp;#34;: &amp;#34;4f5de10f9c4392e5934f30b4&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>comment create&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;timestamp&amp;#34;: &amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;,
&amp;#34;event&amp;#34;: &amp;#34;onshape.comment.create&amp;#34;,
&amp;#34;workspaceId&amp;#34;: &amp;#34;f925722bee1c43fc80fb5bb2&amp;#34;,
&amp;#34;elementId&amp;#34;: &amp;#34;0f931a1ceba842299192823f&amp;#34;,
&amp;#34;webhookId&amp;#34;: &amp;#34;544e91f7fb88ed44f5de1508&amp;#34;,
&amp;#34;messageId&amp;#34;: &amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;,
&amp;#34;documentId&amp;#34;: &amp;#34;0f9c4392e5934f30b48ab645&amp;#34;,
&amp;#34;commentId&amp;#34;: &amp;#34;567953d60a1a5fbb95940333&amp;#34;
}
&lt;/code>&lt;/pre></description></item></channel></rss>